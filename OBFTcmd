-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local ContentProvider = game:GetService("ContentProvider")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Constants
local INTRO_TEXT = "TCMD"
local WATERMARK_TEXT = "Made By hmmm5650"
local INTRO_DURATION = 8 -- Duration of the entire intro animation in seconds
local PARTICLE_COUNT = 60 -- Increased particle count for richer background
local PARTICLE_COLORS = {
    Color3.fromRGB(0, 100, 255),  -- Blue particles
    Color3.fromRGB(0, 150, 255),
    Color3.fromRGB(50, 200, 255)
}

-- Preload assets to prevent lag
ContentProvider:PreloadAsync({
    "rbxassetid://11173905963", -- Example of a potential custom font
    "rbxassetid://112490670948282",   -- Example particle texture
    "rbxassetid://120131404524020" -- Example icon image (can be replaced with your preferred icon)
})

-- Create ScreenGui with improved settings
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CinematicIntro"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 999 -- Ensure it's on top

-- Create layered background for depth effect
local background = Instance.new("Frame")
background.Name = "Background"
background.Size = UDim2.new(1, 0, 1, 0)
background.BackgroundColor3 = Color3.fromRGB(10, 10, 30)  -- Dark blue background
background.BackgroundTransparency = 1
background.ZIndex = 0
background.Parent = screenGui

-- Create gradient overlay for background
local bgGradient = Instance.new("UIGradient")
bgGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 20, 50)),  -- Dark blue gradient
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 40))
})
bgGradient.Rotation = 90
bgGradient.Transparency = NumberSequence.new(0.7)
bgGradient.Parent = background

-- Create particle system with improved visuals
local particles = {}
for i = 1, PARTICLE_COUNT do
    local particle = Instance.new("ImageLabel") -- Using ImageLabel for potential texture
    particle.Name = "Particle_"..i
    particle.Size = UDim2.new(0, math.random(4, 12), 0, math.random(4, 12))
    particle.Position = UDim2.new(0, math.random(0, 1000), 0, math.random(0, 600))
    particle.BackgroundTransparency = 1
    particle.ImageColor3 = PARTICLE_COLORS[math.random(1, #PARTICLE_COLORS)]
    particle.ImageTransparency = 0.7
    particle.Image = "rbxassetid://112490670948282" -- Optional particle texture
    particle.ZIndex = 1
    particle.Parent = background
    
    -- Store initial position for animation with varied properties
    particles[i] = {
        instance = particle,
        speed = math.random(15, 40),
        direction = Vector2.new(math.random() * 2 - 1, math.random() * 2 - 1).Unit,
        rotationSpeed = math.random(-5, 5),
        currentRotation = 0
    }
end

-- Create TextLabel for intro text with improved styling
local textLabel = Instance.new("TextLabel")
textLabel.Name = "Title"
textLabel.Text = INTRO_TEXT
textLabel.Size = UDim2.new(0, 0, 0, 0)
textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.BackgroundTransparency = 1
textLabel.Font = Enum.Font.GothamBlack
textLabel.TextScaled = true
textLabel.TextStrokeTransparency = 0.8
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.ZIndex = 3
textLabel.TextTransparency = 1
textLabel.Parent = screenGui

-- Create advanced text effects
local textShadow = textLabel:Clone()
textShadow.Name = "TextShadow"
textShadow.TextColor3 = Color3.fromRGB(0, 100, 200)  -- Blue shadow
textShadow.TextTransparency = 0.9
textShadow.Position = UDim2.new(0.5, 4, 0.5, 4) -- Offset for shadow
textShadow.ZIndex = 2
textShadow.Parent = screenGui

-- Create gradient underlay for text (KEEPING ORIGINAL GRADIENT FOR TITLE)
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 150)),  -- Original green
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 200, 255)),  -- Original teal
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 255))  -- Original purple
})
gradient.Rotation = 0
gradient.Enabled = false
gradient.Parent = textLabel

-- Create TextLabel for watermark with improved styling
local watermarkLabel = Instance.new("TextLabel")
watermarkLabel.Name = "Watermark"
watermarkLabel.Text = WATERMARK_TEXT
watermarkLabel.Size = UDim2.new(0.3, 0, 0.05, 0)
watermarkLabel.Position = UDim2.new(0.5, 0, 0.85, 0)
watermarkLabel.AnchorPoint = Vector2.new(0.5, 0.5)
watermarkLabel.TextColor3 = Color3.fromRGB(100, 180, 255)  -- Light blue watermark
watermarkLabel.BackgroundTransparency = 1
watermarkLabel.Font = Enum.Font.GothamMedium
watermarkLabel.TextSize = 18
watermarkLabel.TextTransparency = 1
watermarkLabel.ZIndex = 3
watermarkLabel.Parent = screenGui

-- Create transparent icon in top right corner
local icon = Instance.new("ImageLabel")
icon.Name = "TopRightIcon"
icon.Size = UDim2.new(0, 50, 0, 50) -- Adjust size as needed
icon.Position = UDim2.new(1, -60, 0, 10) -- 10 pixels from top, 60 pixels from right
icon.AnchorPoint = Vector2.new(1, 0) -- Anchored to top-right
icon.BackgroundTransparency = 1
icon.ImageTransparency = 0.7 -- Semi-transparent
icon.Image = "rbxassetid://120131404524020" -- Replace with your preferred icon image ID
icon.ZIndex = 3

-- Add rounded corners to the icon
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0.2, 0) -- 20% of the icon's size (adjust as needed)
corner.Parent = icon

icon.Parent = screenGui

-- Create cinematic effects
local blurEffect = Instance.new("BlurEffect")
blurEffect.Name = "CinematicBlur"
blurEffect.Size = 24
blurEffect.Parent = Lighting

local colorCorrection = Instance.new("ColorCorrectionEffect")
colorCorrection.Name = "CinematicColor"
colorCorrection.TintColor = Color3.fromRGB(180, 200, 255)  -- Cool blue tint
colorCorrection.Brightness = -0.1
colorCorrection.Contrast = 0.1
colorCorrection.Saturation = -0.1
colorCorrection.Parent = Lighting

local dofEffect = Instance.new("DepthOfFieldEffect")
dofEffect.Name = "CinematicDOF"
dofEffect.FarIntensity = 0.1
dofEffect.FocusDistance = 0.05
dofEffect.InFocusRadius = 5
dofEffect.NearIntensity = 0.75
dofEffect.Parent = Lighting

-- Improved tween timing with more dynamic animation
local fadeInTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.35,
    Enum.EasingStyle.Quint,
    Enum.EasingDirection.Out,
    0,
    false,
    0
)

local holdTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.3,
    Enum.EasingStyle.Sine,
    Enum.EasingDirection.InOut,
    0,
    false,
    0
)

local fadeOutTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.35,
    Enum.EasingStyle.Back,
    Enum.EasingDirection.In,
    0,
    false,
    0
)

-- Additional tweens for enhanced effects
local bgFadeInTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.25,
    Enum.EasingStyle.Quad,
    Enum.EasingDirection.Out,
    0,
    false,
    0
)

local gradientRotateTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.6,
    Enum.EasingStyle.Linear,
    Enum.EasingDirection.InOut,
    0,
    false,
    0
)

-- Tween goals with more dynamic animations
local fadeInGoals = {
    TextTransparency = 0, 
    Size = UDim2.new(0.7, 0, 0.7, 0),
    TextStrokeTransparency = 0.5
}

local shadowFadeInGoals = {
    TextTransparency = 0.7,
    Size = UDim2.new(0.7, 0, 0.7, 0)
}

local holdGoals = {
    Rotation = 5,
    TextColor3 = Color3.fromRGB(200, 240, 255)  -- Light blue text during hold
}

local fadeOutGoals = {
    TextTransparency = 1, 
    Size = UDim2.new(1.2, 0, 1.2, 0),
    Rotation = -5,
    TextStrokeTransparency = 1
}

local blurOutGoals = {Size = 0}
local watermarkFadeInGoals = {
    Position = UDim2.new(0.5, 0, 0.85, 0), 
    TextTransparency = 0.2,
    TextColor3 = Color3.fromRGB(0, 150, 255)  -- Blue watermark
}

local watermarkFadeOutGoals = {
    Position = UDim2.new(0.5, 0, 0.9, 0), 
    TextTransparency = 1
}

local bgFadeInGoals = {BackgroundTransparency = 0.85}
local bgFadeOutGoals = {BackgroundTransparency = 1}
local gradientEnableGoals = {Enabled = true}
local gradientDisableGoals = {Enabled = false}
local gradientRotateGoals = {Rotation = 360}

-- Icon animation goals
local iconFadeInGoals = {ImageTransparency = 0.3}
local iconFadeOutGoals = {ImageTransparency = 1}

-- Create tweens
local fadeInTween = TweenService:Create(textLabel, fadeInTweenInfo, fadeInGoals)
local shadowFadeInTween = TweenService:Create(textShadow, fadeInTweenInfo, shadowFadeInGoals)
local holdTween = TweenService:Create(textLabel, holdTweenInfo, holdGoals)
local fadeOutTween = TweenService:Create(textLabel, fadeOutTweenInfo, fadeOutGoals)
local shadowFadeOutTween = TweenService:Create(textShadow, fadeOutTweenInfo, fadeOutGoals)
local blurOutTween = TweenService:Create(blurEffect, fadeOutTweenInfo, blurOutGoals)
local watermarkFadeInTween = TweenService:Create(watermarkLabel, fadeInTweenInfo, watermarkFadeInGoals)
local watermarkFadeOutTween = TweenService:Create(watermarkLabel, fadeOutTweenInfo, watermarkFadeOutGoals)
local bgFadeInTween = TweenService:Create(background, bgFadeInTweenInfo, bgFadeInGoals)
local bgFadeOutTween = TweenService:Create(background, fadeOutTweenInfo, bgFadeOutGoals)
local gradientEnableTween = TweenService:Create(gradient, fadeInTweenInfo, gradientEnableGoals)
local gradientDisableTween = TweenService:Create(gradient, fadeOutTweenInfo, gradientDisableGoals)
local gradientRotateTween = TweenService:Create(gradient, gradientRotateTweenInfo, gradientRotateGoals)
local iconFadeInTween = TweenService:Create(icon, fadeInTweenInfo, iconFadeInGoals)
local iconFadeOutTween = TweenService:Create(icon, fadeOutTweenInfo, iconFadeOutGoals)

-- Enhanced particle animation with rotation
local particleConnection
local function animateParticles(dt)
    for _, particle in ipairs(particles) do
        local currentPos = particle.instance.Position
        local moveAmount = particle.speed * dt
        local newX = (currentPos.X.Offset + particle.direction.X * moveAmount) % 1000
        local newY = (currentPos.Y.Offset + particle.direction.Y * moveAmount) % 600
        
        particle.currentRotation = (particle.currentRotation + particle.rotationSpeed * dt) % 360
        particle.instance.Rotation = particle.currentRotation
        particle.instance.Position = UDim2.new(0, newX, 0, newY)
    end
end

-- Function to play intro animation with improved sequencing
local function playIntroAnimation()
    -- Parent the ScreenGui to the player's PlayerGui
    local player = Players.LocalPlayer
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    -- Start particle animation
    particleConnection = RunService.Heartbeat:Connect(animateParticles)
    
    -- Initial state
    background.BackgroundTransparency = 1
    
    -- Play background fade in
    bgFadeInTween:Play()
    
    -- Play fade-in animations
    fadeInTween:Play()
    shadowFadeInTween:Play()
    gradientEnableTween:Play()
    gradientRotateTween:Play()
    iconFadeInTween:Play() -- Fade in the icon
    
    -- Delayed watermark appearance
    task.delay(INTRO_DURATION * 0.25, function()
        watermarkFadeInTween:Play()
    end)
    
    -- Wait for fade in to complete
    fadeInTween.Completed:Wait()
    
    -- Play hold animation
    holdTween:Play()
    holdTween.Completed:Wait()
    
    -- Play fade-out animations
    fadeOutTween:Play()
    shadowFadeOutTween:Play()
    watermarkFadeOutTween:Play()
    blurOutTween:Play()
    bgFadeOutTween:Play()
    gradientDisableTween:Play()
    iconFadeOutTween:Play() -- Fade out the icon
    
    -- Wait for animations to complete
    fadeOutTween.Completed:Wait()
    
    -- Clean up
    particleConnection:Disconnect()
    screenGui:Destroy()
    blurEffect:Destroy()
    colorCorrection:Destroy()
    dofEffect:Destroy()
end

-- Play the intro animation with error handling
local success, err = pcall(playIntroAnimation)
if not success then
    warn("Intro animation failed: " .. err)
    -- Clean up in case of failure
    if screenGui then screenGui:Destroy() end
    if blurEffect then blurEffect:Destroy() end
    if colorCorrection then colorCorrection:Destroy() end
    if dofEffect then dofEffect:Destroy() end
end
task.wait()

-- Place this in a LocalScript (for client-side freezing) or a regular Script (for server-side freezing)
-- Recommended location: StarterPlayerScripts or StarterGui for LocalScript

local freezeDuration = 3 -- seconds to freeze the game

local function freezeGame(duration)
    -- Get the current time
    local startTime = os.clock()
    
    -- Freeze the game by creating an infinite loop that lasts for the duration
    while os.clock() - startTime < duration do
        -- This loop will block all other Lua execution
        -- Note: This only freezes Lua, not the physics engine
    end
    
    print("loaded all commands in " .. duration .. " seconds")
end

-- Call the freeze function
freezeGame(freezeDuration)

task.wait()

local player = Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "NotificationGui"
screenGui.Parent = gui
screenGui.ResetOnSpawn = false

-- Create a sound folder in SoundService for our notification sounds
local notificationSounds = Instance.new("Folder")
notificationSounds.Name = "NotificationSounds"
notificationSounds.Parent = SoundService

-- Sound IDs and configurations
local soundConfigs = {
    NotificationAppear = {id = 3023237993, volume = 0.1},
    NotificationDisappear = {id = 18595195017, volume = 0.1},
    NotificationHover = {id = 7218169592, volume = 0.1},
    NotificationClick = {id = 177266782, volume = 0.1},
    NotificationPulse = {id = 10066936758, volume = 0.1}
}
-- Function to play sounds
local function playSound(soundName)
    local config = soundConfigs[soundName]
    if not config then return end
    
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://"..config.id
    sound.Volume = config.volume
    sound.Parent = notificationSounds
    sound:Play()
    
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

-- Notification function
function showNotification(title, message, duration, color)
    duration = duration or 5
    color = color or Color3.fromRGB(0, 170, 255)

    -- Play appear sound
    playSound("NotificationAppear")

    -- Main frame
    local frame = Instance.new("Frame")
    frame.Name = "Notification"
    frame.Size = UDim2.new(0.35, 0, 0, 70)
    frame.Position = UDim2.new(1, 10, 0.85, 0)
    frame.AnchorPoint = Vector2.new(1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frame.BackgroundTransparency = 0.8  -- Start more transparent for dramatic fade-in
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    frame.ZIndex = 10
    frame.ClipsDescendants = true  -- For the ripple effect

    -- Shadow with initial scale for pop effect
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageTransparency = 0.9  -- Start more transparent
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 118, 118)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame

    -- Rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    -- Accent line
    local accent = Instance.new("Frame")
    accent.Name = "Accent"
    accent.Size = UDim2.new(0, 0, 0, 2)  -- Start with 0 width for animation
    accent.Position = UDim2.new(0, 0, 0, 0)
    accent.BackgroundColor3 = color
    accent.BorderSizePixel = 0
    accent.ZIndex = frame.ZIndex + 1
    accent.Parent = frame

    -- Title with initial scale for bounce effect
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(0, 255, 180)
    titleLabel.TextTransparency = 1  -- Start invisible for fade-in
    titleLabel.TextSize = 15
    titleLabel.Font = Enum.Font.Code
    titleLabel.Size = UDim2.new(1, -40, 0, 18)
    titleLabel.Position = UDim2.new(0, 10, 0, 8)
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.BackgroundTransparency = 1
    titleLabel.ZIndex = frame.ZIndex + 1
    titleLabel.Parent = frame

    -- Message
    local messageLabel = Instance.new("TextLabel")
    messageLabel.Name = "Message"
    messageLabel.Text = message
    messageLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    messageLabel.TextTransparency = 1  -- Start invisible for fade-in
    messageLabel.TextSize = 14
    messageLabel.Font = Enum.Font.Code
    messageLabel.Size = UDim2.new(1, -20, 0, 35)
    messageLabel.Position = UDim2.new(0, 10, 0, 28)
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextYAlignment = Enum.TextYAlignment.Top
    messageLabel.BackgroundTransparency = 1
    messageLabel.ZIndex = frame.ZIndex + 1
    messageLabel.Parent = frame

    -- Close button with hover effects
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Text = "×"
    closeButton.TextColor3 = Color3.fromRGB(180, 180, 180)
    closeButton.TextTransparency = 1  -- Start invisible for fade-in
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.Code
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0, 6)
    closeButton.BackgroundTransparency = 1
    closeButton.ZIndex = frame.ZIndex + 1
    closeButton.Parent = frame

    -- Add a subtle glow effect
    local glow = Instance.new("ImageLabel")
    glow.Name = "Glow"
    glow.Image = "rbxassetid://5028857084"
    glow.ImageColor3 = color
    glow.ImageTransparency = 1  -- Start invisible
    glow.ScaleType = Enum.ScaleType.Slice
    glow.SliceCenter = Rect.new(24, 24, 24, 24)
    glow.Size = UDim2.new(1, 40, 1, 40)
    glow.Position = UDim2.new(0.5, -20, 0.5, -20)
    glow.AnchorPoint = Vector2.new(0.5, 0.5)
    glow.BackgroundTransparency = 1
    glow.ZIndex = frame.ZIndex - 1
    glow.Parent = frame

    -- Add a ripple effect for when the notification appears
    local ripple = Instance.new("Frame")
    ripple.Name = "Ripple"
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.BackgroundColor3 = Color3.new(1, 1, 1)
    ripple.BackgroundTransparency = 0.9
    ripple.ZIndex = frame.ZIndex + 2
    local rippleCorner = Instance.new("UICorner")
    rippleCorner.CornerRadius = UDim.new(1, 0)
    rippleCorner.Parent = ripple
    ripple.Parent = frame

    -- Pulse animation for accent line
    local pulseConnection
    local function startPulse()
        playSound("NotificationPulse")
        
        local targetColor = Color3.new(color.R * 1.2, color.G * 1.2, color.B * 1.2)
        local pulseIn = TweenService:Create(accent, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, -1, true), {
            BackgroundColor3 = targetColor
        })
        pulseIn:Play()
    end

    -- Slide in animation with bounce
    local slideIn = TweenService:Create(frame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(1, -10, 0.85, 0),
        BackgroundTransparency = 0.1
    })
    
    -- Pop effect for shadow
    local shadowPop = TweenService:Create(shadow, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        ImageTransparency = 0.6,
        Size = UDim2.new(1, 30, 1, 30),
        Position = UDim2.new(0, -15, 0, -15)
    })
    
    -- Glow effect
    local glowFadeIn = TweenService:Create(glow, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {
        ImageTransparency = 0.8
    })
    
    -- Ripple effect animation
    local rippleExpand = TweenService:Create(ripple, TweenInfo.new(0.6, Enum.EasingStyle.Quad), {
        Size = UDim2.new(2, 0, 2, 0),
        BackgroundTransparency = 1
    })
    
    -- Fade in content with slight delay between elements
    local fadeIn = TweenService:Create(titleLabel, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
        TextTransparency = 0
    })
    local fadeIn2 = TweenService:Create(messageLabel, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
        TextTransparency = 0
    })
    local fadeIn3 = TweenService:Create(closeButton, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
        TextTransparency = 0
    })
    
    -- Accent line grow animation with overshoot
    local accentGrow = TweenService:Create(accent, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(1, 0, 0, 2)
    })
    
    -- Frame fade in with slight scale effect
    local frameFadeIn = TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
        BackgroundTransparency = 0.1
    })

    -- Play animations in sequence with staggered timing
    slideIn:Play()
    shadowPop:Play()
    rippleExpand:Play()
    glowFadeIn:Play()
    
    -- Start ripple from center
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    
    task.wait(0.1)
    accentGrow:Play()
    frameFadeIn:Play()
    
    task.wait(0.15)
    fadeIn:Play()
    
    task.wait(0.05)
    fadeIn2:Play()
    
    task.wait(0.05)
    fadeIn3:Play()
    
    -- Start pulse animation after everything is shown
    task.delay(0.6, startPulse)
    
    -- Hover effect for the entire notification
    local hoverScale = 1.02
    frame.MouseEnter:Connect(function()
        playSound("NotificationHover")
        
        TweenService:Create(frame, TweenInfo.new(0.2), {
            Size = UDim2.new(0.35 * hoverScale, 0, 0, 70 * hoverScale)
        }):Play()
        TweenService:Create(shadow, TweenInfo.new(0.2), {
            Size = UDim2.new(1, 30 * hoverScale, 1, 30 * hoverScale),
            Position = UDim2.new(0, -15 * hoverScale, 0, -15 * hoverScale)
        }):Play()
    end)
    
    frame.MouseLeave:Connect(function()
        TweenService:Create(frame, TweenInfo.new(0.2), {
            Size = UDim2.new(0.35, 0, 0, 70)
        }):Play()
        TweenService:Create(shadow, TweenInfo.new(0.2), {
            Size = UDim2.new(1, 30, 1, 30),
            Position = UDim2.new(0, -15, 0, -15)
        }):Play()
    end)

    -- Close functionality with animations
    local closing = false
    local function close()
        if closing then return end
        closing = true
        
        playSound("NotificationDisappear")
        
        -- Stop pulse animation
        if pulseConnection then
            pulseConnection:Disconnect()
        end
        
        -- Create a new ripple for close effect
        local closeRipple = ripple:Clone()
        closeRipple.BackgroundTransparency = 0.95
        closeRipple.Size = UDim2.new(0, 0, 0, 0)
        closeRipple.Position = UDim2.new(
            UserInputService:GetMouseLocation().X / frame.AbsoluteSize.X,
            0,
            (UserInputService:GetMouseLocation().Y - frame.AbsolutePosition.Y) / frame.AbsoluteSize.Y,
            0
        )
        closeRipple.AnchorPoint = Vector2.new(0.5, 0.5)
        closeRipple.Parent = frame
        
        local rippleOut = TweenService:Create(closeRipple, TweenInfo.new(0.6, Enum.EasingStyle.Quad), {
            Size = UDim2.new(2, 0, 2, 0),
            BackgroundTransparency = 1
        })
        rippleOut:Play()
        rippleOut.Completed:Connect(function()
            closeRipple:Destroy()
        end)
        
        -- Shake effect when closing
        local shakeOffset = 5
        for i = 1, 3 do
            TweenService:Create(frame, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                Position = UDim2.new(1, -10 + shakeOffset, 0.85, 0)
            }):Play()
            task.wait(0.05)
            TweenService:Create(frame, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                Position = UDim2.new(1, -10 - shakeOffset, 0.85, 0)
            }):Play()
            task.wait(0.05)
            shakeOffset = shakeOffset * 0.6  -- Reduce shake amount each time
        end
        
        -- Fade out content first
        local fadeOut = TweenService:Create(titleLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        local fadeOut2 = TweenService:Create(messageLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        local fadeOut3 = TweenService:Create(closeButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        
        fadeOut:Play()
        fadeOut2:Play()
        fadeOut3:Play()
        
        -- Then slide out the frame
        task.wait(0.15)
        local slideOut = TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Position = UDim2.new(1, 10, 0.85, 0),
            BackgroundTransparency = 0.8
        })
        
        -- Shrink accent line
        local accentShrink = TweenService:Create(accent, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 0, 0, 2)
        })
        
        -- Shadow fade out and shrink
        local shadowFadeOut = TweenService:Create(shadow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            ImageTransparency = 0.9,
            Size = UDim2.new(1, 20, 1, 20),
            Position = UDim2.new(0, -10, 0, -10)
        })
        
        -- Glow fade out
        local glowFadeOut = TweenService:Create(glow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            ImageTransparency = 1
        })
        
        slideOut:Play()
        accentShrink:Play()
        shadowFadeOut:Play()
        glowFadeOut:Play()
        
        slideOut.Completed:Wait()
        frame:Destroy()
    end

    closeButton.MouseButton1Click:Connect(function()
        playSound("NotificationClick")
        close()
    end)
    
    -- Enhanced close button hover effects
    closeButton.MouseEnter:Connect(function()
        playSound("NotificationHover")
        
        TweenService:Create(closeButton, TweenInfo.new(0.1), {
            TextColor3 = Color3.new(1, 1, 1),
            Rotation = 90,
            TextSize = 22
        }):Play()
    end)
    
    closeButton.MouseLeave:Connect(function()
        TweenService:Create(closeButton, TweenInfo.new(0.1), {
            TextColor3 = Color3.fromRGB(180, 180, 180),
            Rotation = 0,
            TextSize = 20
        }):Play()
    end)

    -- Auto-close after duration
    task.delay(duration, function()
        close()
    end)
end

-- Example usage with different animations
showNotification("System Alert", "115 Cmds Are Loaded", 3, Color3.fromRGB(0, 200, 100))
task.wait(4)
showNotification("Welcome To TCMD >:33", "type in [cmds] btw :3", 3, Color3.fromRGB(0, 170, 255))
task.wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
-- PrintLoaderModule.lua
-- A loading GUI that uses the console as the loading GUI for other scripts
print("✅ - Working: It's Good and working) ☑️ - loads external: Loads scripts inside scripts) 🔄 - Debug: checks if working and debugs it ) ❌ - failed: doesn't work or something went wrong) ⚠️ - warn: warns the player")
print("\n")

pcall(function()
local DEBUG = true
local DEBUG_CHANCE = 0.099

local SoundId = "rbxassetid://5515669992" -- Replace with your preferred sound ID
local volume = 2 -- Adjust the volume (0 to 10)
local notifications = {} -- Stores active notifications

local function debugPrint(message)
    if DEBUG and math.random() < DEBUG_CHANCE then
        print(message)
    end
end

print(" ၊၊||၊|။||||။‌‌‌‌‌၊|• TerminalCmd •၊၊||၊|။||||။‌‌‌‌‌၊|")
task.wait()

local UIS = game:GetService("UserInputService")

debugPrint("🔄 [Debug] Initializing openConsole function")
local function openConsole()
    debugPrint("🔄 [Debug] Opening DevConsole")
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", true)
end

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.P then
        openConsole()
    end
end)

 -- the loadstring is full of resources for it to run the script
pcall(function()
    debugPrint("🔄 [Debug] Running pcall block")
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PrintLoadRes/refs/heads/main/PrintLoadRes", true))()
    playSound("rbxassetid://")
    task.wait()
    playSound("rbxassetid://")
    task.wait()
    playSound("rbxassetid://")
    task.wait(0.50)
end)

print("-------------------------------------------------")
print("\n")

local userInputService = game:GetService("UserInputService")

if userInputService.TouchEnabled then
    print("📱 [Scanning] PlayerUserMobile")
else
    print("🖥️ [Scanning] PlayerUserPersonalComputer")
end
task.wait()
print("madebyhmmm5650")
task.wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
task.wait()

debugPrint("🔄 [Debug] Initializing closeConsole function")
local function closeConsole()
    debugPrint("🔄 [Debug] Closing DevConsole")
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", false)
end

closeConsole()

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.O then
        closeConsole()
    end
end)

local success, err = pcall(function()
    pcall(function()
    print("Script started")


    -- Player
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    -- Function to destroy the UI
    local function destroyUI()
        local existingUI = playerGui:FindFirstChild("TerminalUI")
        if existingUI then
            existingUI:Destroy()
        end
    end

    -- Function to create the UI
    local function createUI()
        -- Clear existing UI if it exists
        destroyUI()

        -- Create ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TerminalUI"
        screenGui.Parent = playerGui
        print("ScreenGui created and parented")

        -- Create a Sound instance
        local typingSound = Instance.new("Sound")
        typingSound.SoundId = "rbxassetid://177266782" -- Replace with your sound ID
        typingSound.Volume = 0.1 -- Adjust volume as needed
        typingSound.Parent = screenGui

        -- Create Main Frame
        local mainFrame = Instance.new("Frame")
        mainFrame.Name = "MainFrame"
        mainFrame.Size = UDim2.new(0.4, 0, 0.4, 0) -- Smaller size
        mainFrame.Position = UDim2.new(0.3, 0, 0.3, 0) -- Centered
        mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        mainFrame.Transparency = 0.1
        mainFrame.BorderSizePixel = 0
        mainFrame.Active = true
        mainFrame.Parent = screenGui

        -- Add Squircle Corner to Main Frame
        local mainFrameCorner = Instance.new("UICorner")
        mainFrameCorner.CornerRadius = UDim.new(0.1, 0) -- Adjust for squircle effect
        mainFrameCorner.Parent = mainFrame

        -- Add Green Pulsing Outline to Main Frame
        local mainFrameStroke = Instance.new("UIStroke")
        mainFrameStroke.Color = Color3.fromRGB(27, 42, 53)
        mainFrameStroke.Thickness = 3
        mainFrameStroke.Transparency = 0.3
        mainFrameStroke.Parent = mainFrame

        -- Animate the Outline
        local pulseTween = TweenService:Create(
            mainFrameStroke,
            TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            { Transparency = 0.8 }
        )
        pulseTween:Play()

        print("MainFrame created and parented")

        -- Create Output Scrolling Frame
        local outputFrame = Instance.new("ScrollingFrame")
        outputFrame.Name = "OutputFrame"
        outputFrame.Size = UDim2.new(1, -10, 0.85, -10) -- Adjusted height to make room for the input box
        outputFrame.Position = UDim2.new(0, 5, 0, 5)
        outputFrame.BackgroundTransparency = 1
        outputFrame.ScrollBarThickness = 8
        outputFrame.Parent = mainFrame
        print("OutputFrame created and parented")

        -- Create Output TextLabel
        local outputText = Instance.new("TextLabel")
        outputText.Name = "OutputText"
        outputText.Size = UDim2.new(1, 0, 1, 0)
        outputText.Position = UDim2.new(0, 0, 0, 0)
        outputText.BackgroundTransparency = 1
        outputText.TextColor3 = Color3.fromRGB(204, 204, 204)
        outputText.TextXAlignment = Enum.TextXAlignment.Left
        outputText.TextYAlignment = Enum.TextYAlignment.Top
        outputText.TextWrapped = true
        outputText.Text = "Windows Terminal [Version 10.0.22000.194]\n(c) Microsoft Corporation. All rights reserved.\n\n"
        outputText.Font = Enum.Font.Code
        outputText.TextSize = 12
        outputText.Parent = outputFrame
        print("OutputText created and parented")

        -- Create Input Box Frame (For Blue Outline)
        local inputBoxFrame = Instance.new("Frame")
        inputBoxFrame.Name = "InputBoxFrame"
        inputBoxFrame.Size = UDim2.new(0.5, 0, 0.09, 0)
        inputBoxFrame.Position = UDim2.new(0.5, -inputBoxFrame.Size.X.Offset / 2, 1.1, -inputBoxFrame.Size.Y.Offset / 2)
        inputBoxFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        inputBoxFrame.Parent = mainFrame

        -- Add Circular Corner to Input Box Frame
        local inputBoxFrameCorner = Instance.new("UICorner")
        inputBoxFrameCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
        inputBoxFrameCorner.Parent = inputBoxFrame

        -- Add Blue Pulsing Outline to Input Box Frame
        local inputBoxFrameStroke = Instance.new("UIStroke")
        inputBoxFrameStroke.Color = Color3.fromRGB(27, 42, 53)
        inputBoxFrameStroke.Thickness = 2
        inputBoxFrameStroke.Transparency = 0.3
        inputBoxFrameStroke.Parent = inputBoxFrame

        -- Animate the Blue Outline
        local inputBoxPulseTween = TweenService:Create(
            inputBoxFrameStroke,
            TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            { Transparency = 0.8 }
        )
        inputBoxPulseTween:Play()

        -- Create Input TextBox inside the Frame
        local inputBox = Instance.new("TextBox")
        inputBox.Name = "InputBox"
        inputBox.Size = UDim2.new(1, -5, 1, -5) -- Fit inside the frame with a margin
        inputBox.Position = UDim2.new(0, 2, 0, 2)
        inputBox.BackgroundTransparency = 1 -- Make it transparent so only frame is visible
        inputBox.TextColor3 = Color3.fromRGB(200, 200, 200)
        inputBox.PlaceholderText = "Type a command..."
        inputBox.Font = Enum.Font.Code
        inputBox.TextSize = 12
        inputBox.ClearTextOnFocus = false
        inputBox.Parent = inputBoxFrame

        -- Play sound when typing in the input box
        inputBox:GetPropertyChangedSignal("Text"):Connect(function()
            if inputBox:IsFocused() and inputBox.Text ~= "" then
                typingSound:Play()
            end
        end)

        -- Add Circular Corner to Input Box
        local inputBoxCorner = Instance.new("UICorner")
        inputBoxCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
        inputBoxCorner.Parent = inputBox

        print("InputBox created and parented")

-- Create Minimize Button
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Text = "_"
minimizeButton.Size = UDim2.new(0, 20, 0, 20)
minimizeButton.Position = UDim2.new(1, -25, 0, 5)
minimizeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
minimizeButton.BackgroundTransparency = 0.3
minimizeButton.TextColor3 = Color3.fromRGB(155, 155, 155)
minimizeButton.Parent = mainFrame

-- Make Minimize Button Circular
local minimizeButtonCorner = Instance.new("UICorner")
minimizeButtonCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
minimizeButtonCorner.Parent = minimizeButton

-- Create Collapsed Label
local collapsedLabel = Instance.new("TextLabel")
collapsedLabel.Name = "CollapsedLabel"
collapsedLabel.Text = "TCmd (v2.2)"
collapsedLabel.Size = UDim2.new(1, 0, 1, 0)
collapsedLabel.Position = UDim2.new(0, -20, -0.02, 0)
collapsedLabel.BackgroundTransparency = 1
collapsedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
collapsedLabel.TextXAlignment = Enum.TextXAlignment.Center
collapsedLabel.TextYAlignment = Enum.TextYAlignment.Center
collapsedLabel.Font = Enum.Font.Code
collapsedLabel.TextSize = 19
collapsedLabel.Visible = false
collapsedLabel.Parent = mainFrame

-- Button hover animations
minimizeButton.MouseEnter:Connect(function()
    local tween = game:GetService("TweenService"):Create(
        minimizeButton,
        TweenInfo.new(0.2),
        {BackgroundTransparency = 0, TextColor3 = Color3.fromRGB(255, 255, 255)}
    )
    tween:Play()
end)

minimizeButton.MouseLeave:Connect(function()
    local tween = game:GetService("TweenService"):Create(
        minimizeButton,
        TweenInfo.new(0.2),
        {BackgroundTransparency = 0.3, TextColor3 = Color3.fromRGB(155, 155, 155)}
    )
    tween:Play()
end)

-- Variable to track minimized state
local isMinimized = false

-- Function to handle minimize button click with animations
minimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    
    local tweenService = game:GetService("TweenService")
    
    if isMinimized then
        -- Animate to minimized state
        local frameTween = tweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.2, 0, 0.1, 0)}
        )
        frameTween:Play()
        
        -- Fade out elements
        outputFrame.Visible = false
        inputBox.Visible = false
        inputBoxFrame.Visible = false
        
        -- Fade in collapsed label
        collapsedLabel.Visible = true
        collapsedLabel.TextTransparency = 1
        local labelTween = tweenService:Create(
            collapsedLabel,
            TweenInfo.new(0.3),
            {TextTransparency = 0}
        )
        labelTween:Play()
        
        -- Rotate button arrow
        local buttonTween = tweenService:Create(
            minimizeButton,
            TweenInfo.new(0.3),
            {Rotation = 180}
        )
        buttonTween:Play()
    else
        -- Animate to expanded state
        local frameTween = tweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.4, 0, 0.4, 0)}
        )
        frameTween:Play()
        
        -- Fade out collapsed label
        local labelTween = tweenService:Create(
            collapsedLabel,
            TweenInfo.new(0.2),
            {TextTransparency = 1}
        )
        labelTween:Play()
        
        -- After label fades out, show other elements
        labelTween.Completed:Connect(function()
            collapsedLabel.Visible = false
            outputFrame.Visible = true
            inputBox.Visible = true
            inputBoxFrame.Visible = true
        end)
        
        -- Rotate button arrow back
        local buttonTween = tweenService:Create(
            minimizeButton,
            TweenInfo.new(0.3),
            {Rotation = 0}
        )
        buttonTween:Play()
    end
end)

print("MinimizeButton and CollapsedLabel created and parented by hm5650")

    -- Table to store original transparency values
    local originalTransparency = {}

    local player = game.Players.LocalPlayer  
    local character = player.Character or player.CharacterAdded:Wait()  

    function SitPlayer()  
         if character and character:FindFirstChild("Humanoid") then  
            character.Humanoid.Sit = true  
         end  
    end  

local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local speeds = 1 -- Default speed for both flying and TP walk
local nowe = false
local tpwalking = false

-- TP Walk Functionality
local function TpWalk()
    tpwalking = true

    while tpwalking and humanoid.Health > 0 do
        game:GetService("RunService").Heartbeat:Wait()

        if humanoid.MoveDirection.Magnitude > 0 then
            -- Calculate movement direction and apply speed
            local moveDirection = humanoid.MoveDirection.Unit
            local velocity = moveDirection * speeds * 50 -- Adjust speed multiplier here
            rootPart.CFrame = rootPart.CFrame + velocity * game:GetService("RunService").Heartbeat:Wait()
        end
    end
end

local function StartTpWalk()
    if not tpwalking then
        tpwalking = true
        spawn(TpWalk)
    end
end

local function StopTpWalk()
    tpwalking = false
end

local function SetTpWalkSpeed(newSpeed)
    speeds = newSpeed
    print("TP Walk speed set to:", speeds)
end

-- Fly Functionality
local function Fly()
    nowe = true

    -- Disable animations and humanoid states
    character.Animate.Disabled = true
    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
        track:AdjustSpeed(0)
    end

    humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
    humanoid:ChangeState(Enum.HumanoidStateType.Swimming)

    -- Create BodyGyro and BodyVelocity for flying
    local flyGyro = Instance.new("BodyGyro")
    flyGyro.P = 9e4
    flyGyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    flyGyro.cframe = rootPart.CFrame
    flyGyro.Parent = rootPart

    local flyVelocity = Instance.new("BodyVelocity")
    flyVelocity.velocity = Vector3.new(0, 0.1, 0)
    flyVelocity.maxForce = Vector3.new(9e9, 9e9, 9e9)
    flyVelocity.Parent = rootPart

    humanoid.PlatformStand = true

    -- Movement logic
    local controlCooldown = 0
    local lastLookVector = Vector3.new(0, 0, 0)

    while nowe and humanoid.Health > 0 do
        game:GetService("RunService").RenderStepped:Wait()

        -- Get camera look vector
        local camera = workspace.CurrentCamera
        local lookVector = camera.CFrame.LookVector
        lastLookVector = lookVector

        -- Get player input
        local moveDirection = Vector3.new(0, 0, 0)
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + lookVector
        end
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - lookVector
        end
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end

        -- Normalize move direction
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
        end

        -- Apply movement
        flyVelocity.velocity = moveDirection * speeds * 50

        -- Update BodyGyro to match camera rotation
        flyGyro.cframe = CFrame.new(rootPart.Position, rootPart.Position + lookVector)
    end

    -- Clean up
    flyGyro:Destroy()
    flyVelocity:Destroy()
    humanoid.PlatformStand = false
end

local function UnFly()
    nowe = false
    tpwalking = false

    -- Re-enable humanoid states
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)
    humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)

    -- Re-enable animations
    character.Animate.Disabled = false
    humanoid.PlatformStand = false
end

-- GravityInverter
local player = game.Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Physics Settings
local GRAVITY_MULTIPLIER = 1.5 -- Visible but not too fast
local INITIAL_BOOST = 10 -- Gentle push to start
local MAX_SPEED = 20 -- Maximum upward speed
local SIMULATION_RADIUS = 5000 -- Large area of effect

-- System Variables
local invertedParts = {}
local connection = nil
local heartbeatConnection = nil

local function cleanUpForces(part)
    for _, child in ipairs(part:GetChildren()) do
        if child:IsA("BodyForce") or child:IsA("BodyVelocity") then
            child:Destroy()
        end
    end
end

local function applyUpwardForce()
    -- Ensure we can affect distant parts
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    sethiddenproperty(player, "MaxSimulationRadius", SIMULATION_RADIUS)
    
    for part, data in pairs(invertedParts) do
        if part and part.Parent then
            -- Calculate upward force based on part's mass
            local force = part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER
            
            -- Apply force while respecting max speed
            if part.Velocity.Y < MAX_SPEED then
                part:ApplyImpulse(Vector3.new(0, force * 0.016, 0)) -- 0.016 ≈ 1/60 for frame independence
            end
            
            -- Ensure parts don't get stuck
            if part.Velocity.Y < 5 then
                part.Velocity = Vector3.new(0, 5, 0)
            end
        else
            invertedParts[part] = nil
        end
    end
end

local function invertGravity(part)
    if part:IsA("BasePart") and not part.Anchored and not part:IsDescendantOf(player.Character) then
        if not invertedParts[part] then
            -- Store original state
            invertedParts[part] = {
                CanCollide = part.CanCollide,
                CustomPhysicalProperties = part.CustomPhysicalProperties
            }
            
            -- Clean existing forces
            cleanUpForces(part)
            
            -- Configure part physics
            part.CanCollide = false
            part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            
            -- Initial gentle push
            part.Velocity = Vector3.new(0, INITIAL_BOOST, 0)
            
            -- Add permanent upward force
            local bodyForce = Instance.new("BodyForce")
            bodyForce.Force = Vector3.new(0, part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER, 0)
            bodyForce.Parent = part
            invertedParts[part].bodyForce = bodyForce
        end
    end
end

local function restoreGravity(part)
    if invertedParts[part] then
        cleanUpForces(part)
        part.CanCollide = invertedParts[part].CanCollide
        part.CustomPhysicalProperties = invertedParts[part].CustomPhysicalProperties
        part.Velocity = Vector3.new(0, 0, 0)
        invertedParts[part] = nil
    end
end

function GravOn()
    -- Set physics range
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    
    -- Process existing parts
    for _, part in ipairs(Workspace:GetDescendants()) do
        invertGravity(part)
    end
    
    -- Continuous force application
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    heartbeatConnection = RunService.Heartbeat:Connect(applyUpwardForce)
    
    -- Detect new parts
    if connection then connection:Disconnect() end
    connection = Workspace.DescendantAdded:Connect(invertGravity)
end

function GravOff()
    -- Clean up
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    for part in pairs(invertedParts) do
        if part.Parent then
            restoreGravity(part)
        end
    end
    
    invertedParts = {}
    if connection then
        connection:Disconnect()
        connection = nil
    end
end

-- VoidProtection
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local monitoring = false
local connection
local highestY = hrp.Position.Y
local lastPropulsionHeight = 0
local consecutiveBounces = 0

-- Function to check if player is on a platform
local function isOnPlatform()
    if not humanoid then return false end
    return humanoid.FloorMaterial ~= Enum.Material.Air
end

function VoidProtectionOn()
    if monitoring then return end
    monitoring = true

    connection = RunService.Heartbeat:Connect(function()
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end

        local currentY = hrp.Position.Y

        -- Reset system if player is on a platform
        if isOnPlatform() then
            highestY = currentY
            consecutiveBounces = 0
            return
        end

        -- Update the highest point if we're ascending
        if hrp.Velocity.Y > 0 then
            highestY = currentY
        end

        -- Check if we've fallen below the void level
        if currentY <-105 then
            local fallDistance = highestY - currentY
            
            -- Increase bounce strength based on consecutive bounces
            consecutiveBounces = consecutiveBounces + 1
            local bounceMultiplier = 2 + (consecutiveBounces * 0.5) -- Each bounce increases power by 50%
            local bounceVelocity = math.clamp(fallDistance * bounceMultiplier, 100, 500)

            hrp.Velocity = Vector3.new(0, bounceVelocity, 0)

            -- Store the height we were propelled from
            lastPropulsionHeight = currentY
        end
    end)
end

function VoidProtectionOff()
    if connection then
        connection:Disconnect()
    end
    monitoring = false
end

-- // Antifling \\ --
local antiflingEnabled = false
local connections = {}

local function AFON()
    if antiflingEnabled then return end
    antiflingEnabled = true
    
    -- [ Services ] --
    local Services = setmetatable({}, {__index = function(Self, Index)
        local NewService = game.GetService(game, Index)
        if NewService then
            Self[Index] = NewService
        end
        return NewService
    end})

    -- [ LocalPlayer ] --
    local LocalPlayer = Services.Players.LocalPlayer

    -- // Functions \\ --
    local function PlayerAdded(Player)
        local Detected = false
        local Character;
        local PrimaryPart;

        local function CharacterAdded(NewCharacter)
            Character = NewCharacter
            repeat
                wait()
                PrimaryPart = NewCharacter:FindFirstChild("HumanoidRootPart")
            until PrimaryPart
            Detected = false
        end

        CharacterAdded(Player.Character or Player.CharacterAdded:Wait())
        local conn = Player.CharacterAdded:Connect(CharacterAdded)
        table.insert(connections, conn)
        
        local heartbeatConn = Services.RunService.Heartbeat:Connect(function()
            if (Character and Character:IsDescendantOf(workspace)) and (PrimaryPart and PrimaryPart:IsDescendantOf(Character)) then
                if PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 or PrimaryPart.AssemblyLinearVelocity.Magnitude > 100 then
                    if Detected == false then
                        game.StarterGui:SetCore("ChatMakeSystemMessage", {
                            Text = "Fling Exploit detected, Player: " .. tostring(Player);
                            Color = Color3.fromRGB(255, 200, 0);
                        })
                    end
                    Detected = true
                    for i,v in ipairs(Character:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.CanCollide = false
                            v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                            v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                            v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                        end
                    end
                    PrimaryPart.CanCollide = false
                    PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    PrimaryPart.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                end
            end
        end)
        table.insert(connections, heartbeatConn)
    end

    -- // Event Listeners \\ --
    for i,v in ipairs(Services.Players:GetPlayers()) do
        if v ~= LocalPlayer then
            PlayerAdded(v)
        end
    end
    local playerAddedConn = Services.Players.PlayerAdded:Connect(PlayerAdded)
    table.insert(connections, playerAddedConn)

    local LastPosition = nil
    local localHeartbeatConn = Services.RunService.Heartbeat:Connect(function()
        pcall(function()
            local PrimaryPart = LocalPlayer.Character.PrimaryPart
            if PrimaryPart.AssemblyLinearVelocity.Magnitude > 250 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 250 then
                PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                PrimaryPart.CFrame = LastPosition

                game.StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "You were flung. Neutralizing velocity.";
                    Color = Color3.fromRGB(255, 0, 0);
                })
            elseif PrimaryPart.AssemblyLinearVelocity.Magnitude < 50 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 then
                LastPosition = PrimaryPart.CFrame
            end
        end)
    end)
    table.insert(connections, localHeartbeatConn)
end

local function AFOFF()
    if not antiflingEnabled then return end
    antiflingEnabled = false
    
    -- Disconnect all connections
    for _, connection in ipairs(connections) do
        connection:Disconnect()
    end
    connections = {}
    
    game.StarterGui:SetCore("ChatMakeSystemMessage", {
        Text = "Antifling disabled";
        Color = Color3.fromRGB(0, 255, 0);
    })
end

-- Kill Variable
local TargetPlayer = nil
local LoopBringActive = false
local originalTransparency = {}
local bringConnection = nil

-- Add this function to your existing code
function StartKillEffect(targetName)
    -- Clean up any existing effect
    if bringConnection then
        bringConnection:Disconnect()
        bringConnection = nil
    end
    
    -- Find target player
    TargetPlayer = nil
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer and player.Name:lower():find(targetName:lower()) then
            TargetPlayer = player
            break
        end
    end
    
    if not TargetPlayer then
        return false, "Player not found!"
    end
    
    local character = TargetPlayer.Character
    local localCharacter = game:GetService("Players").LocalPlayer.Character
    if not character or not character.PrimaryPart or not localCharacter or not localCharacter.PrimaryPart then
        return false, "Invalid character(s)!"
    end
    
    local originalPosition = character.PrimaryPart.Position
    LoopBringActive = true
    
    -- Store original transparency
    originalTransparency = {}
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            originalTransparency[part] = part.Transparency
            part.Transparency = 1
        elseif part:IsA("ParticleEmitter") or part:IsA("Trail") then
            part.Enabled = false
        end
    end
    
    local spinSpeed = 1e9
    local angle = 0
    local startTime = tick()
    
    bringConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        if not LoopBringActive or tick() - startTime > 2 then -- 2 second duration
            LoopBringActive = false
            if bringConnection then
                bringConnection:Disconnect()
                bringConnection = nil
            end
            
            -- Clean up
            if character then
                for part, transparency in pairs(originalTransparency) do
                    if part and part.Parent then
                        part.Transparency = transparency
                    end
                end
                
                for _, part in pairs(character:GetDescendants()) do
                    if (part:IsA("ParticleEmitter") or part:IsA("Trail")) and part.Parent then
                        part.Enabled = true
                    end
                end
                
                local forceField = character:FindFirstChild("ForceField")
                if forceField then forceField:Destroy() end
                
                if character.PrimaryPart then
                    character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
                end
            end
            return
        end
        
        if character and character.PrimaryPart and localCharacter and localCharacter.PrimaryPart then
            if not character:FindFirstChild("ForceField") then
                local forceField = Instance.new("ForceField")
                forceField.Visible = false
                forceField.Parent = character
            end
            
            angle = (angle + spinSpeed * deltaTime) % 360
            character:SetPrimaryPartCFrame(
                localCharacter.PrimaryPart.CFrame * 
                CFrame.new(1.7, 4.7, -1.3) * 
                CFrame.Angles(0, math.rad(angle), 0)
            )
        else
            LoopBringActive = false
        end
    end)
    
    return true, "Executing killing on "..TargetPlayer.Name
end

-- animation speed variable
local AnimationSpeedController = {
    CurrentSpeed = 1,
    Enabled = false,
    Running = false
}

-- Main control function for animation speeds
local function ControlAnimationSpeeds()
    AnimationSpeedController.Running = true
    
    while AnimationSpeedController.Running and task.wait(0.1) do
        local character = game.Players.LocalPlayer.Character
        if not character then continue end
        
        local animController = character:FindFirstChildOfClass("Humanoid") or character:FindFirstChildOfClass("AnimationController")
        if not animController then continue end
        
        -- Only adjust speeds if the controller is enabled
        if AnimationSpeedController.Enabled then
            for _, track in ipairs(animController:GetPlayingAnimationTracks()) do
                track:AdjustSpeed(AnimationSpeedController.CurrentSpeed)
            end
        end
    end
end

-- FakeLag variable
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- Debug prints
local function debugPrint(message)
    print("[DEBUG] " .. message)
end

-- Variables
local Character, Head, Humanoid
local FastAnimationsEnabled = false
local AnchoringEnabled = false
local AnchorLoopThread, FastAnimThread

-- Initialize character
local function InitializeCharacter()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    Head = Character:WaitForChild("Head")
    Humanoid = Character:WaitForChild("Humanoid")
    debugPrint("Character initialized!")
end

-- Fast animations (15x speed)
local function FastAnimationsLoop()
    while FastAnimationsEnabled and task.wait(0.1) do
        if not Character then continue end
        
        local animController = Character:FindFirstChildOfClass("Humanoid") or Character:FindFirstChildOfClass("AnimationController")
        if not animController then continue end
        
        for _, track in pairs(animController:GetPlayingAnimationTracks()) do
            track:AdjustSpeed(15)
        end
    end
end

-- Head Anchor/Unanchor loop with sit/stand
local function AnchorHeadLoop()
    while AnchoringEnabled and task.wait(0.1) do
        if not Head or not Humanoid then continue end
        
        -- Toggle anchor and sit state
        Head.Anchored = not Head.Anchored
        if Head.Anchored then
            Humanoid.Sit = false -- Stand when anchored
        else
            Humanoid.Sit = true -- Sit when unanchored
        end
        
        debugPrint("Head Anchored: " .. tostring(Head.Anchored) .. " | Sitting: " .. tostring(Humanoid.Sit))
    end
end

-- Start effects
function Fun()
    if not Character then InitializeCharacter() end
    
    FastAnimationsEnabled = true
    AnchoringEnabled = true
    
    FastAnimThread = task.spawn(FastAnimationsLoop)
    AnchorLoopThread = task.spawn(AnchorHeadLoop)
    
    debugPrint("Started Fun() - Fast Animations + Head Anchor/Sit Loop")
end

-- Stop effects and reset
function NoFun()
    FastAnimationsEnabled = false
    AnchoringEnabled = false
    
    -- Reset animations
    if Character then
        local animController = Character:FindFirstChildOfClass("Humanoid") or Character:FindFirstChildOfClass("AnimationController")
        if animController then
            for _, track in pairs(animController:GetPlayingAnimationTracks()) do
                track:AdjustSpeed(1)
            end
        end
    end
    
    -- Reset Head and sitting
    if Head then Head.Anchored = false end
    if Humanoid then Humanoid.Sit = false end
    
    -- Cancel threads
    if FastAnimThread then task.cancel(FastAnimThread) end
    if AnchorLoopThread then task.cancel(AnchorLoopThread) end
    
    debugPrint("Stopped Fun() - Reset everything")
end

-- Handle respawns
LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    InitializeCharacter()
    
    if FastAnimationsEnabled then
        FastAnimThread = task.spawn(FastAnimationsLoop)
    end
    if AnchoringEnabled then
        AnchorLoopThread = task.spawn(AnchorHeadLoop)
    end
end)

-- Initialize if already in-game
if LocalPlayer.Character then
    InitializeCharacter()
end

-- Drop All Tools Function (DAT)
local function DAT()
    -- Get the player's character and backpack
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player:FindFirstChild("Backpack")
    
    if not backpack then
        warn("Backpack not found!")
        return
    end
    
    -- Get all tools in the backpack
    local tools = {}
    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") then
            table.insert(tools, item)
        end
    end
    
    -- Drop each tool
    for _, tool in ipairs(tools) do
        -- Equip the tool first (necessary to drop it)
        tool.Parent = character
        task.wait(0.1) -- Small delay to ensure tool is equipped
        
        -- Drop the tool
        tool.Parent = workspace
        tool:FindFirstChild("Handle").Anchored = false -- Ensure it can fall
    end
    
    print("Dropped " .. #tools .. " tools")
end

-- AAT (Activate All Tools) Script
local function AAT()
    -- Get the local player
    local player = game:GetService("Players").LocalPlayer
    if not player then return end
    
    -- Get the player's backpack and character
    local backpack = player:FindFirstChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Wait for tools to load if needed
    if not backpack then
        backpack = player:WaitForChild("Backpack")
    end
    
    -- Function to activate a tool
    local function activateTool(tool)
        if tool:IsA("Tool") then
            -- Equip the tool if it's in the backpack
            if tool.Parent == backpack then
                tool.Parent = character
                wait(0.1) -- Small delay for equip animation
            end
            
            -- Activate the tool
            local handle = tool:FindFirstChild("Handle")
            if handle then
                local remote = handle:FindFirstChildOfClass("RemoteEvent") or 
                              tool:FindFirstChildOfClass("RemoteEvent") or
                              handle:FindFirstChildOfClass("RemoteFunction") or
                              tool:FindFirstChildOfClass("RemoteFunction")
                
                if remote then
                    -- Try to activate with the remote
                    pcall(function()
                        if remote:IsA("RemoteEvent") then
                            remote:FireServer("activate")
                        elseif remote:IsA("RemoteFunction") then
                            remote:InvokeServer("activate")
                        end
                    end)
                else
                    -- Try to use the tool's built-in activation
                    pcall(function()
                        tool:Activate()
                    end)
                end
            end
        end
    end
    
    -- Activate all tools in the backpack
    for _, tool in ipairs(backpack:GetChildren()) do
        activateTool(tool)
    end
    
    -- Activate all tools currently equipped
    for _, tool in ipairs(character:GetChildren()) do
        activateTool(tool)
    end
    
    print("AAT: Attempted to activate all tools.")
end

-- Create the AAT function in the global namespace
getgenv().AAT = AAT

-- Combined ESP Script
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- NameESP Configuration
local NameESPConfig = {
    Enabled = false,
    TeamCheck = true,
    MaxDistance = 1000,
    Color = Color3.new(1, 1, 1),
    TeamColor = Color3.new(0, 1, 0),
    EnemyColor = Color3.new(1, 0, 0)
}

-- BoxESP Configuration
local BoxESPConfig = {
    Enabled = false,
    TeamCheck = true
}

-- Variables
local namePlayerAddedConnection
local nameRenderSteppedConnection
local nameCharacterConnections = {} -- Track character connections for cleanup
local boxEspBoxes = {}

-- NameESP Functions
local function CreateEspLabel(character)
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not humanoidRootPart then return end
    
    -- Remove existing label if it exists
    local existingLabel = humanoidRootPart:FindFirstChild("EspLabel")
    if existingLabel then
        existingLabel:Destroy()
    end
    
    local espLabel = Instance.new("BillboardGui")
    espLabel.Name = "EspLabel"
    espLabel.Parent = humanoidRootPart
    espLabel.Adornee = humanoidRootPart
    espLabel.AlwaysOnTop = true
    espLabel.LightInfluence = 0
    espLabel.Size = UDim2.new(0, 200, 0, 20)
    espLabel.StudsOffset = Vector3.new(0, 2, 0)
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "TextLabel"
    textLabel.Parent = espLabel
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = character.Name
    textLabel.Font = Enum.Font.SourceSansSemibold
    textLabel.TextSize = 18
    textLabel.TextColor3 = NameESPConfig.Color
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    
    return espLabel
end

local function UpdateEspLabel(character)
    local espLabel = character:FindFirstChild("EspLabel")
    if espLabel then
        local textLabel = espLabel:FindFirstChild("TextLabel")
        if textLabel then
            local player = Players:GetPlayerFromCharacter(character)
            if player then
                local localPlayer = Players.LocalPlayer
                local localCharacter = localPlayer.Character
                
                -- Distance check
                if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("HumanoidRootPart") then
                    local distance = (character.HumanoidRootPart.Position - localCharacter.HumanoidRootPart.Position).Magnitude
                    if distance > NameESPConfig.MaxDistance then
                        espLabel.Enabled = false
                        return
                    else
                        espLabel.Enabled = true
                    end
                end
                
                textLabel.Text = player.Name
                if NameESPConfig.TeamCheck then
                    if player.Team == localPlayer.Team then
                        textLabel.TextColor3 = NameESPConfig.TeamColor
                    else
                        textLabel.TextColor3 = NameESPConfig.EnemyColor
                    end
                else
                    textLabel.TextColor3 = NameESPConfig.Color
                end
            end
        end
    end
end

-- BoxESP Functions
local function createBox(player)
    local box = Instance.new("BoxHandleAdornment")
    box.Name = player.Name .. "_ESP"
    box.Adornee = nil -- Will be set when character exists
    box.AlwaysOnTop = true
    box.ZIndex = 10
    box.Size = Vector3.new(4, 6, 1)
    box.Transparency = 0.8
    box.Color3 = Color3.new(1, 1, 1)
    
    local outline = Instance.new("SelectionBox")
    outline.Name = player.Name .. "_Outline"
    outline.Adornee = nil
    outline.LineThickness = 0.05
    outline.Color3 = Color3.new(1, 1, 1)
    outline.Transparency = 0.3
    
    return box, outline
end

local function updateBoxColor(player, box, outline)
    if not player or not box or not outline then return end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return end
    
    if player.Team and localPlayer.Team then
        if player.Team ~= localPlayer.Team then
            box.Color3 = Color3.new(1, 0, 0)
            outline.Color3 = Color3.new(1, 0.3, 0.3)
        else
            box.Adornee = nil
            outline.Adornee = nil
            return
        end
    else
        box.Color3 = Color3.new(1, 1, 1)
        outline.Color3 = Color3.new(1, 1, 1)
    end
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        box.Adornee = player.Character.HumanoidRootPart
        outline.Adornee = player.Character.HumanoidRootPart
    end
end

-- Main Functions
function NameEspOn()
    if NameESPConfig.Enabled then return end
    NameESPConfig.Enabled = true
    
    -- Clear existing character connections
    for _, connection in pairs(nameCharacterConnections) do
        connection:Disconnect()
    end
    nameCharacterConnections = {}
    
    -- Create ESP for existing players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            if player.Character then
                CreateEspLabel(player.Character)
            end
            nameCharacterConnections[player] = player.CharacterAdded:Connect(function(character)
                CreateEspLabel(character)
            end)
        end
    end
    
    -- Connect to new players
    namePlayerAddedConnection = Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            nameCharacterConnections[player] = player.CharacterAdded:Connect(function(character)
                CreateEspLabel(character)
            end)
        end
    end)
    
    -- Update loop
    nameRenderSteppedConnection = RunService.RenderStepped:Connect(function()
        if NameESPConfig.Enabled then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character then
                    UpdateEspLabel(player.Character)
                end
            end
        end
    end)
end

function NameEspOff()
    if not NameESPConfig.Enabled then return end
    NameESPConfig.Enabled = false
    
    -- Disconnect all connections
    if namePlayerAddedConnection then
        namePlayerAddedConnection:Disconnect()
        namePlayerAddedConnection = nil
    end
    
    if nameRenderSteppedConnection then
        nameRenderSteppedConnection:Disconnect()
        nameRenderSteppedConnection = nil
    end
    
    for player, connection in pairs(nameCharacterConnections) do
        connection:Disconnect()
    end
    nameCharacterConnections = {}
    
    -- Remove all ESP labels
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            local espLabel = player.Character:FindFirstChild("EspLabel")
            if espLabel then
                espLabel:Destroy()
            end
        end
        
        -- Also check for any labels in workspace (in case they weren't parented to character)
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant.Name == "EspLabel" and descendant:IsA("BillboardGui") then
                descendant:Destroy()
            end
        end
    end
end

function BoxEspOn()
    if BoxESPConfig.Enabled then return end
    BoxESPConfig.Enabled = true
    
    -- Clear existing boxes
    for player, data in pairs(boxEspBoxes) do
        data.box:Destroy()
        data.outline:Destroy()
    end
    boxEspBoxes = {}
    
    -- Create boxes for all current players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            local box, outline = createBox(player)
            box.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or workspace
            outline.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or workspace
            boxEspBoxes[player] = {box = box, outline = outline}
            
            if player.Character then
                updateBoxColor(player, box, outline)
            end
            
            player.CharacterAdded:Connect(function(character)
                if BoxESPConfig.Enabled then
                    local rootPart = character:WaitForChild("HumanoidRootPart")
                    if rootPart then
                        box.Adornee = rootPart
                        box.Parent = rootPart
                        outline.Adornee = rootPart
                        outline.Parent = rootPart
                        updateBoxColor(player, box, outline)
                    end
                end
            end)
            
            player:GetPropertyChangedSignal("Team"):Connect(function()
                if BoxESPConfig.Enabled then
                    updateBoxColor(player, box, outline)
                end
            end)
        end
    end
    
    -- Connect to new players
    Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            local box, outline = createBox(player)
            box.Parent = workspace
            outline.Parent = workspace
            boxEspBoxes[player] = {box = box, outline = outline}
            
            player.CharacterAdded:Connect(function(character)
                if BoxESPConfig.Enabled then
                    local rootPart = character:WaitForChild("HumanoidRootPart")
                    if rootPart then
                        box.Adornee = rootPart
                        box.Parent = rootPart
                        outline.Adornee = rootPart
                        outline.Parent = rootPart
                        updateBoxColor(player, box, outline)
                    end
                end
            end)
        end
    end)
end

function BoxEspOff()
    if not BoxESPConfig.Enabled then return end
    BoxESPConfig.Enabled = false
    
    for player, data in pairs(boxEspBoxes) do
        data.box:Destroy()
        data.outline:Destroy()
    end
    boxEspBoxes = {}
end

function EspOff()
    NameEspOff()
    BoxEspOff()
end

-- Handle player respawn
Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if NameESPConfig.Enabled then
        CreateEspLabel(character)
    end
end)

-- Table to store ESP objects
local espObjects = {}
local espConnections = {}

-- Function to create ESP for a player
local function createEsp(player)
    -- Ensure the player has a character and head
    if not player.Character or not player.Character:FindFirstChild("Head") then return end

    -- Create BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "ESP"
    billboardGui.Adornee = player.Character.Head
    billboardGui.Size = UDim2.new(1, 0, 1, 0)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.AlwaysOnTop = true

    -- Create TextLabel
    local textLabel = Instance.new("TextLabel", billboardGui)
    textLabel.Text = player.Name
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = player.Team == game.Players.LocalPlayer.Team and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)  -- Green for teammates, red for non-teammates

    -- Store ESP object
    espObjects[player] = {
        billboardGui = billboardGui,
        textLabel = textLabel
    }

    -- Parent BillboardGui to player's head
    billboardGui.Parent = player.Character.Head
end

-- Function to remove ESP from a player
local function removeEsp(player)
    if espObjects[player] then
        espObjects[player].billboardGui:Destroy()
        espObjects[player] = nil
    end
end

-- Function to update ESP size based on distance
local function updateEspSize()
    for player, esp in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local distance = (game.Players.LocalPlayer.Character.Head.Position - player.Character.Head.Position).magnitude
            esp.billboardGui.Size = UDim2.new(distance / 50, 0, distance / 50, 0)  -- Adjust size based on distance
        end
    end
end

-- Function to handle player respawn
local function onCharacterAdded(player)
    -- Wait for the head to be created
    player.Character:WaitForChild("Head")
    createEsp(player)
end

-- Function to enable ESP
function EspOn()
    -- Create ESP for all players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            createEsp(player)
            -- Connect CharacterAdded event to handle respawns
            espConnections[player] = player.CharacterAdded:Connect(function()
                onCharacterAdded(player)
            end)
        end
    end

    -- Connect PlayerAdded event to handle rejoins
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            createEsp(player)
            -- Connect CharacterAdded event to handle respawns
            espConnections[player] = player.CharacterAdded:Connect(function()
                onCharacterAdded(player)
            end)
        end
    end)

    -- Connect PlayerRemoving event
    game.Players.PlayerRemoving:Connect(function(player)
        removeEsp(player)
        -- Disconnect the CharacterAdded event
        if espConnections[player] then
            espConnections[player]:Disconnect()
            espConnections[player] = nil
        end
    end)

    -- Connect RenderStepped event to update ESP size
    game:GetService("RunService").RenderStepped:Connect(updateEspSize)
end

-- Function to disable ESP
function EspOff()
    -- Remove ESP from all players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            removeEsp(player)
            -- Disconnect the CharacterAdded event
            if espConnections[player] then
                espConnections[player]:Disconnect()
                espConnections[player] = nil
            end
        end
    end

    -- Disconnect all RenderStepped events (optional, but recommended for cleanup)
    for _, connection in ipairs(game:GetService("RunService").RenderStepped:GetConnections()) do
        connection:Disconnect()
    end
end

-- WinObby
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Settings
local TELEPORT_HEIGHT = 3
local TELEPORT_DELAY = 0.1
local RETRY_DELAY = 0.10
local MAX_ATTEMPTS = 100

-- Find all potential checkpoint containers
local potentialContainers = {
    "Checkpoints", "checkpoints", "Checkpoint", "checkpoint",
    "CP", "cp", "Flags", "flags", "Flag", "flag",
    "Markers", "markers", "Waypoints", "waypoints"
}

-- Function to find the first valid container
local function findCheckpointContainer()
    for _, name in ipairs(potentialContainers) do
        local container = game.Workspace:FindFirstChild(name)
        if container then
            print("Found checkpoint container:", container.Name)
            return container
        end
    end
    return nil
end

local checkpointContainer = findCheckpointContainer()

if not checkpointContainer then
    warn("No checkpoint container found! Searching entire Workspace...")
    checkpointContainer = game.Workspace
end

-- Collect all potential checkpoints
local checkpoints = {}
for _, child in ipairs(checkpointContainer:GetDescendants()) do
    if child:IsA("BasePart") then
        -- Check for common checkpoint name patterns (case-insensitive)
        local lowerName = child.Name:lower()
        if lowerName:find("checkpoint") or 
           lowerName:find("cp") or 
           lowerName:find("flag") or 
           lowerName:find("marker") or 
           lowerName:find("waypoint") or
           #checkpointContainer:GetChildren() < 10 then -- If container has few children, assume all are checkpoints
            table.insert(checkpoints, child)
            print("Found potential checkpoint:", child:GetFullName())
        end
    end
end

if #checkpoints == 0 then
    -- Last resort: collect all parts in container
    warn("No specifically named checkpoints found. Collecting all parts in container...")
    for _, child in ipairs(checkpointContainer:GetChildren()) do
        if child:IsA("BasePart") then
            table.insert(checkpoints, child)
            print("Including part as checkpoint:", child:GetFullName())
        end
    end
end

if #checkpoints == 0 then
    error("No valid checkpoints found anywhere in workspace!")
    return
end

-- Smart sorting function
local function getSortValue(name)
    -- First try to extract number
    local num = tonumber(name:match("%d+"))
    if num then return num end
    
    -- Then try letter value (A=1, B=2, etc) 
    local letter = name:upper():match("^[A-Z]")
    if letter then return string.byte(letter) - 64 end
    
    -- Default for unnamed parts
    return 0
end

table.sort(checkpoints, function(a, b)
    local aVal = getSortValue(a.Name)
    local bVal = getSortValue(b.Name)
    
    if aVal == bVal then
        return a.Name:lower() < b.Name:lower()
    else
        return aVal < bVal
    end
end)

print("Sorted checkpoints order:")
for i, checkpoint in ipairs(checkpoints) do
    print(i, checkpoint:GetFullName())
end

-- Enhanced teleport function
local function teleportToCheckpoint(checkpoint)
    if not (character and character.Parent) then
        character = player.Character or player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
        rootPart = character:WaitForChild("HumanoidRootPart")
    end
    
    local success = pcall(function()
        rootPart.CFrame = checkpoint.CFrame + Vector3.new(0, TELEPORT_HEIGHT, 0)
    end)
    
    if not success then
        -- Try alternative teleport method
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = checkpoint.CFrame + Vector3.new(0, TELEPORT_HEIGHT, 0)
            return true
        end
        return false
    end
    return true
end

function TPCheckpoints()
    print("Starting teleportation sequence to", #checkpoints, "checkpoints...")
    
    for i, checkpoint in ipairs(checkpoints) do
        local attempts = 0
        local teleported = false
        
        while attempts < MAX_ATTEMPTS and not teleported do
            attempts += 1
            teleported = teleportToCheckpoint(checkpoint)
            
            if not teleported then
                warn("Attempt", attempts, "failed for", checkpoint:GetFullName())
                task.wait(RETRY_DELAY)
            end
        end
        
        if teleported then
            print("Successfully teleported to", checkpoint:GetFullName())
            if i < #checkpoints then
                task.wait(TELEPORT_DELAY)
            end
        else
            warn("Failed to teleport to", checkpoint:GetFullName(), "after", MAX_ATTEMPTS, "attempts")
        end
    end
    
    print("Teleportation sequence complete!")
end

-- Black Hole Script Function
local function blackHoleScript()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Attachment1 = Instance.new("Attachment", Part)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1

    if not Network then
        Network = {
            BaseParts = {},
            Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
        }

        Network.RetainPart = function(Part)
            if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                table.insert(Network.BaseParts, Part)
                Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                Part.CanCollide = false
            end
        end

        local function EnablePartControl()
            LocalPlayer.ReplicationFocus = Workspace
            RunService.Heartbeat:Connect(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                for _, Part in pairs(Network.BaseParts) do
                    if Part:IsDescendantOf(Workspace) then
                        Part.Velocity = Network.Velocity
                    end
                end
            end)
        end

        EnablePartControl()
    end

    local function ForcePart(v)
        if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
            for _, x in next, v:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if v:FindFirstChild("Attachment") then
                v:FindFirstChild("Attachment"):Destroy()
            end
            if v:FindFirstChild("AlignPosition") then
                v:FindFirstChild("AlignPosition"):Destroy()
            end
            if v:FindFirstChild("Torque") then
                v:FindFirstChild("Torque"):Destroy()
            end
            v.CanCollide = false
            local Torque = Instance.new("Torque", v)
            Torque.Torque = Vector3.new(100000, 100000, 100000)
            local AlignPosition = Instance.new("AlignPosition", v)
            local Attachment2 = Instance.new("Attachment", v)
            Torque.Attachment0 = Attachment2
            AlignPosition.MaxForce = 9999999999999999
            AlignPosition.MaxVelocity = math.huge
            AlignPosition.Responsiveness = 200
            AlignPosition.Attachment0 = Attachment2
            AlignPosition.Attachment1 = Attachment1
        end
    end

    blackHoleActive = true

    for _, v in next, Workspace:GetDescendants() do
        ForcePart(v)
    end

    Workspace.DescendantAdded:Connect(function(v)
        if blackHoleActive then
            ForcePart(v)
        end
    end)

    spawn(function()
        while blackHoleActive and RunService.RenderStepped:Wait() do
            Attachment1.WorldCFrame = humanoidRootPart.CFrame
        end
    end)
end

-- Function to disable black hole
local function disableBlackHole()
    blackHoleActive = false
    if Folder then
        Folder:Destroy()
        Folder = nil
    end
    if Network then
        Network.BaseParts = {}
    end
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
        return GetPlayers[math.random(#GetPlayers)]
    elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
        for _,x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) then
                    return x;
                elseif x.DisplayName:lower():match("^"..Name) then
                    return x;
                end
            end
        end
    else
        return
    end
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle

    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessory and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    end
end

local StartFlingAll = function(Targets)
    if Targets[1] then 
        for _,x in next, Targets do 
            GetPlayer(x) 
        end 
    else 
        return 
    end

    if AllBool then
        for _,x in next, Players:GetPlayers() do
            SkidFling(x)
        end
    end

    for _,x in next, Targets do
        if GetPlayer(x) and GetPlayer(x) ~= Player then
            if GetPlayer(x).UserId ~= 1414978355 then
                local TPlayer = GetPlayer(x)
                if TPlayer then
                    SkidFling(TPlayer)
                end
            end
        end
    end
end

-- Fling Functionality without UI

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function Message(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local function SkidFling(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter and TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit then
            return Message("Error Occurred", "Target is sitting", 5)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        else
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local function FPos(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local function SFBasePart(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Occurred", "Random error", 5)
    end
end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local math = math

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("HumanoidRootPart") -- R15 part

local particleEmitter = Instance.new("ParticleEmitter")
particleEmitter.Texture = "rbxassetid://<your_cube_texture_id>"
particleEmitter.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
particleEmitter.Size = NumberSequence.new(0.3)
particleEmitter.Lifetime = NumberRange.new(1)
particleEmitter.Rate = 10
particleEmitter.Parent = torso

local function spawnCube()
    local cube = Instance.new("Part")
    cube.Shape = Enum.PartType.Block
    cube.Size = Vector3.new(0.3, 0.3, 0.3)
    cube.Color = Color3.fromRGB(255, 255, 0)
    cube.Anchored = true
    cube.CanCollide = false
    cube.Material = Enum.Material.Neon -- Neon material for glowing effect

    local light = Instance.new("PointLight")
    light.Color = Color3.fromRGB(255, 255, 0)
    light.Brightness = 0.5
    light.Range = 3
    light.Parent = cube

    cube.Parent = workspace

    -- Generate spinning oval coordinates
    local radiusX = 2.5 -- Horizontal radius
    local radiusY = 1.5 -- Vertical radius
    local theta = math.random() * 2 * math.pi -- Random angle
    local x = radiusX * math.cos(theta)
    local y = radiusY * math.sin(theta)
    local z = math.random(-1, 1) -- Random depth

    -- Apply rotation to create spinning effect
    local rotationAngle = tick() * 5 -- Adjust speed here (higher = faster)
    local rotatedX = x * math.cos(rotationAngle) - z * math.sin(rotationAngle)
    local rotatedZ = x * math.sin(rotationAngle) + z * math.cos(rotationAngle)

    cube.Position = torso.Position + Vector3.new(rotatedX, y, rotatedZ)

    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
    local tweenGoal = {Transparency = 1}
    local tween = TweenService:Create(cube, tweenInfo, tweenGoal)
    tween:Play()
    tween.Completed:Connect(function()
        cube:Destroy()
    end)
end

local emitterEnabled = false
local cubeSpawnConnection

function EmitterOn()
    if not emitterEnabled then
        emitterEnabled = true
        particleEmitter.Enabled = true
        cubeSpawnConnection = RunService.RenderStepped:Connect(function()
            spawnCube()
        end)
    end
end

function EmitterOff()
    if emitterEnabled then
        emitterEnabled = false
        particleEmitter.Enabled = false
        if cubeSpawnConnection then
            cubeSpawnConnection:Disconnect()
            cubeSpawnConnection = nil
        end
    end
end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local TFlingActive = false
local ModeActive = false
local TFlingCoroutine
local ModeConnection

-- TFling functionality
local function TFling()
    local character = LocalPlayer.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    while TFlingActive do
        RunService.Heartbeat:Wait()
        local velocity = rootPart.Velocity
        rootPart.Velocity = velocity * 999999999999999999999999999999999 + Vector3.new(0, 999999999999999999999999999999999, 0)
        RunService.RenderStepped:Wait()
        rootPart.Velocity = velocity
        RunService.Stepped:Wait()
        rootPart.Velocity = velocity + Vector3.new(0, 0.1, 0)
    end
end

-- Mode functionality
local function DisableCollisions()
    if not LocalPlayer.Character then return end
    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and not part.Anchored then
            part.CanCollide = false
        end
    end
end

local function EnableCollisions()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Control functions
function TFlingOn()
    TFlingActive = true
    TFlingCoroutine = coroutine.create(TFling)
    coroutine.resume(TFlingCoroutine)
end

function TFlingOff()
    TFlingActive = false
    if TFlingCoroutine then
        coroutine.close(TFlingCoroutine)
    end
end

function ModeOn()
    ModeActive = true
    ModeConnection = RunService.Heartbeat:Connect(DisableCollisions)
end

function ModeOff()
    ModeActive = false
    if ModeConnection then
        ModeConnection:Disconnect()
    end
    EnableCollisions()
end


    local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local RunService = game:GetService("RunService")

local tpSpeed = 1
local tpWalking = false
local tpConnection = nil

-- Improved TP Walk Function
local function TpWalk()
    if tpConnection then return end

    tpConnection = RunService.Heartbeat:Connect(function(delta)
        if not rootPart or not humanoid or humanoid.Health <= 0 then
            StopTpWalk()
            return
        end

        if humanoid.MoveDirection.Magnitude > 0 then
            local moveDirection = humanoid.MoveDirection.Unit
            local offset = moveDirection * tpSpeed * 50 * delta
            rootPart.CFrame = rootPart.CFrame + offset
        end
    end)
end

local function StartTpWalk()
    if not tpWalking then
        tpWalking = true
        TpWalk()
    end
end

local function StopTpWalk()
    if tpConnection then
        tpConnection:Disconnect()
        tpConnection = nil
    end
    tpWalking = false
    print("TP Walk stopped.")
end

local function SetTpWalkSpeed(newSpeed)
    tpSpeed = newSpeed
    print("TP Walk speed set to:", tpSpeed)
end

    local player = game.Players.LocalPlayer  
    local character = player.Character or player.CharacterAdded:Wait()  
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")  

    function LayDown()  
    if humanoidRootPart then  
            humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0)  
        end  
    end  

    -- Function to enable XRay
    local function enableXRay()
        for _, part in pairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and not part:IsA("Terrain") then
                originalTransparency[part] = part.Transparency
                part.Transparency = 0.8 -- Set transparency to make parts semi-transparent
            end
        end
    end

    -- Function to disable XRay
    local function disableXRay()
        for part, transparency in pairs(originalTransparency) do
            if part:IsA("BasePart") then
                part.Transparency = transparency -- Restore original transparency
            end
        end
        originalTransparency = {} -- Clear the table
    end


    -- Function to handle input
    local function handleInput(input)
        local command = input.Text
        input.Text = ""

        -- Add the command to the output
        outputText.Text = outputText.Text .. "\n</> " .. command

        -- Simulate command execution
        local result = "Command not recognized."
        if command == "🍪" then
            result = "🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪??🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪"
        elseif command == "clear" then
            outputText.Text = ""
            return
         elseif command:sub(1, 11) == "jumpower " or command:sub(1, 3) == "jp " then
            local speed = tonumber(command:match("%d+"))
            if speed then
                player.Character.Humanoid.JumpPower = speed
                result = "JumpPower set to " .. speed
            else
                result = "Invalid walkspeed value."
            end
        elseif command == "resetjumppower" or command == "resetjp" then
            player.Character.Humanoid.JumpPower = 50
            result = "JumpPower reset to 50"
        elseif command:sub(1, 10) == "walkspeed " or command:sub(1, 3) == "ws " then
            local speed = tonumber(command:match("%d+"))
            if speed then
                player.Character.Humanoid.WalkSpeed = speed
                result = "Walkspeed set to " .. speed
            else
                result = "Invalid walkspeed value."
            end
        elseif command == "resetwalkspeed" or command == "resetws" then
            player.Character.Humanoid.WalkSpeed = 16
            result = "Walkspeed reset to 16"
        elseif command:sub(1, 5) == "tpto " then
            local targetPlayerName = command:sub(6)
            if targetPlayerName == "random" then
                -- Teleport to a random player
                local players = Players:GetPlayers()
                local randomPlayer = players[math.random(2, #players)] -- Exclude self
                if randomPlayer and randomPlayer.Character then
                    player.Character:MoveTo(randomPlayer.Character.HumanoidRootPart.Position)
                    result = "Teleported to random player: " .. randomPlayer.Name
                else
                    result = "No valid random player found."
                end
            else
                -- Teleport to a specific player
                local targetPlayer = Players:FindFirstChild(targetPlayerName)
                if targetPlayer and targetPlayer.Character then
                    player.Character:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
                    result = "Teleported to " .. targetPlayerName
                else
                    result = "Player not found."
                end
            end
        elseif command == "bring unachoredparts" or command == "bring ua" then
            for _, part in pairs(workspace:GetDescendants()) do
                if part:IsA("BasePart") and not part.Anchored and not Players:GetPlayerFromCharacter(part.Parent) and not part:IsDescendantOf(player.Character) and not part:IsDescendantOf(Players.LocalPlayer.Character) then
                    part.Position = player.Character.HumanoidRootPart.Position
                end
            end
            result = "Brought all unanchored parts to you."
        elseif command == "esp" then
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = otherPlayer.Character
                    highlight.FillColor = Color3.new(1, 0, 0)
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                    highlight.OutlineTransparency = 0.5
                    highlight.Parent = otherPlayer.Character
                end
            end
            result = "ESP enabled."
        elseif command == "unesp" then
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, child in pairs(otherPlayer.Character:GetChildren()) do
                        if child:IsA("Highlight") then
                            child:Destroy()
                        end
                    end
                end
            end
            result = "ESP disabled."
        elseif command:sub(1, 10) == "unctest" then
            local luaCode = command:sub(11)
            local func, err = loadstring(game:HttpGet("https://pastebin.com/raw/MzpVFDwx"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started UncTest:\n"
            end
        elseif command:sub(1, 11) == "pcr" then
            local luaCode = command:sub(12)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PCR/refs/heads/main/PartControllerRemote"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "pcr is active:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "PartControllerRemote is active:\n"
            end
        elseif command:sub(1, 12) == "hitblox" then
            local luaCode = command:sub(13)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Hitblox/refs/heads/main/Hitblox"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "HitbloxIsActive:\n"
            end
        elseif command:sub(1, 13) == "dex" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/peyton2465/Dex/master/out.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DexExplorerIsActive:\n"
            end
        elseif command:sub(1, 13) == "dexexplorer" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/peyton2465/Dex/master/out.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DexExplorerIsActive:\n"
            end
        elseif command:sub(1, 13) == "inf" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "InfyieldIsActive:\n"
            end
        elseif command:sub(1, 13) == "infiniteyield" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "InfyieldIsActive:\n"
            end
        elseif command:sub(1, 15) == "blackhole" then
            local luaCode = command:sub(16)
            local func, err = blackHoleScript()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "disableblackhole" then
            local luaCode = command:sub(16)
            local func, err = disableBlackHole()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Disabled:\n"
            end
        elseif command:sub(1, 18) == "cmds" then
            local luaCode = command:sub(18)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Cmdspaneldbsnsbsm/refs/heads/main/ShowCmdsPanellollol123123", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Command panel Started:\nSearch For A Command"
            end
        elseif command:sub(1, 15) == "bh" then
            local luaCode = command:sub(16)
            local func, err = blackHoleScript()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Enabled:\n"
            end
        elseif command:sub(1, 13) == "loopfling" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LFling/refs/heads/main/LoopFling", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "LoopFlingIsActive:\n"
            end
        elseif command:sub(1, 13) == "lfling" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LFling/refs/heads/main/LoopFling", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "LoopFlingIsActive:\n"
            end
        elseif command:sub(1, 15) == "dbh" then
            local luaCode = command:sub(16)
            local func, err = disableBlackHole()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Disabled:\n"
            end
        elseif command:sub(1,4) == "fov " then
            local fovValue = tonumber(command:sub(5))
            if fovValue and fovValue >= 1 and fovValue <= 120 then
                game.Workspace.CurrentCamera.FieldOfView = fovValue
                result = "FOV set to "..fovValue
            else
                result = "Invalid FOV (1-120)"
            end
        elseif command == "serverhop" then
            result = "Attempting to server hop..."
            local HttpService = game:GetService("HttpService")
            local TeleportService = game:GetService("TeleportService")
    
            local placeId = game.PlaceId
            local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
    
            for _, server in ipairs(servers.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id)
                    break
                end
            end
        elseif command == "shop" then
            result = "Attempting to server hop..."
            local HttpService = game:GetService("HttpService")
            local TeleportService = game:GetService("TeleportService")
    
            local placeId = game.PlaceId
            local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
    
            for _, server in ipairs(servers.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id)
                    break
                end
            end
        elseif command:sub(1, 15) == "besp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "boxesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "disableboxesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "dbesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "disablenameesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "floatparts" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Gravity-inverter/refs/heads/main/GI", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "floaty :):\n"
            end
        elseif command:sub(1, 15) == "nesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "nameesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "dnesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Disable:\n"
            end
        elseif command:sub(1, 15) == "disablenameesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Disabled:\n"
            end
        elseif command:sub(1, 13) == "reset" then
            local luaCode = command:sub(14)
            local func, err = game.Players.LocalPlayer.Character.Head:Destroy()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Reseting:\nUr Player has been reseted"
            end
        elseif command:sub(1, 13) == "re" then
            local luaCode = command:sub(14)
            local func, err = game.Players.LocalPlayer.Character.Head:Destroy()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Reseting:\nUr Player has been reseted"
            end
         elseif command:sub(1, 6) == "fling " then
            local targetPlayerName = command:sub(7)
            if targetPlayerName == "random" then
                -- Fling a random player
                local players = Players:GetPlayers()
                local randomPlayer = players[math.random(2, #players)] -- Exclude self
                if randomPlayer then
                    SkidFling(randomPlayer)
                    result = "Flinging random player: " .. randomPlayer.Name
                else
                    result = "No valid random player found."
                end
            else
                -- Fling a specific player
                local targetPlayer = GetPlayer(targetPlayerName)
                if targetPlayer then
                    SkidFling(targetPlayer)
                    result = "Flinging " .. targetPlayer.Name
                else
                    result = "Player not found."
                end
            end
        elseif command:sub(1, 17) == "flingall" then
            local luaCode = command:sub(18)
            local func, err = StartFlingAll({"All"})
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flinged all players:\n"
            end
        elseif command:sub(1, 14) == "sit" then
            local luaCode = command:sub(15)
            local func, err = SitPlayer()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Sitting:\n"
            end
        elseif command:sub(1, 15) == "lay" then
            local luaCode = command:sub(16)
            local func, err = LayDown()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "laying:\n"
            end
        elseif command:sub(1, 15) == "fly" then
            local luaCode = command:sub(16)
            local func, err = Fly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flying:\n"
            end
        elseif command:sub(1, 15) == "unfly" then
            local luaCode = command:sub(16)
            local func, err = UnFly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped Flying:\n"
            end
        elseif command:sub(1, 15) == "f" then
            local luaCode = command:sub(16)
            local func, err = Fly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flying:\n"
            end
        elseif command:sub(1, 15) == "uf" then
            local luaCode = command:sub(16)
            local func, err = UnFly()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped Flying:\n"
            end
        elseif command:sub(1, 15) == "instantkill" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/InstantKillig/refs/heads/main/Coolkillguithingy", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "(req, sword):\n"
            end
        elseif command:sub(1, 15) == "ikill" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/InstantKillig/refs/heads/main/Coolkillguithingy", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "(req, sword):\n"
            end
        elseif command:sub(1, 15) == "infoviewer" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty31.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "I have Ur IP address:\n"
            end
        elseif command:sub(1, 15) == "silverware" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SilverWare/refs/heads/main/SW", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started SilverWare:\n"
            end
        elseif command:sub(1, 15) == "sw" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SilverWare/refs/heads/main/SW", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started SilverWare:\n"
            end
        elseif command:sub(1, 15) == "tornado" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TornadoGuiIg/refs/heads/main/Srrylolitsobfuscatednomorestealing", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started TornadoGui:\nWont work on some exec"
            end
        elseif command:sub(1, 15) == "td" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TornadoGuiIg/refs/heads/main/Srrylolitsobfuscatednomorestealing", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started TornadoGui:\nWont work on some exec"
            end
        elseif command:sub(1, 15) == "changerig" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/Bac0nHck/Scripts/refs/heads/main/ChangeRigType"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Changing Rig Type...:\n"
            end
        elseif command:sub(1, 15) == "rig" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/Bac0nHck/Scripts/refs/heads/main/ChangeRigType"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Changing Rig Type...:\n"
                end
            else
                result = "Changing Rig Type...:\n"
            end
        elseif command:sub(1, 15) == "invertgrav" then
            local luaCode = command:sub(16)
            local func, err = GravOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Inverting Gravity To UnachoredParts:\nWont Work On some Exec"
            end
        elseif command:sub(1, 15) == "uninvertgrav" then
            local luaCode = command:sub(16)
            local func, err = GravOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped Inverting Gravity To UnachoredParts:\n"
            end
        elseif command:sub(1, 15) == "voidprotection" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Started VoidProtection:\nlocalplayer is not vulnerable to voids"
                end
            else
                result = "Started VoidProtection:\nlocalplayer is not vulnerable to voids"
            end
        elseif command:sub(1, 15) == "voidprotectionoff" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Stopped VoidProtection:\nlocalplayer is now vulnerable to voids"
                end
            else
                result = "Stopped VoidProtection:\nlocalplayer is now vulnerable to voids"
            end
        elseif command:sub(1, 15) == "vp" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Started VoidProtection:\nlocalplayer is not vulnerable to voids:\n"
                end
            else
                result = "Started VoidProtection:\nlocalplayer is not vulnerable to voids"
            end
        elseif command:sub(1, 15) == "dvp" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Stopped VoidProtection:\nlocalplayer is now vulnerable to voids"
                end
            else
                result = "Stopped VoidProtection:\nlocalplayer is now vulnerable to voids"
            end
        elseif command:sub(1, 8) == "uwuchat " then
            local textToConvert = command:sub(9)
            if textToConvert and #textToConvert > 0 then
                local function uwuify(text)
                    return text:gsub("[rl]", "w")
                             :gsub("[RL]", "W")
                             :gsub("n([aeiou])", "ny%1")
                             :gsub("N([aeiouAEIOU])", "Ny%1")
                             :gsub("ove", "uv")
                             :gsub("th", "d")
                             :gsub("!+", "~~")
                             :gsub("%?+", "? owo")
                             :gsub("%.+", " uwu")
                end
                
                local suffixes = {" uwu", " >w<", " :3", " ^-^", " >-<", "~~"}
                local uwuText = uwuify(textToConvert)..suffixes[math.random(#suffixes)]
                
                -- Send to actual chat
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(uwuText, "All")
                result = "Sent UwU message to chat!"
            else
                result = "Usage: uwuchat [text]\nExample: uwuchat Hello world!"
            end
        elseif command:sub(1, 10):lower() == "setuagrav " then
            local gravityValue = tonumber(command:sub(11))
            if gravityValue then
                -- Set maximum simulation range
                sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 5000)
                sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", 5000)
                
                -- Clear previous modifications
                if _G.CustomGravityForces then
                    for part, force in pairs(_G.CustomGravityForces) do
                        if part and part.Parent then force:Destroy() end
                    end
                end
                
                _G.CustomGravityForces = {}
                local changed = 0
                local partsProcessed = 0
                local maxPartsPerFrame = 100 -- Process in chunks to prevent lag
                
                -- Create a list of all parts first to avoid nested loops
                local partsToProcess = {}
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored then
                        table.insert(partsToProcess, part)
                    end
                end
                
                -- Process in chunks using RunService
                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local processed = 0
                    while processed < maxPartsPerFrame and partsProcessed < #partsToProcess do
                        partsProcessed = partsProcessed + 1
                        local part = partsToProcess[partsProcessed]
                        
                        -- Remove existing forces
                        for _, child in ipairs(part:GetChildren()) do
                            if child:IsA("BodyForce") and child.Name == "CustomGravityForce" then
                                child:Destroy()
                            end
                        end
                        
                        -- Apply new force
                        local bodyForce = Instance.new("BodyForce")
                        bodyForce.Name = "CustomGravityForce"
                        
                        if gravityValue == 0 then
                            bodyForce.Force = Vector3.new(0, part:GetMass() * workspace.Gravity, 0)
                            part.Velocity = Vector3.new(0, 0, 0)
                            part.RotVelocity = Vector3.new(0, 0, 0)
                        else
                            bodyForce.Force = Vector3.new(0, part:GetMass() * workspace.Gravity * (gravityValue - 1), 0)
                        end
                        
                        bodyForce.Parent = part
                        _G.CustomGravityForces[part] = bodyForce
                        changed = changed + 1
                        processed = processed + 1
                    end
                    
                    if partsProcessed >= #partsToProcess then
                        connection:Disconnect()
                        result = string.format("Successfully applied gravity to %d parts (Multiplier: %.2f)", changed, gravityValue)
                    end
                end)
                
                result = string.format("Processing %d parts... (%.1f%%)", #partsToProcess, 0)
            else
                result = "Invalid value! Usage: setuagrav [number]\nExample: setuagrav 0 (zero gravity), setuagrav 0.5 (half gravity), setuagrav 2.0 (double gravity)"
            end
        elseif command:sub(1, 11):lower() == "resetuagrav" then
            if _G.CustomGravityForces then
                local restored = 0
                local maxPerFrame = 100
                local totalToProcess = 0
                
                -- First count how many we need to process
                for _ in pairs(_G.CustomGravityForces) do totalToProcess = totalToProcess + 1 end
                
                local processed = 0
                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local batch = 0
                    for part, force in pairs(_G.CustomGravityForces) do
                        if part and part.Parent then
                            force:Destroy()
                            restored = restored + 1
                        end
                        _G.CustomGravityForces[part] = nil
                        processed = processed + 1
                        batch = batch + 1
                        
                        if batch >= maxPerFrame then break end
                    end
                    
                    if processed >= totalToProcess then
                        connection:Disconnect()
                        _G.CustomGravityForces = nil
                        result = string.format("Removed custom gravity from %d parts", restored)
                    else
                        result = string.format("Resetting... (%d/%d)", processed, totalToProcess)
                    end
                end)
            else
                result = "No custom gravity forces to remove"
            end
        elseif command:sub(1, 15) == "bhop" then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:WaitForChild("Humanoid")
            
            -- Disconnect previous connection if exists
            if _G.BHopConnection then
                _G.BHopConnection:Disconnect()
            end
            
            -- Create new connection
            _G.BHopConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if humanoid and humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
            
            -- Increase jump power
            humanoid.JumpPower = 60
            humanoid.JumpHeight = 8
            
            result = "Bunnyhop activated! Auto-jumping when touching ground."
        elseif command:sub(1, 18) == "unbhop" then
            if _G.BHopConnection then
                _G.BHopConnection:Disconnect()
                _G.BHopConnection = nil
                
                -- Reset jump power
                local player = game:GetService("Players").LocalPlayer
                if player.Character then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.JumpPower = 50
                        humanoid.JumpHeight = 7.5
                    end
                end
                
                result = "Bunnyhop deactivated"
            else
                result = "Bunnyhop wasn't active"
            end
        elseif command:sub(1, 5) == "spin " then -- spins your character with adjustable speed
            local spinSpeed = tonumber(command:sub(6)) or 20  -- Default speed if not specified
            
            -- Get player components
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            -- Clean up any existing spin connection
            if _G.SpinConnection then
                _G.SpinConnection:Disconnect()
                _G.SpinConnection = nil
            end
            
            -- Create new spinning function
            local spinFunction = function()
                if humanoidRootPart and humanoidRootPart.Parent then
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
                else
                    if _G.SpinConnection then
                        _G.SpinConnection:Disconnect()
                        _G.SpinConnection = nil
                    end
                end
            end
            
            -- Start spinning
            _G.SpinConnection = game:GetService("RunService").Heartbeat:Connect(spinFunction)
            
            result = string.format("Spinning activated at speed: %d\n(Use 'unspin' to stop)", spinSpeed)
        elseif command:sub(1, 7) == "unspin" then -- stops spinning
            if _G.SpinConnection then
                _G.SpinConnection:Disconnect()
                _G.SpinConnection = nil
                result = "Spinning stopped"
            else
                result = "No active spinning to stop"
            end
        elseif command:sub(1, 15) == "graballtools" then -- grabs all tools even if it needs robux or it's on the ground
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if not humanoid then
                result = "Error: No humanoid found in character"
                return
            end
            local toolsCollected = 0
            local toolsFailed = 0
            local toolList = {}
            -- Function to attempt collecting a tool
            local function collectTool(tool)
                if tool:IsA("Tool") and not tool.Parent:IsA("Backpack") and tool.Parent ~= character then
                    -- Try normal collection first
                    local success = pcall(function()
                        tool.Parent = character
                    end)
                    
                    if not success then
                        -- If normal method fails, try alternative methods
                        pcall(function()
                            -- Try to clone the tool
                            local clone = tool:Clone()
                            clone.Parent = character
                            tool = clone
                        end)
                    end
                    if tool.Parent == character then
                        toolsCollected = toolsCollected + 1
                        table.insert(toolList, tool.Name)
                        return true
                    else
                        toolsFailed = toolsFailed + 1
                        return false
                    end
                end
                return false
            end
            -- Collect tools from workspace
            for _, tool in ipairs(game:GetService("Workspace"):GetDescendants()) do
                collectTool(tool)
            end
            -- Collect tools from other players
            for _, otherPlayer in ipairs(game:GetService("Players"):GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, tool in ipairs(otherPlayer.Character:GetDescendants()) do
                        collectTool(tool)
                    end
                end
            end
            -- Collect tools from tool services
            for _, service in ipairs(game:GetChildren()) do
                if service:IsA("BackpackItem") or service:IsA("Tool") then
                    collectTool(service)
                end
            end
            -- Prepare result message
            if toolsCollected > 0 then
                result = string.format("Successfully collected %d tools:\n", toolsCollected) ..
                         table.concat(toolList, ", ") ..
                         (toolsFailed > 0 and string.format("\nFailed to collect %d tools", toolsFailed) or "")
            else
                result = "No tools collected. " .. 
                         (toolsFailed > 0 and string.format("Failed to collect %d tools", toolsFailed) or "No tools found")
            end
        elseif command:sub(1, 15) == "gat" then -- grabs all tools even if it needs robux or it's on the ground
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if not humanoid then
                result = "Error: No humanoid found in character"
                return
            end
            local toolsCollected = 0
            local toolsFailed = 0
            local toolList = {}
            -- Function to attempt collecting a tool
            local function collectTool(tool)
                if tool:IsA("Tool") and not tool.Parent:IsA("Backpack") and tool.Parent ~= character then
                    -- Try normal collection first
                    local success = pcall(function()
                        tool.Parent = character
                    end)
                    
                    if not success then
                        -- If normal method fails, try alternative methods
                        pcall(function()
                            -- Try to clone the tool
                            local clone = tool:Clone()
                            clone.Parent = character
                            tool = clone
                        end)
                    end
                    if tool.Parent == character then
                        toolsCollected = toolsCollected + 1
                        table.insert(toolList, tool.Name)
                        return true
                    else
                        toolsFailed = toolsFailed + 1
                        return false
                    end
                end
                return false
            end
            -- Collect tools from workspace
            for _, tool in ipairs(game:GetService("Workspace"):GetDescendants()) do
                collectTool(tool)
            end
            -- Collect tools from other players
            for _, otherPlayer in ipairs(game:GetService("Players"):GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, tool in ipairs(otherPlayer.Character:GetDescendants()) do
                        collectTool(tool)
                    end
                end
            end
            -- Collect tools from tool services
            for _, service in ipairs(game:GetChildren()) do
                if service:IsA("BackpackItem") or service:IsA("Tool") then
                    collectTool(service)
                end
            end
            -- Prepare result message
            if toolsCollected > 0 then
                result = string.format("Successfully collected %d tools:\n", toolsCollected) ..
                         table.concat(toolList, ", ") ..
                         (toolsFailed > 0 and string.format("\nFailed to collect %d tools", toolsFailed) or "")
            else
                result = "No tools collected. " .. 
                         (toolsFailed > 0 and string.format("Failed to collect %d tools", toolsFailed) or "No tools found")
            end
        elseif command:sub(1, 15) == "toolgiver" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/yofriendfromschool1/Sky-Hub-Backup/main/gametoolgiver.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "ToolGiver Loaded:\n"
            end
        elseif command:sub(1, 15) == "ringpartsv2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SuperRingV2/refs/heads/main/SuperRing"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RingPartsV2 Started:\nRingParts but with shapes"
            end
        elseif command:sub(1, 15) == "rpv2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SuperRingV2/refs/heads/main/SuperRing"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RingPartsV2 Started:\nRingParts but with shapes"
            end
        elseif command:sub(1, 5) == "zoom " then
            local distance = tonumber(command:sub(6))
            if distance then
                local player = game.Players.LocalPlayer
                player.CameraMaxZoomDistance = distance
                player.CameraMinZoomDistance = 0.5 -- optional: minimum zoom in
                result = "ZoomCameraDistance is set to: " .. distance
            else
                result = "Invalid zoom value. Usage: zoom [number]"
            end
        elseif command:sub(1, 15) == "rochips" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/load/refs/heads/main/rcloader"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RoChipsPanel Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "rc" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/load/refs/heads/main/rcloader"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RoChipsPanel Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "control npc" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty38.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
                end
            else
                result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "cn" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty38.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
                end
            else
                result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "pshade" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/randomstring0/pshade-ultimate/refs/heads/main/src/cd.lua'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "your device is overheating at (109.4°F):\nGo Sub To @Im_Patrick"
                end
            else
                result = "your device is overheating at (109.4°F):\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "invistoggle" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet('https://pastebin.com/raw/3Rnd9rHf'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started Invistoggle:\n"
            end
        elseif command:sub(1, 15) == "moveparts" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://pastefy.app/Vcuyg09O/raw", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "MovePartsStarted:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "mp" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://pastefy.app/Vcuyg09O/raw", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "MovePartsStarted:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 5) == "nofog" then -- removes or pushes fog far away
            local atmosphere = game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere")
            local fogEnd = 1000000 -- Very far distance (effectively removes fog)
            
            if atmosphere then
                -- Save original fog settings if we haven't already
                if not _originalFogSettings then
                    _originalFogSettings = {
                        Density = atmosphere.Density,
                        Offset = atmosphere.Offset,
                        Color = atmosphere.Color,
                        Decay = atmosphere.Decay,
                        Glare = atmosphere.Glare,
                        Haze = atmosphere.Haze
                    }
                end
                
                -- Disable fog effects
                atmosphere.Density = 0
                atmosphere.Offset = 0
                atmosphere.Decay = Color3.new(1, 1, 1)
                atmosphere.Glare = 0
                atmosphere.Haze = 0
                
                result = "Fog has been disabled"
            else
                -- If no Atmosphere exists, try adjusting the global Lighting fog
                local lighting = game:GetService("Lighting")
                if not _originalFogSettings then
                    _originalFogSettings = {
                        FogEnd = lighting.FogEnd,
                        FogStart = lighting.FogStart
                    }
                end
                
                lighting.FogEnd = fogEnd
                lighting.FogStart = fogEnd - 100
                
                result = "GobalFog Is Pushed"
            end
        elseif command:sub(1, 5) == "view " then
            local playerName = command:sub(6)
            local targetPlayer
            for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                if player.Name:lower():find(playerName:lower(), 1, true) then
                    targetPlayer = player
                    break
                end
            end
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    local camera = workspace.CurrentCamera
                    camera.CameraType = Enum.CameraType.Custom
                    camera.CameraSubject = humanoid
                    result = "Now viewing player: " .. targetPlayer.Name
                else
                    result = "Player " .. targetPlayer.Name .. " has no humanoid"
                end
            else
                result = "Player not found or has no character: " .. playerName
            end
        elseif command:sub(1, 7) == "unview" then
            local camera = workspace.CurrentCamera
            local localPlayer = game:GetService("Players").LocalPlayer
            if localPlayer.Character then
                camera.CameraType = Enum.CameraType.Custom
                camera.CameraSubject = localPlayer.Character:FindFirstChild("Humanoid")
                result = "Stopped viewing player"
            else
                result = "Cannot reset view — no local character found"
            end
        elseif command:sub(1, 15) == "fakechat" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Obfffakechat/refs/heads/main/Fkaechat", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started FakeChat:\n"
            end
        elseif command:sub(1, 15) == "energize" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Energize-10408"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Just a random anims ui:\n"
            end
        elseif command:sub(1, 15) == "ee" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Energize-10408"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Just a random anims ui:\n"
            end
        elseif command:sub(1, 16) == "afem" then
            local luaCode = command:sub(17)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-AFEM-14048"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Just a random anims ui that only works on r15:\n"
            end
        elseif command:lower():sub(1, 5) == "orbit" then
            local args = {}
            for arg in command:gmatch("%S+") do
                table.insert(args, arg:lower())
            end
            -- Initialize or get existing orbit system
            if not getgenv().OrbitSystem then
                getgenv().OrbitSystem = {
                    Target = nil,
                    Radius = 10,
                    Speed = 2,
                    Angle = 0,
                    Connection = nil,
                    Running = false
                }
            end
            local orbit = getgenv().OrbitSystem
            -- Handle subcommands
            if #args == 1 then
                -- Show status if no subcommands
                result = "Orbit System Status:\n"
                      .. "Target: " .. (orbit.Target and orbit.Target.Name or "None") .. "\n"
                      .. "Radius: " .. orbit.Radius .. "\n"
                      .. "Speed: " .. orbit.Speed .. "\n"
                      .. "Running: " .. (orbit.Running and "YES" or "NO") .. "\n\n"
                      .. "Commands:\n"
                      .. "orbit [player] - Orbit around player\n"
                      .. "orbit stop - Stop orbiting\n"
                      .. "orbit radius [value] - Change orbit distance\n"
                      .. "orbit speed [value] - Change orbit speed"
            elseif args[2] == "stop" then
                -- Stop orbiting
                if orbit.Connection then
                    orbit.Connection:Disconnect()
                    orbit.Connection = nil
                end
                orbit.Running = false
                orbit.Target = nil
                result = "Stopped orbiting"
            elseif args[2] == "radius" and tonumber(args[3]) then
                -- Change orbit radius
                orbit.Radius = tonumber(args[3])
                result = "Orbit radius set to " .. orbit.Radius
            elseif args[2] == "speed" and tonumber(args[3]) then
                -- Change orbit speed
                orbit.Speed = tonumber(args[3])
                result = "Orbit speed set to " .. orbit.Speed
            else
                -- Find player to orbit
                local targetName = table.concat(args, " ", 2)
                local foundPlayer = nil
                -- Search for matching player (allows partial name matching)
                for _, player in pairs(game.Players:GetPlayers()) do
                    if player ~= game.Players.LocalPlayer and 
                       player.Name:lower():find(targetName:lower(), 1, true) then
                        foundPlayer = player
                        break
                    end
                end
                if foundPlayer then
                    -- Stop any existing orbit
                    if orbit.Connection then
                        orbit.Connection:Disconnect()
                    end
                    -- Set new target
                    orbit.Target = foundPlayer
                    orbit.Angle = 0
                    orbit.Running = true
                    -- Create new orbit loop
                    orbit.Connection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                        if not orbit.Running or not orbit.Target or not orbit.Target.Character then return end
                        
                        local targetRoot = orbit.Target.Character:FindFirstChild("HumanoidRootPart")
                        local localChar = game.Players.LocalPlayer.Character
                        if not targetRoot or not localChar then return end
                        
                        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
                        if not localRoot then return end
                        
                        -- Update angle based on speed and time
                        orbit.Angle = orbit.Angle + (orbit.Speed * dt)
                        if orbit.Angle > 2 * math.pi then
                            orbit.Angle = orbit.Angle - (2 * math.pi)
                        end
                        
                        -- Calculate orbit position
                        local offset = Vector3.new(
                            math.cos(orbit.Angle) * orbit.Radius,
                            0,
                            math.sin(orbit.Angle) * orbit.Radius
                        )
                        
                        -- Apply movement
                        localRoot.CFrame = CFrame.new(targetRoot.Position + offset, targetRoot.Position)
                    end)
                    result = "Now orbiting " .. foundPlayer.Name
                else
                    result = "Player not found or invalid command. Usage:\n"
                          .. "orbit [player] - Orbit around player\n"
                          .. "orbit stop - Stop orbiting\n"
                          .. "orbit radius [value] - Change orbit distance\n"
                          .. "orbit speed [value] - Change orbit speed"
                end
            end
        elseif command:sub(1, 15) == "antifling" then
            local luaCode = command:sub(16)
            local func, err = AFON()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started AntiFling:\n"
            end
        elseif command:sub(1, 15) == "af" then
            local luaCode = command:sub(16)
            local func, err = AFON()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started AntiFling:\n"
            end
        elseif command:sub(1, 15) == "unantifling" then
            local luaCode = command:sub(16)
            local func, err = AFOFF()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped AntiFling:\n"
            end
        elseif command:sub(1, 15) == "unaf" then
            local luaCode = command:sub(16)
            local func, err = AFOFF()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped AntiFling:\n"
            end
        elseif command:lower():sub(1, 8) == "ringparts" or command:lower():sub(1, 2) == "rp" then
            if not _G.RingParts then
                _G.RingParts = {
                    Enabled = false,
                    Radius = 100,
                    Strength = 1000,
                    Parts = {},
                    Connections = {}
                }
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")
                local Workspace = game:GetService("Workspace")
                local LocalPlayer = Players.LocalPlayer
                if not getgenv().Network then
                    getgenv().Network = {
                        BaseParts = {},
                        Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
                    }
                    Network.RetainPart = function(Part)
                        if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                            table.insert(Network.BaseParts, Part)
                            Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                            Part.CanCollide = false
                        end
                    end
                    local function EnablePartControl()
                        LocalPlayer.ReplicationFocus = Workspace
                        table.insert(_G.RingParts.Connections, RunService.Heartbeat:Connect(function()
                            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                            for _, Part in pairs(Network.BaseParts) do
                                if Part:IsDescendantOf(Workspace) then
                                    Part.Velocity = Network.Velocity
                                end
                            end
                        end))
                    end
                    EnablePartControl()
                end
                local function RetainPart(part)
                    if part:IsA("BasePart") and not part.Anchored and part:IsDescendantOf(Workspace) then
                        if part:IsDescendantOf(LocalPlayer.Character) then return false end
                        part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                        part.CanCollide = false
                        return true
                    end
                    return false
                end
                local function AddPart(part)
                    if RetainPart(part) and not table.find(_G.RingParts.Parts, part) then
                        table.insert(_G.RingParts.Parts, part)
                    end
                end
                local function RemovePart(part)
                    local index = table.find(_G.RingParts.Parts, part)
                    if index then
                        table.remove(_G.RingParts.Parts, index)
                    end
                end
                for _, part in pairs(Workspace:GetDescendants()) do
                    AddPart(part)
                end
                table.insert(_G.RingParts.Connections, Workspace.DescendantAdded:Connect(AddPart))
                table.insert(_G.RingParts.Connections, Workspace.DescendantRemoving:Connect(RemovePart))
                table.insert(_G.RingParts.Connections, RunService.Heartbeat:Connect(function()
                    if not _G.RingParts.Enabled then return end
                    local character = LocalPlayer.Character
                    if not character then return end
                    local hrp = character:FindFirstChild("HumanoidRootPart")
                    if not hrp then return end
                    local center = hrp.Position
                    local height = 100
                    local rotationSpeed = 0.5
                    for _, part in pairs(_G.RingParts.Parts) do
                        if part.Parent and not part.Anchored then
                            local pos = part.Position
                            local distance = (Vector3.new(pos.X, center.Y, pos.Z) - center).Magnitude
                            local angle = math.atan2(pos.Z - center.Z, pos.X - center.X)
                            local newAngle = angle + math.rad(rotationSpeed)
                            local targetPos = Vector3.new(
                                center.X + math.cos(newAngle) * math.min(_G.RingParts.Radius, distance),
                                center.Y + height * math.abs(math.sin((pos.Y - center.Y)/height)),
                                center.Z + math.sin(newAngle) * math.min(_G.RingParts.Radius, distance)
                            )
                            local dir = (targetPos - pos).Unit
                            part.Velocity = dir * _G.RingParts.Strength
                        end
                    end
                end))
            end
            local args = {}
            for word in command:gmatch("%S+") do
                table.insert(args, word:lower())
            end
            if #args == 1 then
                _G.RingParts.Enabled = not _G.RingParts.Enabled
                return "RingParts " .. (_G.RingParts.Enabled and "enabled" or "disabled")
            elseif args[2] == "radius" and tonumber(args[3]) then
                _G.RingParts.Radius = math.clamp(tonumber(args[3]), 1, 10000)
                return "RingParts radius set to " .. _G.RingParts.Radius
            elseif args[2] == "speed" and tonumber(args[3]) then
                _G.RingParts.Strength = math.clamp(tonumber(args[3]), 1, 100000)
                return "RingParts speed set to " .. _G.RingParts.Strength
            elseif args[2] == "status" then
                return string.format([[
        RingParts Status:
        Enabled: %s
        Radius: %d
        Speed: %d
        Active Parts: %d]], tostring(_G.RingParts.Enabled), _G.RingParts.Radius, _G.RingParts.Strength, #_G.RingParts.Parts)
            else
                return [[RingParts commands:
        rp/ringparts - Toggle RingParts
        rp/ringparts radius [value] - Set effect radius (1-10000)
        rp/ringparts speed [value] - Set effect speed (1-100000)
        rp/ringparts status - Show current settings]]
            end
        elseif command:lower():sub(1,5) == "kill " then
            local playerName = command:sub(6):match("^%s*(.-)%s*$") -- Trim whitespace
            if playerName and playerName ~= "" then
                local success, execResult = pcall(function()
                    return StartKillEffect(playerName)
                end)
                
                if success then
                    if execResult then
                        result = execResult[2] -- Get the message from the tuple
                    else
                        result = "Kill effect started"
                    end
                else
                    result = "Error: "..tostring(execResult)
                end
            else
                result = "Please specify a player name (e.g. 'kill username')"
            end
        elseif command:sub(1, 15) == "players" then
            local luaCode = command:sub(16)
            if luaCode and luaCode:len() > 0 then
                local func, err = load("return " .. luaCode)
                if not func then
                    func, err = load(luaCode)
                end
                
                if func then
                    local success, execResult = pcall(func)
                    if success then
                        result = "Executed successfully:\n" .. tostring(execResult)
                    else
                        result = "Execution error:\n" .. tostring(execResult)
                    end
                else
                    result = "Lua error:\n" .. tostring(err)
                end
            else
                -- Show all player usernames
                local players = game:GetService("Players"):GetPlayers()
                local usernames = {}
                for _, player in ipairs(players) do
                    table.insert(usernames, player.Name)
                end
                result = "Players online (" .. #usernames .. "):\n" .. table.concat(usernames, "\n")
            end
        elseif command:sub(1, 15) == "plrs" then
            local luaCode = command:sub(16)
            if luaCode and luaCode:len() > 0 then
                local func, err = load("return " .. luaCode)
                if not func then
                    func, err = load(luaCode)
                end
                
                if func then
                    local success, execResult = pcall(func)
                    if success then
                        result = "Executed successfully:\n" .. tostring(execResult)
                    else
                        result = "Execution error:\n" .. tostring(execResult)
                    end
                else
                    result = "Lua error:\n" .. tostring(err)
                end
            else
                -- Show all player usernames
                local players = game:GetService("Players"):GetPlayers()
                local usernames = {}
                for _, player in ipairs(players) do
                    table.insert(usernames, player.Name)
                end
                result = "Players online (" .. #usernames .. "):\n" .. table.concat(usernames, "\n")
            end
        elseif command:lower():sub(1, 15) == "animationspeed " or command:lower():sub(1, 3) == "as " then
            -- Extract speed value (works for both versions)
            local speedValue
            if command:lower():sub(1, 3) == "as " then
                speedValue = tonumber(command:sub(4))
            else
                speedValue = tonumber(command:sub(16))
            end
            
            if speedValue then
                AnimationSpeedController.CurrentSpeed = speedValue
                AnimationSpeedController.Enabled = true
                
                -- Start the controller if not already running
                if not AnimationSpeedController.Running then
                    task.spawn(ControlAnimationSpeeds)
                end
                
                result = "(to reset type in 1) Animation speed set to " .. speedValue
            else
                result = "Invalid speed value. Please provide a number."
            end
        elseif command:sub(1, 15) == "antikick" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/AntkickLol/refs/heads/main/Antikicklol"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiKick Started:\n"
            end
        elseif command:sub(1, 15) == "ak" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/AntkickLol/refs/heads/main/Antikicklol"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiKick Started:\n"
            end
        elseif command:sub(1, 15) == "antilag" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Al/refs/heads/main/AntiLag", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n"
            end
        elseif command:sub(1, 15) == "al" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Al/refs/heads/main/AntiLag", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n"
            end
        elseif command:sub(1, 15) == "antilag2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Jxeybdfkhwnsantilagejbesnjdd/refs/heads/main/Al2", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n(rec, FullBright)"
            end
        elseif command:sub(1, 15) == "al2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Jxeybdfkhwnsantilagejbesnjdd/refs/heads/main/Al2", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n(rec, FullBright)"
            end
        elseif command:sub(1, 15) == "loopkill" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/2Loopkillsbnensnsns3838/refs/heads/main/Lkobf", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "LoopKill UI Started:\n"
            end
        elseif command:sub(1, 15) == "lkill" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/2Loopkillsbnensnsns3838/refs/heads/main/Lkobf", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "LoopKill UI Started:\n"
            end
        elseif command:sub(1, 15) == "fakelag" then
            local luaCode = command:sub(16)
            local func, err = Fun()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "FakeLag Started:\n"
            end
        elseif command:sub(1, 15) == "unfakelag" then
            local luaCode = command:sub(16)
            local func, err = NoFun()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "FakeLag Stopped:\n"
            end
        elseif command:sub(1, 15) == "drawchat" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/AKadminlol/Chatdraw/refs/heads/main/Chattdraw"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "someone recommended me this :/ :\n"
            end
        elseif command:sub(1, 15) == "hugtool" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/ExploitFin/Animations/refs/heads/main/Front%20and%20Back%20Hug%20Tool"))()loadstring(game:HttpGet("https://raw.githubusercontent.com/ExploitFin/Animations/refs/heads/main/Front%20and%20Back%20Hug%20Tool"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "someone recommended me this :/ :\n"
            end
        elseif command:sub(1, 15) == "drawchat" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/AKadminlol/Chatdraw/refs/heads/main/Chattdraw"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "someone recommended me this :/ :\n"
            end
        elseif command:sub(1, 15) == "flag" then
            local luaCode = command:sub(16)
            local func, err = Fun()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "FakeLag Started:\n"
            end
        elseif command:sub(1, 15) == "unflag" then
            local luaCode = command:sub(16)
            local func, err = NoFun()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "FakeLag Stopped:\n"
            end
        elseif command:lower():sub(1, 8) == "aimassist" or command:lower():sub(1, 3) == "aim" then
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Camera = workspace.CurrentCamera
            local LocalPlayer = Players.LocalPlayer
            local Mouse = LocalPlayer:GetMouse()
            _G.AimAssistSettings = _G.AimAssistSettings or {
                Enabled = false,
                FOV = 70,
                ShowFOV = false,
                Strength = 0.5,
                FOVCircle = nil,
                CurrentTarget = nil
            }
            -- FOV Circle Draw
            if not _G.AimAssistSettings.FOVCircle then
                local fovCircle = Drawing.new("Circle")
                fovCircle.Color = Color3.fromRGB(255, 0, 0)
                fovCircle.Thickness = 1
                fovCircle.Filled = false
                fovCircle.Transparency = 0.6
                fovCircle.Visible = _G.AimAssistSettings.ShowFOV
                _G.AimAssistSettings.FOVCircle = fovCircle
                RunService.RenderStepped:Connect(function()
                    if _G.AimAssistSettings.FOVCircle then
                        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        _G.AimAssistSettings.FOVCircle.Position = center
                        _G.AimAssistSettings.FOVCircle.Radius = _G.AimAssistSettings.FOV
                        _G.AimAssistSettings.FOVCircle.Visible = _G.AimAssistSettings.ShowFOV
                    end
                end)
            end
            -- Assist Logic
            if not _G.AimAssistConnection then
                _G.AimAssistConnection = RunService.RenderStepped:Connect(function()
                    if not _G.AimAssistSettings.Enabled then return end
                    local closest, closestDist = nil, _G.AimAssistSettings.FOV
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                            local head = player.Character.Head
                            local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                            local dist = (Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                            if onScreen and dist < closestDist then
                                closest = head
                                closestDist = dist
                            end
                        end
                    end
                    _G.AimAssistSettings.CurrentTarget = closest
                    if closest then
                        local direction = (closest.Position - Camera.CFrame.Position).Unit
                        local newCF = CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + direction)
                        Camera.CFrame = Camera.CFrame:Lerp(newCF, _G.AimAssistSettings.Strength)
                    end
                end)
            end
            -- Command handler
            local args = command:split(" ")
            local sub = args[2]
            local value = tonumber(args[3])
            local res = ""
            if not sub then
                _G.AimAssistSettings.Enabled = not _G.AimAssistSettings.Enabled
                res = "AimAssist " .. (_G.AimAssistSettings.Enabled and "Enabled" or "Disabled")
            elseif sub == "fov" and value then
                _G.AimAssistSettings.FOV = math.clamp(value, 10, 500)
                res = "FOV set to " .. _G.AimAssistSettings.FOV
            elseif sub == "showfov" then
                _G.AimAssistSettings.ShowFOV = not _G.AimAssistSettings.ShowFOV
                res = "FOV circle " .. (_G.AimAssistSettings.ShowFOV and "shown" or "hidden")
            elseif sub == "strength" and value then
                _G.AimAssistSettings.Strength = math.clamp(value, 0.1, 1)
                res = "Aim strength set to " .. _G.AimAssistSettings.Strength
            else
                res = [[AimAssist Usage:
        aimassist - toggle
        aimassist fov [number] - set FOV size
        aimassist strength [0.1 - 1] - set lock-on smoothness
        aimassist showfov - toggle FOV visibility]]
            end
            return res
        elseif command:sub(1, 7) == "hitbox " then
            local valueStr = command:sub(8)
            local value = tonumber(valueStr)
            local localPlayer = game.Players.LocalPlayer
            
            if value then
                if value == 0 then
                    -- Turn off hitboxes for all players
                    for _, player in ipairs(game.Players:GetPlayers()) do
                        if player ~= localPlayer then
                            local character = player.Character or player.CharacterAdded:Wait()
                            local hrp = character:FindFirstChild("HumanoidRootPart")
                            local head = character:FindFirstChild("Head")
                            
                            -- Restore HRP properties
                            if hrp and hrp:FindFirstChild("OriginalSize") then
                                hrp.Size = hrp.OriginalSize.Value
                                hrp.CanCollide = true
                                hrp.Transparency = 0
                                hrp.OriginalSize:Destroy()
                            end
                            
                            -- Restore Head properties
                            if head and head:FindFirstChild("OriginalSize") then
                                head.Size = head.OriginalSize.Value
                                head.CanCollide = true
                                head.Transparency = 0
                                head.OriginalSize:Destroy()
                            end
                        end
                    end
                    result = "Hitboxes turned off for all applicable players"
                else
                    -- Expand hitboxes based on team settings
                    for _, player in ipairs(game.Players:GetPlayers()) do
                        if player ~= localPlayer then
                            -- Check team conditions
                            local shouldModify = false
                            if game.Teams and #game.Teams:GetTeams() > 0 then
                                -- Team game - only modify enemies
                                shouldModify = player.Team ~= localPlayer.Team
                            else
                                -- No teams - modify everyone except local player
                                shouldModify = true
                            end
                            
                            if shouldModify then
                                local character = player.Character
                                if character then
                                    local hrp = character:FindFirstChild("HumanoidRootPart")
                                    local head = character:FindFirstChild("Head")
                                    
                                    -- Handle HRP
                                    if hrp then
                                        if not hrp:FindFirstChild("OriginalSize") then
                                            local originalSize = Instance.new("Vector3Value")
                                            originalSize.Name = "OriginalSize"
                                            originalSize.Value = hrp.Size
                                            originalSize.Parent = hrp
                                        end
                                        hrp.Size = Vector3.new(value, value, value)
                                        hrp.CanCollide = false
                                        hrp.Transparency = 0.5
                                    end
                                    
                                    -- Handle Head
                                    if head then
                                        if not head:FindFirstChild("OriginalSize") then
                                            local originalSize = Instance.new("Vector3Value")
                                            originalSize.Name = "OriginalSize"
                                            originalSize.Value = head.Size
                                            originalSize.Parent = head
                                        end
                                        head.Size = Vector3.new(value, value, value)
                                        head.CanCollide = false
                                        head.Transparency = 0.5
                                    end
                                end
                            end
                        end
                    end
                    result = "Hitboxes expanded to " .. value .. " Type in 0 if you want to reset"
                end
            else
                result = "Invalid value. Usage: hitbox [number] or hitbox 0 to turn off"
            end
        elseif command:sub(1, 15) == "susgui" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/TmcdSusGu182-hi/refs/heads/main/GuiLol", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "🍆💦:\n"
            end
        elseif command:sub(1, 15) == "ss" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/TmcdSusGu182-hi/refs/heads/main/GuiLol", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "🍆💦:\n"
            end
        elseif command:sub(1, 15) == "aat" then
            local luaCode = command:sub(16)
            local func, err = AAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Activated All Tools:\n"
            end
        elseif command:sub(1, 15) == "activatealltools" then
            local luaCode = command:sub(16)
            local func, err = AAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Activated All Tools:\n"
            end
        elseif command:sub(1, 15) == "dat" then
            local luaCode = command:sub(16)
            local func, err = DAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Dropped All Tools:\n"
            end
        elseif command:sub(1, 15) == "dropalltools" then
            local luaCode = command:sub(16)
            local func, err = DAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Dropped All Tools:\n"
            end

        elseif command:sub(1, 14) == "hitbox" then
            local luaCode = command:sub(15)
            local func, err = hitboxeson()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Expanded:\nHrp or head has been expanded"
            end
        elseif command:sub(1, 14) == "unhitbox" then
            local luaCode = command:sub(15)
            local func, err = hitboxesoff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DeExpanded:\nHrp or head size is set to normal"
            end
        elseif command:sub(1, 14) == "emitteroff" then
            local luaCode = command:sub(15)
            local func, err = EmitterOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter On:\n"
            end
        elseif command:sub(1, 14) == "en" then
            local luaCode = command:sub(15)
            local func, err = EmitterOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter On:\n"
            end
        elseif command:sub(1, 14) == "ef" then
            local luaCode = command:sub(15)
            local func, err = EmitterOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter Off:\n"
            end
        elseif command:sub(1, 15) == "enabletfling" then
            local luaCode = command:sub(16)
            local func, err = TFlingOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is enabled:\n"
            end
        elseif command:sub(1, 15) == "disabletfling" then
            local luaCode = command:sub(16)
            local func, err = TFlingOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is disabled:\n"
            end
        elseif command:sub(1, 15) == "etf" then
            local luaCode = command:sub(16)
            local func, err = TFlingOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is enabled:\n"
            end
        elseif command:sub(1, 15) == "disabletfling" then
            local luaCode = command:sub(16)
            local func, err = TFlingOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling is disabled:\n"
            end
        elseif command:sub(1, 15) == "noclip" then
            local luaCode = command:sub(17)
            local func, err = ModeOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Noclip:\nWalk thru Walls"
            end
        elseif command:sub(1, 15) == "clip" then
            local luaCode = command:sub(17)
            local func, err = ModeOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Clipped:\nWalk Thru Walls Is Disabled"
            end
        elseif command:sub(1, 15) == "namelessadmin" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminIsActive:\n"
            end
        elseif command:sub(1, 15) == "na" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminIsActive:\n"
            end
        elseif command:sub(1, 15) == "namelessadminv2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminV2IsActive:\n"
            end
        elseif command:sub(1, 15) == "nav2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminV2IsActive:\n"
            end
        elseif command:sub(1, 15) == "telekinesis" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TelekinesisIsActive:\n"
            end
        elseif command:sub(1, 15) == "tk" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TelekinesisIsActive:\n"
            end
        elseif command:sub(1, 13) == "f3x" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "GetGear rbxassetid://6695644299:\nF3X is active"
            end
        elseif command:sub(1, 13) == "winobby" then
            local luaCode = command:sub(14)
            local func, err = TPCheckpoints()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Finished Obby:\nMay Not Work On Some (Games)"
            end
        elseif command:sub(1, 13) == "fex" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "GetGear rbxassetid://6695644299:\nF3X is active"
            end
        elseif command:sub(1, 13) == "esp" then
            local luaCode = command:sub(14)
            local func, err = EspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "EspIsEnabled:\nEsp On"
            end
        elseif command:sub(1, 13) == "unesp" then
            local luaCode = command:sub(14)
            local func, err = EspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "EspIsDisabled:\nEsp Off"
            end
        elseif command:sub(1, 5) == "grav " then
            local grav = tonumber(command:sub(6))
            if grav and grav > 0 then
                workspace.Gravity = grav
                result = "Gravity set to "..grav
            else
                result = "Invalid gravity. Use: grav [number]"
            end
        elseif command:sub(1, 8) == "infjump" then
            local infiniteJumpEnabled = not _G.infiniteJumpEnabled
            _G.infiniteJumpEnabled = infiniteJumpEnabled
    
            if infiniteJumpEnabled then
                game:GetService("UserInputService").JumpRequest:Connect(function()
                    game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
                end)
                result = "Infinite jump enabled"
            else
                result = "Infinite jump disabled"
            end
        elseif command == "stoptpwalk" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StopTpWalk()
                result = "TP Walk Disabled"
            end
        elseif command == "stpw" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StopTpWalk()
                result = "TP Walk Disabled"
            end
        elseif command == "tpwalk" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StartTpWalk()
                result = "TP Walk enabled."
            end
        elseif command == "tpw" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StartTpWalk()
                result = "TP Walk Enabled."
            end
        elseif command:lower():find("^tpws ") or command:lower():find("^tpwalkspeed ") then
            local speed = tonumber(command:match("%d+"))
            if speed and speed > 0 then
                tpSpeed = speed
                result = "TP Speed set to " .. speed
            else
                result = "Invalid speed (use numbers > 0)"
            end
        elseif command:sub(1, 10) == "fullbright" then
            -- Enable fullbright (remove lighting effects)
            game:GetService("Lighting").GlobalShadows = false
            game:GetService("Lighting").Brightness = 2
            game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
            result = "Full Bright Is Enabled"
        elseif command:sub(1, 12) == "unfullbright" then
            -- Reset lighting to default values
            game:GetService("Lighting").GlobalShadows = true
            game:GetService("Lighting").Brightness = 1
            game:GetService("Lighting").Ambient = Color3.new(0.5, 0.5, 0.5)
            result = "Full Bright Is Disabled"
        elseif command:sub(1, 10) == "fb" then
            -- Enable fullbright (remove lighting effects)
            game:GetService("Lighting").GlobalShadows = false
            game:GetService("Lighting").Brightness = 2
            game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
            result = "Full Bright Is Enabled"
        elseif command:sub(1, 12) == "unfb" then
            -- Reset lighting to default values
            game:GetService("Lighting").GlobalShadows = true
            game:GetService("Lighting").Brightness = 1
            game:GetService("Lighting").Ambient = Color3.new(0.5, 0.5, 0.5)
            result = "Full Bright Is Disabled"
        elseif command == "xray" then
            enableXRay()
            result = "XRay enabled."
        elseif command == "unxray" then
            disableXRay()
            result = "XRay disabled."
        end

        -- Add the result to the output
        outputText.Text = outputText.Text .. "\n" .. result

        -- Auto-scroll to the bottom
        outputFrame.CanvasPosition = Vector2.new(0, outputText.TextBounds.Y)
    end

    -- Connect the input box to the handleInput function
    inputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            handleInput(inputBox)
        end
    end)

    -- Allow the user to press Enter to submit the command
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if input.KeyCode == Enum.KeyCode.Return and inputBox:IsFocused() then
            handleInput(inputBox)
        end
    end)
    
    -- Dragging functionality
    local gui = mainFrame -- Change this to the UI element you want to make draggable

    local dragging
    local dragStart
    local startPos
    local lastMousePos
    local lastGoalPos
    local DRAG_SPEED = 8 -- Adjust for smoother or faster dragging

    local function Lerp(a, b, m)
        return a + (b - a) * m
    end

    local function Update(dt)
        if not startPos then return end
        if not dragging and lastGoalPos then
            gui.Position = UDim2.new(
                startPos.X.Scale,
                Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED),
                startPos.Y.Scale,
                Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED)
            )
            return
        end

        local delta = lastMousePos - UserInputService:GetMouseLocation()
        local xGoal = startPos.X.Offset - delta.X
        local yGoal = startPos.Y.Offset - delta.Y
        lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)

        gui.Position = UDim2.new(
            startPos.X.Scale,
            Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED),
            startPos.Y.Scale,
            Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED)
        )
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position
            lastMousePos = UserInputService:GetMouseLocation()

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    RunService.Heartbeat:Connect(Update)

    print("Script completed")
end

    -- Initial UI creation
    createUI()

    -- Destroy UI when the player dies
    player.CharacterRemoving:Connect(destroyUI)

    -- Recreate UI when the player respawns
    player.CharacterAdded:Connect(createUI)
end)
end)

if not success then
    warn("Error caught:", err) -- Prevents full error log spam
    createNotification("⚠️ Error Caught: " .. err, 5, "rbxassetid://1234567890") -- Replace with an appropriate image asset ID
end
end)
wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
