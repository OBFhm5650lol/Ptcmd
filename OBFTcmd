pcall(function()

-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local ContentProvider = game:GetService("ContentProvider")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- CmdsVariables
local backLoopConnection = nil
local backAnimTrack = nil

-- [[ THIS IS A SNIPPET ]] --

-- Import the Library
local fnl = loadstring(game:HttpGetAsync 'https://raw.githubusercontent.com/Code1Tech/utils/main/notification.lua')()

-- Make a Notification function
function notify(title, text, duration)
  title = title or "Notification"
  text = text or "No text provided."
  duration = duration or 5
  
  fnl:MakeNotification({
    Title = title,
    Text = text,
    Duration = duration
  })
end

-- Constants
local INTRO_TEXT = "TCMD"
local WATERMARK_TEXT = "Made By hmmm5650"
local INTRO_DURATION = 6 -- Duration of the entire intro animation in seconds
local PARTICLE_COUNT = 60 -- Increased particle count for richer background
local PARTICLE_COLORS = {
    Color3.fromRGB(0, 100, 255),  -- Blue particles
    Color3.fromRGB(0, 150, 255),
    Color3.fromRGB(50, 200, 255)
}

-- Preload assets to prevent lag
ContentProvider:PreloadAsync({
    "rbxassetid://11173905963", -- Example of a potential custom font
    "rbxassetid://112490670948282",   -- Example particle texture
    "rbxassetid://120131404524020" -- Example icon image (can be replaced with your preferred icon)
})

-- Create ScreenGui with improved settings
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CinematicIntro"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 999 -- Ensure it's on top

-- Create layered background for depth effect
local background = Instance.new("Frame")
background.Name = "Background"
background.Size = UDim2.new(1, 0, 1, 0)
background.BackgroundColor3 = Color3.fromRGB(10, 10, 30)  -- Dark blue background
background.BackgroundTransparency = 1
background.ZIndex = 0
background.Parent = screenGui

-- Create gradient overlay for background
local bgGradient = Instance.new("UIGradient")
bgGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 20, 50)),  -- Dark blue gradient
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 40))
})
bgGradient.Rotation = 90
bgGradient.Transparency = NumberSequence.new(0.7)
bgGradient.Parent = background

-- Create particle system with improved visuals
local particles = {}
for i = 1, PARTICLE_COUNT do
    local particle = Instance.new("ImageLabel") -- Using ImageLabel for potential texture
    particle.Name = "Particle_"..i
    particle.Size = UDim2.new(0, math.random(4, 12), 0, math.random(4, 12))
    particle.Position = UDim2.new(0, math.random(0, 1000), 0, math.random(0, 600))
    particle.BackgroundTransparency = 1
    particle.ImageColor3 = PARTICLE_COLORS[math.random(1, #PARTICLE_COLORS)]
    particle.ImageTransparency = 0.7
    particle.Image = "rbxassetid://112490670948282" -- Optional particle texture
    particle.ZIndex = 1
    particle.Parent = background
    
    -- Store initial position for animation with varied properties
    particles[i] = {
        instance = particle,
        speed = math.random(15, 40),
        direction = Vector2.new(math.random() * 2 - 1, math.random() * 2 - 1).Unit,
        rotationSpeed = math.random(-5, 5),
        currentRotation = 0
    }
end

-- Create TextLabel for intro text with improved styling
local textLabel = Instance.new("TextLabel")
textLabel.Name = "Title"
textLabel.Text = INTRO_TEXT
textLabel.Size = UDim2.new(0, 0, 0, 0)
textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.BackgroundTransparency = 1
textLabel.Font = Enum.Font.GothamBlack
textLabel.TextScaled = true
textLabel.TextStrokeTransparency = 0.8
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.ZIndex = 3
textLabel.TextTransparency = 1
textLabel.Parent = screenGui

-- Create advanced text effects
local textShadow = textLabel:Clone()
textShadow.Name = "TextShadow"
textShadow.TextColor3 = Color3.fromRGB(0, 100, 200)  -- Blue shadow
textShadow.TextTransparency = 0.9
textShadow.Position = UDim2.new(0.5, 4, 0.5, 4) -- Offset for shadow
textShadow.ZIndex = 2
textShadow.Parent = screenGui

-- Create gradient underlay for text (KEEPING ORIGINAL GRADIENT FOR TITLE)
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 150)),  -- Original green
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 200, 255)),  -- Original teal
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 255))  -- Original purple
})
gradient.Rotation = 0
gradient.Enabled = false
gradient.Parent = textLabel

-- Create TextLabel for watermark with improved styling
local watermarkLabel = Instance.new("TextLabel")
watermarkLabel.Name = "Watermark"
watermarkLabel.Text = WATERMARK_TEXT
watermarkLabel.Size = UDim2.new(0.3, 0, 0.05, 0)
watermarkLabel.Position = UDim2.new(0.5, 0, 0.85, 0)
watermarkLabel.AnchorPoint = Vector2.new(0.5, 0.5)
watermarkLabel.TextColor3 = Color3.fromRGB(100, 180, 255)  -- Light blue watermark
watermarkLabel.BackgroundTransparency = 1
watermarkLabel.Font = Enum.Font.GothamMedium
watermarkLabel.TextSize = 18
watermarkLabel.TextTransparency = 1
watermarkLabel.ZIndex = 3
watermarkLabel.Parent = screenGui

-- Create transparent icon in top right corner
local icon = Instance.new("ImageLabel")
icon.Name = "TopRightIcon"
icon.Size = UDim2.new(0, 50, 0, 50) -- Adjust size as needed
icon.Position = UDim2.new(1, -60, 0, 10) -- 10 pixels from top, 60 pixels from right
icon.AnchorPoint = Vector2.new(1, 0) -- Anchored to top-right
icon.BackgroundTransparency = 1
icon.ImageTransparency = 0.7 -- Semi-transparent
icon.Image = "rbxassetid://120131404524020" -- Replace with your preferred icon image ID
icon.ZIndex = 3

-- Add rounded corners to the icon
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0.2, 0) -- 20% of the icon's size (adjust as needed)
corner.Parent = icon

icon.Parent = screenGui

-- Create cinematic effects
local blurEffect = Instance.new("BlurEffect")
blurEffect.Name = "CinematicBlur"
blurEffect.Size = 24
blurEffect.Parent = Lighting

local colorCorrection = Instance.new("ColorCorrectionEffect")
colorCorrection.Name = "CinematicColor"
colorCorrection.TintColor = Color3.fromRGB(180, 200, 255)  -- Cool blue tint
colorCorrection.Brightness = -0.1
colorCorrection.Contrast = 0.1
colorCorrection.Saturation = -0.1
colorCorrection.Parent = Lighting

local dofEffect = Instance.new("DepthOfFieldEffect")
dofEffect.Name = "CinematicDOF"
dofEffect.FarIntensity = 0.1
dofEffect.FocusDistance = 0.05
dofEffect.InFocusRadius = 5
dofEffect.NearIntensity = 0.75
dofEffect.Parent = Lighting

-- Improved tween timing with more dynamic animation
local fadeInTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.35,
    Enum.EasingStyle.Quint,
    Enum.EasingDirection.Out,
    0,
    false,
    0
)

local holdTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.3,
    Enum.EasingStyle.Sine,
    Enum.EasingDirection.InOut,
    0,
    false,
    0
)

local fadeOutTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.35,
    Enum.EasingStyle.Back,
    Enum.EasingDirection.In,
    0,
    false,
    0
)

-- Additional tweens for enhanced effects
local bgFadeInTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.25,
    Enum.EasingStyle.Quad,
    Enum.EasingDirection.Out,
    0,
    false,
    0
)

local gradientRotateTweenInfo = TweenInfo.new(
    INTRO_DURATION * 0.6,
    Enum.EasingStyle.Linear,
    Enum.EasingDirection.InOut,
    0,
    false,
    0
)

-- Tween goals with more dynamic animations
local fadeInGoals = {
    TextTransparency = 0, 
    Size = UDim2.new(0.7, 0, 0.7, 0),
    TextStrokeTransparency = 0.5
}

local shadowFadeInGoals = {
    TextTransparency = 0.7,
    Size = UDim2.new(0.7, 0, 0.7, 0)
}

local holdGoals = {
    Rotation = 5,
    TextColor3 = Color3.fromRGB(200, 240, 255)  -- Light blue text during hold
}

local fadeOutGoals = {
    TextTransparency = 1, 
    Size = UDim2.new(1.2, 0, 1.2, 0),
    Rotation = -5,
    TextStrokeTransparency = 1
}

local blurOutGoals = {Size = 0}
local watermarkFadeInGoals = {
    Position = UDim2.new(0.5, 0, 0.85, 0), 
    TextTransparency = 0.2,
    TextColor3 = Color3.fromRGB(0, 150, 255)  -- Blue watermark
}

local watermarkFadeOutGoals = {
    Position = UDim2.new(0.5, 0, 0.9, 0), 
    TextTransparency = 1
}

local bgFadeInGoals = {BackgroundTransparency = 0.85}
local bgFadeOutGoals = {BackgroundTransparency = 1}
local gradientEnableGoals = {Enabled = true}
local gradientDisableGoals = {Enabled = false}
local gradientRotateGoals = {Rotation = 360}

-- Icon animation goals
local iconFadeInGoals = {ImageTransparency = 0.3}
local iconFadeOutGoals = {ImageTransparency = 1}

-- Create tweens
local fadeInTween = TweenService:Create(textLabel, fadeInTweenInfo, fadeInGoals)
local shadowFadeInTween = TweenService:Create(textShadow, fadeInTweenInfo, shadowFadeInGoals)
local holdTween = TweenService:Create(textLabel, holdTweenInfo, holdGoals)
local fadeOutTween = TweenService:Create(textLabel, fadeOutTweenInfo, fadeOutGoals)
local shadowFadeOutTween = TweenService:Create(textShadow, fadeOutTweenInfo, fadeOutGoals)
local blurOutTween = TweenService:Create(blurEffect, fadeOutTweenInfo, blurOutGoals)
local watermarkFadeInTween = TweenService:Create(watermarkLabel, fadeInTweenInfo, watermarkFadeInGoals)
local watermarkFadeOutTween = TweenService:Create(watermarkLabel, fadeOutTweenInfo, watermarkFadeOutGoals)
local bgFadeInTween = TweenService:Create(background, bgFadeInTweenInfo, bgFadeInGoals)
local bgFadeOutTween = TweenService:Create(background, fadeOutTweenInfo, bgFadeOutGoals)
local gradientEnableTween = TweenService:Create(gradient, fadeInTweenInfo, gradientEnableGoals)
local gradientDisableTween = TweenService:Create(gradient, fadeOutTweenInfo, gradientDisableGoals)
local gradientRotateTween = TweenService:Create(gradient, gradientRotateTweenInfo, gradientRotateGoals)
local iconFadeInTween = TweenService:Create(icon, fadeInTweenInfo, iconFadeInGoals)
local iconFadeOutTween = TweenService:Create(icon, fadeOutTweenInfo, iconFadeOutGoals)

-- Enhanced particle animation with rotation
local particleConnection
local function animateParticles(dt)
    for _, particle in ipairs(particles) do
        local currentPos = particle.instance.Position
        local moveAmount = particle.speed * dt
        local newX = (currentPos.X.Offset + particle.direction.X * moveAmount) % 1000
        local newY = (currentPos.Y.Offset + particle.direction.Y * moveAmount) % 600
        
        particle.currentRotation = (particle.currentRotation + particle.rotationSpeed * dt) % 360
        particle.instance.Rotation = particle.currentRotation
        particle.instance.Position = UDim2.new(0, newX, 0, newY)
    end
end

-- Function to play intro animation with improved sequencing
local function playIntroAnimation()
    -- Parent the ScreenGui to the player's PlayerGui
    local player = Players.LocalPlayer
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    -- Start particle animation
    particleConnection = RunService.Heartbeat:Connect(animateParticles)
    
    -- Initial state
    background.BackgroundTransparency = 1
    
    -- Play background fade in
    bgFadeInTween:Play()
    
    -- Play fade-in animations
    fadeInTween:Play()
    shadowFadeInTween:Play()
    gradientEnableTween:Play()
    gradientRotateTween:Play()
    iconFadeInTween:Play() -- Fade in the icon
    
    -- Delayed watermark appearance
    task.delay(INTRO_DURATION * 0.25, function()
        watermarkFadeInTween:Play()
    end)
    
    -- Wait for fade in to complete
    fadeInTween.Completed:Wait()
    
    -- Play hold animation
    holdTween:Play()
    holdTween.Completed:Wait()
    
    -- Play fade-out animations
    fadeOutTween:Play()
    shadowFadeOutTween:Play()
    watermarkFadeOutTween:Play()
    blurOutTween:Play()
    bgFadeOutTween:Play()
    gradientDisableTween:Play()
    iconFadeOutTween:Play() -- Fade out the icon
    
    -- Wait for animations to complete
    fadeOutTween.Completed:Wait()
    
    -- Clean up
    particleConnection:Disconnect()
    screenGui:Destroy()
    blurEffect:Destroy()
    colorCorrection:Destroy()
    dofEffect:Destroy()
end

-- Play the intro animation with error handling
local success, err = pcall(playIntroAnimation)
if not success then
    warn("Intro animation failed: " .. err)
    -- Clean up in case of failure
    if screenGui then screenGui:Destroy() end
    if blurEffect then blurEffect:Destroy() end
    if colorCorrection then colorCorrection:Destroy() end
    if dofEffect then dofEffect:Destroy() end
end
task.wait()

-- Place this in a LocalScript (for client-side freezing) or a regular Script (for server-side freezing)
-- Recommended location: StarterPlayerScripts or StarterGui for LocalScript

local freezeDuration = 0.5 -- seconds to freeze the game

local function freezeGame(duration)
    local startTime = os.clock()
    
    while os.clock() - startTime < duration do
        -- This loop will block all other Lua execution
    end
    
    print("loaded all commands in " .. duration .. " seconds")
end

-- Call the freeze function
freezeGame(freezeDuration)

-- Call the freeze function
freezeGame(freezeDuration)

task.wait()
notify("TerminalCmd:System", "[🛠️] all Cmds Are Loaded\n[🗒️] type in [cmds] to continue\n[💬] Script Made By @hmmm5650", 3)
task.wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
-- PrintLoaderModule.lua
-- A loading GUI that uses the console as the loading GUI for other scripts
print("✅ - Working: It's Good and working) ☑️ - loads external: Loads scripts inside scripts) 🔄 - Debug: checks if working and debugs it ) ❌ - failed: doesn't work or something went wrong) ⚠️ - warn: warns the player")
print("\n")

pcall(function()
local DEBUG = true
local DEBUG_CHANCE = 0.099

local SoundId = "rbxassetid://5515669992" -- Replace with your preferred sound ID
local volume = 2 -- Adjust the volume (0 to 10)
local notifications = {} -- Stores active notifications

local function debugPrint(message)
    if DEBUG and math.random() < DEBUG_CHANCE then
        print(message)
    end
end

print(" ၊၊||၊|။||||။‌‌‌‌‌၊|• TerminalCmd •၊၊||၊|။||||။‌‌‌‌‌၊|")
task.wait()

local UIS = game:GetService("UserInputService")

debugPrint("🔄 [Debug] Initializing openConsole function")
local function openConsole()
    debugPrint("🔄 [Debug] Opening DevConsole")
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", true)
end

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.P then
        openConsole()
    end
end)

 -- the loadstring is full of resources for it to run the script
pcall(function()
    debugPrint("🔄 [Debug] Running pcall block")
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PrintLoadRes/refs/heads/main/PrintLoadRes", true))()
    playSound("rbxassetid://")
    task.wait()
    playSound("rbxassetid://")
    task.wait()
    playSound("rbxassetid://")
    task.wait(0.50)
end)

print("-------------------------------------------------")
print("\n")

local userInputService = game:GetService("UserInputService")

if userInputService.TouchEnabled then
    print("📱 [Scanning] PlayerUserMobile")
else
    print("🖥️ [Scanning] PlayerUserPersonalComputer")
end
task.wait()
print("madebyhmmm5650")
task.wait()
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Credit-obfuscated-lol/refs/heads/main/OBFCredit", true))()
end)
task.wait()

debugPrint("🔄 [Debug] Initializing closeConsole function")
local function closeConsole()
    debugPrint("🔄 [Debug] Closing DevConsole")
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", false)
end

closeConsole()

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.O then
        closeConsole()
    end
end)

local success, err = pcall(function()
    pcall(function()
    print("Script started")


    -- Player
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    -- Function to destroy the UI
    local function destroyUI()
        local existingUI = playerGui:FindFirstChild("TerminalUI")
        if existingUI then
            existingUI:Destroy()
        end
    end

    -- Function to create the UI
    local function createUI()
        -- Clear existing UI if it exists
        destroyUI()

        -- Create ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TerminalUI"
        screenGui.ResetOnSpawn = true
        screenGui.Parent = playerGui
        print("ScreenGui created and parented")

        -- Create a Sound instance
        local typingSound = Instance.new("Sound")
        typingSound.SoundId = "rbxassetid://177266782" -- Replace with your sound ID
        typingSound.Volume = 0.1 -- Adjust volume as needed
        typingSound.Parent = screenGui

        -- Create Main Frame
        local mainFrame = Instance.new("Frame")
        mainFrame.Name = "MainFrame"
        mainFrame.Size = UDim2.new(0.4, 0, 0.4, 0) -- Smaller size
        mainFrame.Position = UDim2.new(0.3, 0, 0.3, 0) -- Centered
        mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        mainFrame.Transparency = 0.1
        mainFrame.BorderSizePixel = 0
        mainFrame.Active = true
        mainFrame.Parent = screenGui

        -- Add Squircle Corner to Main Frame
        local mainFrameCorner = Instance.new("UICorner")
        mainFrameCorner.CornerRadius = UDim.new(0.1, 0) -- Adjust for squircle effect
        mainFrameCorner.Parent = mainFrame

        -- Add Green Pulsing Outline to Main Frame
        local mainFrameStroke = Instance.new("UIStroke")
        mainFrameStroke.Color = Color3.fromRGB(27, 42, 53)
        mainFrameStroke.Thickness = 3
        mainFrameStroke.Transparency = 0.3
        mainFrameStroke.Parent = mainFrame

        -- Animate the Outline
        local pulseTween = TweenService:Create(
            mainFrameStroke,
            TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            { Transparency = 0.8 }
        )
        pulseTween:Play()

        print("MainFrame created and parented")

        -- Create Output Scrolling Frame
        local outputFrame = Instance.new("ScrollingFrame")
        outputFrame.Name = "OutputFrame"
        outputFrame.Size = UDim2.new(1, -10, 0.85, -10) -- Adjusted height to make room for the input box
        outputFrame.Position = UDim2.new(0, 5, 0, 5)
        outputFrame.BackgroundTransparency = 1
        outputFrame.ScrollBarThickness = 8
        outputFrame.Parent = mainFrame
        print("OutputFrame created and parented")

        -- Create Output TextLabel
        local outputText = Instance.new("TextLabel")
        outputText.Name = "OutputText"
        outputText.Size = UDim2.new(1, 0, 1, 0)
        outputText.Position = UDim2.new(0, 0, 0, 0)
        outputText.BackgroundTransparency = 1
        outputText.TextColor3 = Color3.fromRGB(204, 204, 204)
        outputText.TextXAlignment = Enum.TextXAlignment.Left
        outputText.TextYAlignment = Enum.TextYAlignment.Top
        outputText.TextWrapped = true
        outputText.Text = "Windows Terminal [Version 10.0.22000.194]\n(c) Microsoft Corporation. All rights reserved.\n\n"
        outputText.Font = Enum.Font.Code
        outputText.TextSize = 12
        outputText.Parent = outputFrame
        print("OutputText created and parented")

        -- Create Input Box Frame (For Blue Outline)
        local inputBoxFrame = Instance.new("Frame")
        inputBoxFrame.Name = "InputBoxFrame"
        inputBoxFrame.Size = UDim2.new(0.5, 0, 0.09, 0)
        inputBoxFrame.Position = UDim2.new(0.5, -inputBoxFrame.Size.X.Offset / 2, 1.1, -inputBoxFrame.Size.Y.Offset / 2)
        inputBoxFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        inputBoxFrame.Parent = mainFrame

        -- Add Circular Corner to Input Box Frame
        local inputBoxFrameCorner = Instance.new("UICorner")
        inputBoxFrameCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
        inputBoxFrameCorner.Parent = inputBoxFrame

        -- Add Blue Pulsing Outline to Input Box Frame
        local inputBoxFrameStroke = Instance.new("UIStroke")
        inputBoxFrameStroke.Color = Color3.fromRGB(27, 42, 53)
        inputBoxFrameStroke.Thickness = 2
        inputBoxFrameStroke.Transparency = 0.3
        inputBoxFrameStroke.Parent = inputBoxFrame

        -- Animate the Blue Outline
        local inputBoxPulseTween = TweenService:Create(
            inputBoxFrameStroke,
            TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            { Transparency = 0.8 }
        )
        inputBoxPulseTween:Play()

        -- Create Input TextBox inside the Frame
        local inputBox = Instance.new("TextBox")
        inputBox.Name = "InputBox"
        inputBox.Size = UDim2.new(1, -5, 1, -5) -- Fit inside the frame with a margin
        inputBox.Position = UDim2.new(0, 2, 0, 2)
        inputBox.BackgroundTransparency = 1 -- Make it transparent so only frame is visible
        inputBox.TextColor3 = Color3.fromRGB(200, 200, 200)
        inputBox.PlaceholderText = "Type a command..."
        inputBox.Font = Enum.Font.Code
        inputBox.TextSize = 12
        inputBox.ClearTextOnFocus = false
        inputBox.Parent = inputBoxFrame

        -- Play sound when typing in the input box
        inputBox:GetPropertyChangedSignal("Text"):Connect(function()
            if inputBox:IsFocused() and inputBox.Text ~= "" then
                typingSound:Play()
            end
        end)

        -- Add Circular Corner to Input Box
        local inputBoxCorner = Instance.new("UICorner")
        inputBoxCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
        inputBoxCorner.Parent = inputBox

        print("InputBox created and parented")

-- Create Minimize Button
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Text = "_"
minimizeButton.Size = UDim2.new(0, 20, 0, 20)
minimizeButton.Position = UDim2.new(1, -25, 0, 5)
minimizeButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
minimizeButton.BackgroundTransparency = 0.3
minimizeButton.TextColor3 = Color3.fromRGB(155, 155, 155)
minimizeButton.Parent = mainFrame

-- Make Minimize Button Circular
local minimizeButtonCorner = Instance.new("UICorner")
minimizeButtonCorner.CornerRadius = UDim.new(1, 0) -- Fully circular
minimizeButtonCorner.Parent = minimizeButton

-- Create Collapsed Label
local collapsedLabel = Instance.new("TextLabel")
collapsedLabel.Name = "CollapsedLabel"
collapsedLabel.Text = "TCmd (3.1)" -- VZ
collapsedLabel.Size = UDim2.new(1, 0, 1, 0)
collapsedLabel.Position = UDim2.new(0, -20, -0.02, 0)
collapsedLabel.BackgroundTransparency = 1
collapsedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
collapsedLabel.TextXAlignment = Enum.TextXAlignment.Center
collapsedLabel.TextYAlignment = Enum.TextYAlignment.Center
collapsedLabel.Font = Enum.Font.Code
collapsedLabel.TextSize = 19
collapsedLabel.Visible = false
collapsedLabel.Parent = mainFrame

-- Button hover animations
minimizeButton.MouseEnter:Connect(function()
    local tween = game:GetService("TweenService"):Create(
        minimizeButton,
        TweenInfo.new(0.2),
        {BackgroundTransparency = 0, TextColor3 = Color3.fromRGB(255, 255, 255)}
    )
    tween:Play()
end)

minimizeButton.MouseLeave:Connect(function()
    local tween = game:GetService("TweenService"):Create(
        minimizeButton,
        TweenInfo.new(0.2),
        {BackgroundTransparency = 0.3, TextColor3 = Color3.fromRGB(155, 155, 155)}
    )
    tween:Play()
end)

-- Variable to track minimized state
local isMinimized = false

-- Function to handle minimize button click with animations
minimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    
    local tweenService = game:GetService("TweenService")
    
    if isMinimized then
        -- Animate to minimized state
        local frameTween = tweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.2, 0, 0.1, 0)}
        )
        frameTween:Play()
        
        -- Fade out elements
        outputFrame.Visible = false
        inputBox.Visible = false
        inputBoxFrame.Visible = false
        
        -- Fade in collapsed label
        collapsedLabel.Visible = true
        collapsedLabel.TextTransparency = 1
        local labelTween = tweenService:Create(
            collapsedLabel,
            TweenInfo.new(0.3),
            {TextTransparency = 0}
        )
        labelTween:Play()
        
        -- Rotate button arrow
        local buttonTween = tweenService:Create(
            minimizeButton,
            TweenInfo.new(0.3),
            {Rotation = 180}
        )
        buttonTween:Play()
    else
        -- Animate to expanded state
        local frameTween = tweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.4, 0, 0.4, 0)}
        )
        frameTween:Play()
        
        -- Fade out collapsed label
        local labelTween = tweenService:Create(
            collapsedLabel,
            TweenInfo.new(0.2),
            {TextTransparency = 1}
        )
        labelTween:Play()
        
        -- After label fades out, show other elements
        labelTween.Completed:Connect(function()
            collapsedLabel.Visible = false
            outputFrame.Visible = true
            inputBox.Visible = true
            inputBoxFrame.Visible = true
        end)
        
        -- Rotate button arrow back
        local buttonTween = tweenService:Create(
            minimizeButton,
            TweenInfo.new(0.3),
            {Rotation = 0}
        )
        buttonTween:Play()
    end
end)

print("MinimizeButton and CollapsedLabel created and parented by hm5650")

    -- Table to store original transparency values
    local originalTransparency = {}

    local player = game.Players.LocalPlayer  
    local character = player.Character or player.CharacterAdded:Wait()  

    function SitPlayer()  
         if character and character:FindFirstChild("Humanoid") then  
            character.Humanoid.Sit = true  
         end  
    end  

local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local speeds = 1 -- Default speed for both flying and TP walk
local nowe = false
local tpwalking = false

-- TP Walk Functionality
local function TpWalk()
    tpwalking = true

    while tpwalking and humanoid.Health > 0 do
        game:GetService("RunService").Heartbeat:Wait()

        if humanoid.MoveDirection.Magnitude > 0 then
            -- Calculate movement direction and apply speed
            local moveDirection = humanoid.MoveDirection.Unit
            local velocity = moveDirection * speeds * 50 -- Adjust speed multiplier here
            rootPart.CFrame = rootPart.CFrame + velocity * game:GetService("RunService").Heartbeat:Wait()
        end
    end
end

local function StartTpWalk()
    if not tpwalking then
        tpwalking = true
        spawn(TpWalk)
    end
end

local function StopTpWalk()
    tpwalking = false
end

local function SetTpWalkSpeed(newSpeed)
    speeds = newSpeed
    print("TP Walk speed set to:", speeds)
end

-- GravityInverter
local player = game.Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Physics Settings
local GRAVITY_MULTIPLIER = 1.5 -- Visible but not too fast
local INITIAL_BOOST = 10 -- Gentle push to start
local MAX_SPEED = 20 -- Maximum upward speed
local SIMULATION_RADIUS = 5000 -- Large area of effect

-- System Variables
local invertedParts = {}
local connection = nil
local heartbeatConnection = nil

local function cleanUpForces(part)
    for _, child in ipairs(part:GetChildren()) do
        if child:IsA("BodyForce") or child:IsA("BodyVelocity") then
            child:Destroy()
        end
    end
end

local function applyUpwardForce()
    -- Ensure we can affect distant parts
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    sethiddenproperty(player, "MaxSimulationRadius", SIMULATION_RADIUS)
    
    for part, data in pairs(invertedParts) do
        if part and part.Parent then
            -- Calculate upward force based on part's mass
            local force = part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER
            
            -- Apply force while respecting max speed
            if part.Velocity.Y < MAX_SPEED then
                part:ApplyImpulse(Vector3.new(0, force * 0.016, 0)) -- 0.016 ≈ 1/60 for frame independence
            end
            
            -- Ensure parts don't get stuck
            if part.Velocity.Y < 5 then
                part.Velocity = Vector3.new(0, 5, 0)
            end
        else
            invertedParts[part] = nil
        end
    end
end

local function invertGravity(part)
    if part:IsA("BasePart") and not part.Anchored and not part:IsDescendantOf(player.Character) then
        if not invertedParts[part] then
            -- Store original state
            invertedParts[part] = {
                CanCollide = part.CanCollide,
                CustomPhysicalProperties = part.CustomPhysicalProperties
            }
            
            -- Clean existing forces
            cleanUpForces(part)
            
            -- Configure part physics
            part.CanCollide = false
            part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            
            -- Initial gentle push
            part.Velocity = Vector3.new(0, INITIAL_BOOST, 0)
            
            -- Add permanent upward force
            local bodyForce = Instance.new("BodyForce")
            bodyForce.Force = Vector3.new(0, part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER, 0)
            bodyForce.Parent = part
            invertedParts[part].bodyForce = bodyForce
        end
    end
end

local function restoreGravity(part)
    if invertedParts[part] then
        cleanUpForces(part)
        part.CanCollide = invertedParts[part].CanCollide
        part.CustomPhysicalProperties = invertedParts[part].CustomPhysicalProperties
        part.Velocity = Vector3.new(0, 0, 0)
        invertedParts[part] = nil
    end
end

function GravOn()
    -- Set physics range
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    
    -- Process existing parts
    for _, part in ipairs(Workspace:GetDescendants()) do
        invertGravity(part)
    end
    
    -- Continuous force application
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    heartbeatConnection = RunService.Heartbeat:Connect(applyUpwardForce)
    
    -- Detect new parts
    if connection then connection:Disconnect() end
    connection = Workspace.DescendantAdded:Connect(invertGravity)
end

function GravOff()
    -- Clean up
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    for part in pairs(invertedParts) do
        if part.Parent then
            restoreGravity(part)
        end
    end
    
    invertedParts = {}
    if connection then
        connection:Disconnect()
        connection = nil
    end
end

-- invis variable
local offset = 1100
local invisible = false
local grips = {}
local heldTool
local gripChanged
local handle
local weld
local originalAnimateState -- To store whether Animate was enabled originally

function setDisplayDistance(distance)
    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChildWhichIsA("Humanoid") then
            player.Character:FindFirstChildWhichIsA("Humanoid").NameDisplayDistance = distance
            player.Character:FindFirstChildWhichIsA("Humanoid").HealthDisplayDistance = distance
        end
    end
end

function invis()
    if not invisible then
        invisible = true
        
        -- Store original animate state
        originalAnimateState = game.Players.LocalPlayer.Character.Animate.Enabled
        
        -- Disable all animations
        game.Players.LocalPlayer.Character.Animate.Enabled = false
        for _, track in pairs(game.Players.LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
        
        -- Handle invisibility setup
        if handle then handle:Destroy() end
        if weld then weld:Destroy() end
        
        handle = Instance.new("Part", workspace)
        handle.Name = "Handle"
        handle.Transparency = 1
        handle.CanCollide = false
        handle.Size = Vector3.new(2, 1, 1)
        
        weld = Instance.new("Weld", handle)
        weld.Part0 = handle
        weld.Part1 = game.Players.LocalPlayer.Character.HumanoidRootPart
        weld.C0 = CFrame.new(0, offset - 1.5, 0)
        
        setDisplayDistance(offset + 100)
        workspace.CurrentCamera.CameraSubject = handle
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, offset, 0)
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = offset
        game.Players.LocalPlayer.Character.Humanoid:ChangeState(11)
        
        -- Store original tool grips
        for _, child in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
            if child:IsA("Tool") then
                grips[child] = child.Grip
            end
        end
    end
end

function vis()
    if invisible then
        invisible = false
        
        -- Clean up invisibility parts
        if handle then handle:Destroy() end
        if weld then weld:Destroy() end
        
        -- Restore animations to original state
        game.Players.LocalPlayer.Character.Animate.Enabled = originalAnimateState or true
        
        -- Return tools to normal state
        for _, child in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
            if child:IsA("Tool") then
                child.Parent = game.Players.LocalPlayer.Backpack
            end
        end
        
        for tool, grip in pairs(grips) do
            if tool then
                tool.Grip = grip
            end
        end
        
        heldTool = nil
        setDisplayDistance(100)
        workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, -offset, 0)
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = 0
        
        -- Make the character jump
        game.Players.LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

-- Tool handling for when tools are equipped while invisible
game.Players.LocalPlayer.Character.ChildAdded:Connect(function(child)
    wait()
    if invisible and child:IsA("Tool") and child ~= heldTool then
        heldTool = child
        local lastGrip = heldTool.Grip
        if not grips[heldTool] then
            grips[heldTool] = lastGrip
        end
        
        -- Ensure animations stay disabled for tools
        game.Players.LocalPlayer.Character.Animate.Enabled = false
        for _, track in pairs(game.Players.LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
        
        heldTool.Grip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
        heldTool.Parent = game.Players.LocalPlayer.Backpack
        heldTool.Parent = game.Players.LocalPlayer.Character
        
        if gripChanged then
            gripChanged:Disconnect()
        end
        
        gripChanged = heldTool:GetPropertyChangedSignal("Grip"):Connect(function()
            wait()
            if not invisible then
                gripChanged:Disconnect()
            end
            if heldTool.Grip ~= lastGrip then
                lastGrip = heldTool.Grip * (CFrame.new(0, offset - 1.5, 1.5) * CFrame.Angles(math.rad(-90), 0, 0))
                heldTool.Grip = lastGrip
                heldTool.Parent = game.Players.LocalPlayer.Backpack
                heldTool.Parent = game.Players.LocalPlayer.Character
            end
        end)
    end
end)

-- AutoUse Func
local AutoS = {
    on = function()
        _G.AutoSwing = true
        while _G.AutoSwing do
            pcall(function()
                game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Tool"):Activate()
            end)
            wait(0.1)
        end
    end,
    
    off = function()
        _G.AutoSwing = false
    end
}

function CreateTptool()
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local backpack = localPlayer.Backpack
local mouse = localPlayer:GetMouse()

local function isAlive(Player, headCheck)
    local Player = Player or localPlayer
    if Player and Player.Character and ((Player.Character:FindFirstChildOfClass("Humanoid")) and (Player.Character:FindFirstChild("HumanoidRootPart")) and (headCheck and Player.Character:FindFirstChild("Head") or not headCheck)) then
        return true
    else
        return false
    end
end

local tool = Instance.new("Tool")
tool.Name = "TPTool"
tool.Parent = backpack
tool.RequiresHandle = false
tool.Activated:Connect(function()
	if isAlive() then
		localPlayer.Character.HumanoidRootPart.CFrame = mouse.Hit + Vector3.new(0, 3, 0)
	end
end)

end

-- Godmode variable
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Config
local MAX_HEALTH = math.huge * 2
local HOTKEY = Enum.KeyCode.Z
local PROTECT_FROM_FALL = true
local PROTECT_FROM_INSTA_KILL = true

-- State
local godModeEnabled = false
local connections = {}
local originalWalkSpeed = 16

-- Function: Setup protection
local function setupCharacterProtection(character)
	if not character then return end
	local humanoid = character:WaitForChild("Humanoid", 5)
	if not humanoid then return end

	originalWalkSpeed = humanoid.WalkSpeed
	humanoid.MaxHealth = MAX_HEALTH
	humanoid.Health = MAX_HEALTH

	table.insert(connections, humanoid:GetPropertyChangedSignal("Health"):Connect(function()
		if godModeEnabled and humanoid.Health < MAX_HEALTH then
			humanoid.Health = MAX_HEALTH
		end
	end))

	table.insert(connections, humanoid.Died:Connect(function()
		if godModeEnabled then
			task.wait(1)
			character:BreakJoints()
			task.wait(1)
			local newChar = Players.LocalPlayer:LoadCharacter()
			setupCharacterProtection(newChar)
		end
	end))

	if PROTECT_FROM_FALL then
		table.insert(connections, humanoid.StateChanged:Connect(function(_, newState)
			if godModeEnabled and newState == Enum.HumanoidStateType.FallingDown then
				humanoid:ChangeState(Enum.HumanoidStateType.Running)
			end
		end))
	end
end

-- Function: Remove all protection
local function clearProtection()
	for _, conn in pairs(connections) do
		conn:Disconnect()
	end
	connections = {}

	local char = Players.LocalPlayer.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.MaxHealth = 100
			humanoid.Health = math.min(humanoid.Health, 100)
			humanoid.WalkSpeed = originalWalkSpeed
		end
	end
end

-- Public API: Toggle Functions
function GodModeOn()
	godModeEnabled = true
	setupCharacterProtection(Players.LocalPlayer.Character)
	updateButton()
end

function GodModeOff()
	godModeEnabled = false
	clearProtection()
	updateButton()
end

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Config
local MAX_HEALTH = math.huge * 2
local HOTKEY = Enum.KeyCode.Z
local PROTECT_FROM_FALL = true
local PROTECT_FROM_INSTA_KILL = true

-- State
local godModeEnabled = false
local connections = {}
local originalWalkSpeed = 16

-- Function: Setup protection
local function setupCharacterProtection(character)
	if not character then return end
	local humanoid = character:WaitForChild("Humanoid", 5)
	if not humanoid then return end

	originalWalkSpeed = humanoid.WalkSpeed
	humanoid.MaxHealth = MAX_HEALTH
	humanoid.Health = MAX_HEALTH

	table.insert(connections, humanoid:GetPropertyChangedSignal("Health"):Connect(function()
		if godModeEnabled and humanoid.Health < MAX_HEALTH then
			humanoid.Health = MAX_HEALTH
		end
	end))

	table.insert(connections, humanoid.Died:Connect(function()
		if godModeEnabled then
			task.wait(1)
			character:BreakJoints()
			task.wait(1)
			local newChar = Players.LocalPlayer:LoadCharacter()
			setupCharacterProtection(newChar)
		end
	end))

	if PROTECT_FROM_FALL then
		table.insert(connections, humanoid.StateChanged:Connect(function(_, newState)
			if godModeEnabled and newState == Enum.HumanoidStateType.FallingDown then
				humanoid:ChangeState(Enum.HumanoidStateType.Running)
			end
		end))
	end
end

-- Function: Remove all protection
local function clearProtection()
	for _, conn in pairs(connections) do
		conn:Disconnect()
	end
	connections = {}

	local char = Players.LocalPlayer.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.MaxHealth = 100
			humanoid.Health = math.min(humanoid.Health, 100)
			humanoid.WalkSpeed = originalWalkSpeed
		end
	end
end

-- Public API: Toggle Functions
function GodModeOn()
	godModeEnabled = true
	setupCharacterProtection(Players.LocalPlayer.Character)
	updateButton()
end

function GodModeOff()
	godModeEnabled = false
	clearProtection()
	updateButton()
end

-- rj func
function Rj()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    -- Rejoin the same place and server
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end

-- VoidProtection Variable
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local voidYLevel = -100 -- Adjust based on your game's void height
local protectionEnabled = false
local bounceForce = 10000   -- Initial upward force
local maxBounceForce = 999e999
local platformCheckRaycast = 5 -- Raycast distance to check for platforms below
local inVoid = false -- Track if player is in void

local function checkPlatformBelow()
    if not humanoidRootPart then return false end
    
    local rayOrigin = humanoidRootPart.Position
    local rayDirection = Vector3.new(0, -platformCheckRaycast, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult and raycastResult.Instance
end

local function applyBounce()
    if not humanoidRootPart or not protectionEnabled then return end
    
    -- Apply upward velocity (like a bounce)
    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, bounceForce, 0)
    
    -- Increase bounce force for next time (capped at maxBounceForce)
    bounceForce = math.min(bounceForce + 100, maxBounceForce)
    
    print("Bouncing with force:", bounceForce) -- Debug output
end

local function checkVoidPosition()
    while protectionEnabled and humanoidRootPart do
        local isInVoidNow = humanoidRootPart.Position.Y < voidYLevel
        
        -- Check for platform below regardless of void state
        local onPlatform = checkPlatformBelow()
        
        if onPlatform then
            -- Player landed on something, reset bounce force
            bounceForce = 100
            inVoid = false
        elseif isInVoidNow then
            -- Player is in void, apply bounce
            if not inVoid then
                -- First time entering void
                bounceForce = 100
                inVoid = true
            else
                -- Continuous bouncing in void
                applyBounce()
            end
        else
            inVoid = false
        end
        
        task.wait(0.1) -- More efficient than wait()
    end
end

function VoidProtectionOn()
    if not protectionEnabled then
        protectionEnabled = true
        inVoid = false
        bounceForce = 100 -- Reset force when turning on
        checkVoidPosition()
        print("Void Protection (Bounce Mode): ON")
    end
end

function VoidProtectionOff()
    protectionEnabled = false
    print("Void Protection: OFF")
end

-- Antifling Variable
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local antiflingConnection

afon = {}

function afon.on(speaker)
    if antiflingConnection then
        antiflingConnection:Disconnect()
        antiflingConnection = nil
    end
    antiflingConnection = RunService.Stepped:Connect(function()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= speaker and player.Character then
                for _, v in pairs(player.Character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanCollide = false
                    end
                end
            end
        end
    end)
end

function afon.off()
    if antiflingConnection then
        antiflingConnection:Disconnect()
        antiflingConnection = nil
    end
end

-- babify Variable
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")

-- Store original values
local originalHipHeight = Humanoid.HipHeight
local originalGravity = workspace.Gravity
local noclipConnection = nil

-- Enhanced noclip that works with extreme gravity
local function enableNoclip()
    if noclipConnection then return end
    
    -- First disable collisions on all parts
    for _, part in ipairs(Character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            part.Velocity = Vector3.new() -- Stop any movement
        end
    end
    
    -- Maintain noclip state
    noclipConnection = RunService.Stepped:Connect(function()
        for _, part in ipairs(Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                part.AssemblyLinearVelocity = Vector3.new() -- Prevent any drifting
            end
        end
    end)
end

local function disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    
    -- Restore collisions
    for _, part in ipairs(Character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

-- Main shrinking function with no limits
function smallhead(offset)
    offset = offset or 5 -- Default offset
    
    -- Set extreme gravity only when smallhead is called
    originalGravity = workspace.Gravity
    workspace.Gravity = 999e999
    
    -- Enable noclip before making changes
    enableNoclip()
    
    -- Apply the head shrink (no upper limit)
    originalHipHeight = Humanoid.HipHeight
    Humanoid.HipHeight = originalHipHeight - offset
    
    -- Force physics update
    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    task.wait(0.1)
    Humanoid:ChangeState(Enum.HumanoidStateType.Running)
end

function unsmallhead()
    -- Restore original values
    Humanoid.HipHeight = originalHipHeight
    workspace.Gravity = originalGravity
    disableNoclip()
end

-- Automatic reset on respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    Humanoid = char:WaitForChild("Humanoid")
    RootPart = char:WaitForChild("HumanoidRootPart")
    originalHipHeight = Humanoid.HipHeight
    unsmallhead() -- Ensures clean state on respawn (restores gravity too)
end)

-- seizure variable
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- Debug prints
local function debugPrint(message)
    print("[DEBUG] " .. message)
end

-- Variables
local Character, Head, Humanoid
local FastAnimationsEnabled = false
local AnchoringEnabled = false
local AnchorLoopThread, FastAnimThread
local ActiveThreads = {}

-- Initialize character
local function InitializeCharacter()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    Head = Character:WaitForChild("Head")
    Humanoid = Character:WaitForChild("Humanoid")
    debugPrint("Character initialized!")
end

-- Fast animations (15x speed)
local function FastAnimationsLoop()
    debugPrint("FastAnimationsLoop started")
    while true do
        if not FastAnimationsEnabled then break end
        if not Character then 
            task.wait(0.1)
            continue 
        end
        
        local animController = Character:FindFirstChildOfClass("Humanoid") or Character:FindFirstChildOfClass("AnimationController")
        if not animController then 
            task.wait(0.1)
            continue 
        end
        
        for _, track in pairs(animController:GetPlayingAnimationTracks()) do
            track:AdjustSpeed(15)
        end
        task.wait(0.1)
    end
    debugPrint("FastAnimationsLoop ended")
end

-- Head Anchor/Unanchor loop with sit/stand
local function AnchorHeadLoop()
    debugPrint("AnchorHeadLoop started")
    while true do
        if not AnchoringEnabled then break end
        if not Head or not Humanoid then 
            task.wait(0.1)
            continue 
        end
        
        -- Toggle anchor and sit state
        Head.Anchored = not Head.Anchored
        if Head.Anchored then
            Humanoid.Sit = false -- Stand when anchored
        else
            Humanoid.Sit = true -- Sit when unanchored
        end
        
        debugPrint("Head Anchored: " .. tostring(Head.Anchored) .. " | Sitting: " .. tostring(Humanoid.Sit))
        task.wait(0.1)
    end
    debugPrint("AnchorHeadLoop ended")
end

-- Start effects
function Fun()
    if not Character then InitializeCharacter() end
    
    -- Cancel any existing threads first
    NoFun()
    
    FastAnimationsEnabled = true
    AnchoringEnabled = true
    
    FastAnimThread = task.spawn(FastAnimationsLoop)
    AnchorLoopThread = task.spawn(AnchorHeadLoop)
    
    -- Track active threads
    ActiveThreads.FastAnim = FastAnimThread
    ActiveThreads.Anchor = AnchorLoopThread
    
    debugPrint("Started Fun() - Fast Animations + Head Anchor/Sit Loop")
end

-- Stop effects and reset
function NoFun()
    debugPrint("NoFun() called")
    FastAnimationsEnabled = false
    AnchoringEnabled = false
    
    -- Reset animations
    if Character then
        local animController = Character:FindFirstChildOfClass("Humanoid") or Character:FindFirstChildOfClass("AnimationController")
        if animController then
            for _, track in pairs(animController:GetPlayingAnimationTracks()) do
                track:AdjustSpeed(1)
            end
        end
    end
    
    -- Reset Head and sitting
    if Head then Head.Anchored = false end
    if Humanoid then Humanoid.Sit = false end
    
    -- Cancel threads with additional safety
    for name, thread in pairs(ActiveThreads) do
        if thread and task.getStatus(thread) == "running" then
            task.cancel(thread)
            debugPrint("Cancelled thread: " .. name)
        end
    end
    
    ActiveThreads = {}
    FastAnimThread = nil
    AnchorLoopThread = nil
    
    debugPrint("Stopped Fun() - Reset everything")
end

-- Handle respawns
LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    InitializeCharacter()
    
    if FastAnimationsEnabled or AnchoringEnabled then
        -- Only restart if we're supposed to be running
        NoFun() -- Clean up any existing state
        if FastAnimationsEnabled or AnchoringEnabled then
            Fun() -- Restart with new character
        end
    end
end)

-- Initialize if already in-game
if LocalPlayer.Character then
    InitializeCharacter()
end

-- Drop All Tools Function (DAT)
local function DAT()
    -- Get the player's character and backpack
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player:FindFirstChild("Backpack")
    
    if not backpack then
        warn("Backpack not found!")
        return
    end
    
    -- Get all tools in the backpack
    local tools = {}
    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") then
            table.insert(tools, item)
        end
    end
    
    -- Drop each tool
    for _, tool in ipairs(tools) do
        -- Equip the tool first (necessary to drop it)
        tool.Parent = character
        task.wait(0.1) -- Small delay to ensure tool is equipped
        
        -- Drop the tool
        tool.Parent = workspace
        tool:FindFirstChild("Handle").Anchored = false -- Ensure it can fall
    end
    
    print("Dropped " .. #tools .. " tools")
end

-- AAT (Activate All Tools) Script
local function AAT()
    -- Get the local player
    local player = game:GetService("Players").LocalPlayer
    if not player then return end
    
    -- Get the player's backpack and character
    local backpack = player:FindFirstChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Wait for tools to load if needed
    if not backpack then
        backpack = player:WaitForChild("Backpack")
    end
    
    -- Function to activate a tool
    local function activateTool(tool)
        if tool:IsA("Tool") then
            -- Equip the tool if it's in the backpack
            if tool.Parent == backpack then
                tool.Parent = character
                wait(0.1) -- Small delay for equip animation
            end
            
            -- Activate the tool
            local handle = tool:FindFirstChild("Handle")
            if handle then
                local remote = handle:FindFirstChildOfClass("RemoteEvent") or 
                              tool:FindFirstChildOfClass("RemoteEvent") or
                              handle:FindFirstChildOfClass("RemoteFunction") or
                              tool:FindFirstChildOfClass("RemoteFunction")
                
                if remote then
                    -- Try to activate with the remote
                    pcall(function()
                        if remote:IsA("RemoteEvent") then
                            remote:FireServer("activate")
                        elseif remote:IsA("RemoteFunction") then
                            remote:InvokeServer("activate")
                        end
                    end)
                else
                    -- Try to use the tool's built-in activation
                    pcall(function()
                        tool:Activate()
                    end)
                end
            end
        end
    end
    
    -- Activate all tools in the backpack
    for _, tool in ipairs(backpack:GetChildren()) do
        activateTool(tool)
    end
    
    -- Activate all tools currently equipped
    for _, tool in ipairs(character:GetChildren()) do
        activateTool(tool)
    end
    
    print("AAT: Attempted to activate all tools.")
end

-- Create the AAT function in the global namespace
getgenv().AAT = AAT

-- Combined ESP Script
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- NameESP Configuration
local NameESPConfig = {
    Enabled = false,
    TeamCheck = true,
    MaxDistance = 1000,
    Color = Color3.new(1, 1, 1),
    TeamColor = Color3.new(0, 1, 0),
    EnemyColor = Color3.new(1, 0, 0)
}

-- BoxESP Configuration
local BoxESPConfig = {
    Enabled = false,
    TeamCheck = true
}

-- Variables
local namePlayerAddedConnection
local nameRenderSteppedConnection
local nameCharacterConnections = {} -- Track character connections for cleanup
local boxEspBoxes = {}

-- NameESP Functions
local function CreateEspLabel(character)
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not humanoidRootPart then return end
    
    -- Remove existing label if it exists
    local existingLabel = humanoidRootPart:FindFirstChild("EspLabel")
    if existingLabel then
        existingLabel:Destroy()
    end
    
    local espLabel = Instance.new("BillboardGui")
    espLabel.Name = "EspLabel"
    espLabel.Parent = humanoidRootPart
    espLabel.Adornee = humanoidRootPart
    espLabel.AlwaysOnTop = true
    espLabel.LightInfluence = 0
    espLabel.Size = UDim2.new(0, 200, 0, 20)
    espLabel.StudsOffset = Vector3.new(0, 2, 0)
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "TextLabel"
    textLabel.Parent = espLabel
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = character.Name
    textLabel.Font = Enum.Font.SourceSansSemibold
    textLabel.TextSize = 18
    textLabel.TextColor3 = NameESPConfig.Color
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    
    return espLabel
end

local function UpdateEspLabel(character)
    local espLabel = character:FindFirstChild("EspLabel")
    if espLabel then
        local textLabel = espLabel:FindFirstChild("TextLabel")
        if textLabel then
            local player = Players:GetPlayerFromCharacter(character)
            if player then
                local localPlayer = Players.LocalPlayer
                local localCharacter = localPlayer.Character
                
                -- Distance check
                if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("HumanoidRootPart") then
                    local distance = (character.HumanoidRootPart.Position - localCharacter.HumanoidRootPart.Position).Magnitude
                    if distance > NameESPConfig.MaxDistance then
                        espLabel.Enabled = false
                        return
                    else
                        espLabel.Enabled = true
                    end
                end
                
                textLabel.Text = player.Name
                if NameESPConfig.TeamCheck then
                    if player.Team == localPlayer.Team then
                        textLabel.TextColor3 = NameESPConfig.TeamColor
                    else
                        textLabel.TextColor3 = NameESPConfig.EnemyColor
                    end
                else
                    textLabel.TextColor3 = NameESPConfig.Color
                end
            end
        end
    end
end

-- BoxESP Functions
local function createBox(player)
    local box = Instance.new("BoxHandleAdornment")
    box.Name = player.Name .. "_ESP"
    box.Adornee = nil -- Will be set when character exists
    box.AlwaysOnTop = true
    box.ZIndex = 10
    box.Size = Vector3.new(4, 6, 1)
    box.Transparency = 0.8
    box.Color3 = Color3.new(1, 1, 1)
    
    local outline = Instance.new("SelectionBox")
    outline.Name = player.Name .. "_Outline"
    outline.Adornee = nil
    outline.LineThickness = 0.05
    outline.Color3 = Color3.new(1, 1, 1)
    outline.Transparency = 0.3
    
    return box, outline
end

local function updateBoxColor(player, box, outline)
    if not player or not box or not outline then return end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return end
    
    if player.Team and localPlayer.Team then
        if player.Team ~= localPlayer.Team then
            box.Color3 = Color3.new(1, 0, 0)
            outline.Color3 = Color3.new(1, 0.3, 0.3)
        else
            box.Adornee = nil
            outline.Adornee = nil
            return
        end
    else
        box.Color3 = Color3.new(1, 1, 1)
        outline.Color3 = Color3.new(1, 1, 1)
    end
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        box.Adornee = player.Character.HumanoidRootPart
        outline.Adornee = player.Character.HumanoidRootPart
    end
end

-- Main Functions
function NameEspOn()
    if NameESPConfig.Enabled then return end
    NameESPConfig.Enabled = true
    
    -- Clear existing character connections
    for _, connection in pairs(nameCharacterConnections) do
        connection:Disconnect()
    end
    nameCharacterConnections = {}
    
    -- Create ESP for existing players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            if player.Character then
                CreateEspLabel(player.Character)
            end
            nameCharacterConnections[player] = player.CharacterAdded:Connect(function(character)
                CreateEspLabel(character)
            end)
        end
    end
    
    -- Connect to new players
    namePlayerAddedConnection = Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            nameCharacterConnections[player] = player.CharacterAdded:Connect(function(character)
                CreateEspLabel(character)
            end)
        end
    end)
    
    -- Update loop
    nameRenderSteppedConnection = RunService.RenderStepped:Connect(function()
        if NameESPConfig.Enabled then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character then
                    UpdateEspLabel(player.Character)
                end
            end
        end
    end)
end

function NameEspOff()
    if not NameESPConfig.Enabled then return end
    NameESPConfig.Enabled = false
    
    -- Disconnect all connections
    if namePlayerAddedConnection then
        namePlayerAddedConnection:Disconnect()
        namePlayerAddedConnection = nil
    end
    
    if nameRenderSteppedConnection then
        nameRenderSteppedConnection:Disconnect()
        nameRenderSteppedConnection = nil
    end
    
    for player, connection in pairs(nameCharacterConnections) do
        connection:Disconnect()
    end
    nameCharacterConnections = {}
    
    -- Remove all ESP labels
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            local espLabel = player.Character:FindFirstChild("EspLabel")
            if espLabel then
                espLabel:Destroy()
            end
        end
        
        -- Also check for any labels in workspace (in case they weren't parented to character)
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant.Name == "EspLabel" and descendant:IsA("BillboardGui") then
                descendant:Destroy()
            end
        end
    end
end

function BoxEspOn()
    if BoxESPConfig.Enabled then return end
    BoxESPConfig.Enabled = true
    
    -- Clear existing boxes
    for player, data in pairs(boxEspBoxes) do
        data.box:Destroy()
        data.outline:Destroy()
    end
    boxEspBoxes = {}
    
    -- Create boxes for all current players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            local box, outline = createBox(player)
            box.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or workspace
            outline.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or workspace
            boxEspBoxes[player] = {box = box, outline = outline}
            
            if player.Character then
                updateBoxColor(player, box, outline)
            end
            
            player.CharacterAdded:Connect(function(character)
                if BoxESPConfig.Enabled then
                    local rootPart = character:WaitForChild("HumanoidRootPart")
                    if rootPart then
                        box.Adornee = rootPart
                        box.Parent = rootPart
                        outline.Adornee = rootPart
                        outline.Parent = rootPart
                        updateBoxColor(player, box, outline)
                    end
                end
            end)
            
            player:GetPropertyChangedSignal("Team"):Connect(function()
                if BoxESPConfig.Enabled then
                    updateBoxColor(player, box, outline)
                end
            end)
        end
    end
    
    -- Connect to new players
    Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            local box, outline = createBox(player)
            box.Parent = workspace
            outline.Parent = workspace
            boxEspBoxes[player] = {box = box, outline = outline}
            
            player.CharacterAdded:Connect(function(character)
                if BoxESPConfig.Enabled then
                    local rootPart = character:WaitForChild("HumanoidRootPart")
                    if rootPart then
                        box.Adornee = rootPart
                        box.Parent = rootPart
                        outline.Adornee = rootPart
                        outline.Parent = rootPart
                        updateBoxColor(player, box, outline)
                    end
                end
            end)
        end
    end)
end

function BoxEspOff()
    if not BoxESPConfig.Enabled then return end
    BoxESPConfig.Enabled = false
    
    for player, data in pairs(boxEspBoxes) do
        data.box:Destroy()
        data.outline:Destroy()
    end
    boxEspBoxes = {}
end

function EspOff()
    NameEspOff()
    BoxEspOff()
end

-- Handle player respawn
Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if NameESPConfig.Enabled then
        CreateEspLabel(character)
    end
end)

-- Table to store ESP objects
local espObjects = {}
local espConnections = {}

-- Function to create ESP for a player
local function createEsp(player)
    -- Ensure the player has a character and head
    if not player.Character or not player.Character:FindFirstChild("Head") then return end

    -- Create BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "ESP"
    billboardGui.Adornee = player.Character.Head
    billboardGui.Size = UDim2.new(1, 0, 1, 0)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.AlwaysOnTop = true

    -- Create TextLabel
    local textLabel = Instance.new("TextLabel", billboardGui)
    textLabel.Text = player.Name
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = player.Team == game.Players.LocalPlayer.Team and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)  -- Green for teammates, red for non-teammates

    -- Store ESP object
    espObjects[player] = {
        billboardGui = billboardGui,
        textLabel = textLabel
    }

    -- Parent BillboardGui to player's head
    billboardGui.Parent = player.Character.Head
end

-- Function to remove ESP from a player
local function removeEsp(player)
    if espObjects[player] then
        espObjects[player].billboardGui:Destroy()
        espObjects[player] = nil
    end
end

-- Function to update ESP size based on distance
local function updateEspSize()
    for player, esp in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local distance = (game.Players.LocalPlayer.Character.Head.Position - player.Character.Head.Position).magnitude
            esp.billboardGui.Size = UDim2.new(distance / 50, 0, distance / 50, 0)  -- Adjust size based on distance
        end
    end
end

-- Function to handle player respawn
local function onCharacterAdded(player)
    -- Wait for the head to be created
    player.Character:WaitForChild("Head")
    createEsp(player)
end

-- Function to enable ESP
function EspOn()
    -- Create ESP for all players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            createEsp(player)
            -- Connect CharacterAdded event to handle respawns
            espConnections[player] = player.CharacterAdded:Connect(function()
                onCharacterAdded(player)
            end)
        end
    end

    -- Connect PlayerAdded event to handle rejoins
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            createEsp(player)
            -- Connect CharacterAdded event to handle respawns
            espConnections[player] = player.CharacterAdded:Connect(function()
                onCharacterAdded(player)
            end)
        end
    end)

    -- Connect PlayerRemoving event
    game.Players.PlayerRemoving:Connect(function(player)
        removeEsp(player)
        -- Disconnect the CharacterAdded event
        if espConnections[player] then
            espConnections[player]:Disconnect()
            espConnections[player] = nil
        end
    end)

    -- Connect RenderStepped event to update ESP size
    game:GetService("RunService").RenderStepped:Connect(updateEspSize)
end

-- Function to disable ESP
function EspOff()
    -- Remove ESP from all players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            removeEsp(player)
            -- Disconnect the CharacterAdded event
            if espConnections[player] then
                espConnections[player]:Disconnect()
                espConnections[player] = nil
            end
        end
    end

    -- Disconnect all RenderStepped events (optional, but recommended for cleanup)
    for _, connection in ipairs(game:GetService("RunService").RenderStepped:GetConnections()) do
        connection:Disconnect()
    end
end

-- WinObby
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Settings
local TELEPORT_HEIGHT = 3
local TELEPORT_DELAY = 0.1
local RETRY_DELAY = 0.10
local MAX_ATTEMPTS = 100

-- Find all potential checkpoint containers
local potentialContainers = {
    "Checkpoints", "checkpoints", "Checkpoint", "checkpoint",
    "CP", "cp", "Flags", "flags", "Flag", "flag",
    "Markers", "markers", "Waypoints", "waypoints"
}

-- Function to find the first valid container
local function findCheckpointContainer()
    for _, name in ipairs(potentialContainers) do
        local container = game.Workspace:FindFirstChild(name)
        if container then
            print("Found checkpoint container:", container.Name)
            return container
        end
    end
    return nil
end

local checkpointContainer = findCheckpointContainer()

if not checkpointContainer then
    warn("No checkpoint container found! Searching entire Workspace...")
    checkpointContainer = game.Workspace
end

-- Collect all potential checkpoints
local checkpoints = {}
for _, child in ipairs(checkpointContainer:GetDescendants()) do
    if child:IsA("BasePart") then
        -- Check for common checkpoint name patterns (case-insensitive)
        local lowerName = child.Name:lower()
        if lowerName:find("checkpoint") or 
           lowerName:find("cp") or 
           lowerName:find("flag") or 
           lowerName:find("marker") or 
           lowerName:find("waypoint") or
           #checkpointContainer:GetChildren() < 10 then -- If container has few children, assume all are checkpoints
            table.insert(checkpoints, child)
            print("Found potential checkpoint:", child:GetFullName())
        end
    end
end

if #checkpoints == 0 then
    -- Last resort: collect all parts in container
    warn("No specifically named checkpoints found. Collecting all parts in container...")
    for _, child in ipairs(checkpointContainer:GetChildren()) do
        if child:IsA("BasePart") then
            table.insert(checkpoints, child)
            print("Including part as checkpoint:", child:GetFullName())
        end
    end
end

if #checkpoints == 0 then
    error("No valid checkpoints found anywhere in workspace!")
    return
end

-- Smart sorting function
local function getSortValue(name)
    -- First try to extract number
    local num = tonumber(name:match("%d+"))
    if num then return num end
    
    -- Then try letter value (A=1, B=2, etc) 
    local letter = name:upper():match("^[A-Z]")
    if letter then return string.byte(letter) - 64 end
    
    -- Default for unnamed parts
    return 0
end

table.sort(checkpoints, function(a, b)
    local aVal = getSortValue(a.Name)
    local bVal = getSortValue(b.Name)
    
    if aVal == bVal then
        return a.Name:lower() < b.Name:lower()
    else
        return aVal < bVal
    end
end)

print("Sorted checkpoints order:")
for i, checkpoint in ipairs(checkpoints) do
    print(i, checkpoint:GetFullName())
end

-- Enhanced teleport function
local function teleportToCheckpoint(checkpoint)
    if not (character and character.Parent) then
        character = player.Character or player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
        rootPart = character:WaitForChild("HumanoidRootPart")
    end
    
    local success = pcall(function()
        rootPart.CFrame = checkpoint.CFrame + Vector3.new(0, TELEPORT_HEIGHT, 0)
    end)
    
    if not success then
        -- Try alternative teleport method
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = checkpoint.CFrame + Vector3.new(0, TELEPORT_HEIGHT, 0)
            return true
        end
        return false
    end
    return true
end

function TPCheckpoints()
    print("Starting teleportation sequence to", #checkpoints, "checkpoints...")
    
    for i, checkpoint in ipairs(checkpoints) do
        local attempts = 0
        local teleported = false
        
        while attempts < MAX_ATTEMPTS and not teleported do
            attempts += 1
            teleported = teleportToCheckpoint(checkpoint)
            
            if not teleported then
                warn("Attempt", attempts, "failed for", checkpoint:GetFullName())
                task.wait(RETRY_DELAY)
            end
        end
        
        if teleported then
            print("Successfully teleported to", checkpoint:GetFullName())
            if i < #checkpoints then
                task.wait(TELEPORT_DELAY)
            end
        else
            warn("Failed to teleport to", checkpoint:GetFullName(), "after", MAX_ATTEMPTS, "attempts")
        end
    end
    
    print("Teleportation sequence complete!")
end

-- Black Hole Script Function
local function blackHoleScript()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Attachment1 = Instance.new("Attachment", Part)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1

    if not Network then
        Network = {
            BaseParts = {},
            Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
        }

        Network.RetainPart = function(Part)
            if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                table.insert(Network.BaseParts, Part)
                Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                Part.CanCollide = false
            end
        end

        local function EnablePartControl()
            LocalPlayer.ReplicationFocus = Workspace
            RunService.Heartbeat:Connect(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                for _, Part in pairs(Network.BaseParts) do
                    if Part:IsDescendantOf(Workspace) then
                        Part.Velocity = Network.Velocity
                    end
                end
            end)
        end

        EnablePartControl()
    end

    local function ForcePart(v)
        if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
            for _, x in next, v:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if v:FindFirstChild("Attachment") then
                v:FindFirstChild("Attachment"):Destroy()
            end
            if v:FindFirstChild("AlignPosition") then
                v:FindFirstChild("AlignPosition"):Destroy()
            end
            if v:FindFirstChild("Torque") then
                v:FindFirstChild("Torque"):Destroy()
            end
            v.CanCollide = false
            local Torque = Instance.new("Torque", v)
            Torque.Torque = Vector3.new(100000, 100000, 100000)
            local AlignPosition = Instance.new("AlignPosition", v)
            local Attachment2 = Instance.new("Attachment", v)
            Torque.Attachment0 = Attachment2
            AlignPosition.MaxForce = 9999999999999999
            AlignPosition.MaxVelocity = math.huge
            AlignPosition.Responsiveness = 200
            AlignPosition.Attachment0 = Attachment2
            AlignPosition.Attachment1 = Attachment1
        end
    end

    blackHoleActive = true

    for _, v in next, Workspace:GetDescendants() do
        ForcePart(v)
    end

    Workspace.DescendantAdded:Connect(function(v)
        if blackHoleActive then
            ForcePart(v)
        end
    end)

    spawn(function()
        while blackHoleActive and RunService.RenderStepped:Wait() do
            Attachment1.WorldCFrame = humanoidRootPart.CFrame
        end
    end)
end

-- Function to disable black hole
local function disableBlackHole()
    blackHoleActive = false
    if Folder then
        Folder:Destroy()
        Folder = nil
    end
    if Network then
        Network.BaseParts = {}
    end
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
        return GetPlayers[math.random(#GetPlayers)]
    elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
        for _,x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) then
                    return x;
                elseif x.DisplayName:lower():match("^"..Name) then
                    return x;
                end
            end
        end
    else
        return
    end
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle

    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessory and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    end
end

local StartFlingAll = function(Targets)
    if Targets[1] then 
        for _,x in next, Targets do 
            GetPlayer(x) 
        end 
    else 
        return 
    end

    if AllBool then
        for _,x in next, Players:GetPlayers() do
            SkidFling(x)
        end
    end

    for _,x in next, Targets do
        if GetPlayer(x) and GetPlayer(x) ~= Player then
            if GetPlayer(x).UserId ~= 1414978355 then
                local TPlayer = GetPlayer(x)
                if TPlayer then
                    SkidFling(TPlayer)
                end
            end
        end
    end
end

-- Fling Functionality without UI

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function Message(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local function SkidFling(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter and TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit then
            return Message("Error Occurred", "Target is sitting", 5)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        else
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local function FPos(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local function SFBasePart(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Occurred", "Random error", 5)
    end
end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local math = math

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local torso = character:WaitForChild("HumanoidRootPart") -- R15 part

local particleEmitter = Instance.new("ParticleEmitter")
particleEmitter.Texture = "rbxassetid://<your_cube_texture_id>"
particleEmitter.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
particleEmitter.Size = NumberSequence.new(0.3)
particleEmitter.Lifetime = NumberRange.new(1)
particleEmitter.Rate = 10
particleEmitter.Parent = torso

local function spawnCube()
    local cube = Instance.new("Part")
    cube.Shape = Enum.PartType.Block
    cube.Size = Vector3.new(0.3, 0.3, 0.3)
    cube.Color = Color3.fromRGB(255, 255, 0)
    cube.Anchored = true
    cube.CanCollide = false
    cube.Material = Enum.Material.Neon -- Neon material for glowing effect

    local light = Instance.new("PointLight")
    light.Color = Color3.fromRGB(255, 255, 0)
    light.Brightness = 0.5
    light.Range = 3
    light.Parent = cube

    cube.Parent = workspace

    -- Generate spinning oval coordinates
    local radiusX = 2.5 -- Horizontal radius
    local radiusY = 1.5 -- Vertical radius
    local theta = math.random() * 2 * math.pi -- Random angle
    local x = radiusX * math.cos(theta)
    local y = radiusY * math.sin(theta)
    local z = math.random(-1, 1) -- Random depth

    -- Apply rotation to create spinning effect
    local rotationAngle = tick() * 5 -- Adjust speed here (higher = faster)
    local rotatedX = x * math.cos(rotationAngle) - z * math.sin(rotationAngle)
    local rotatedZ = x * math.sin(rotationAngle) + z * math.cos(rotationAngle)

    cube.Position = torso.Position + Vector3.new(rotatedX, y, rotatedZ)

    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
    local tweenGoal = {Transparency = 1}
    local tween = TweenService:Create(cube, tweenInfo, tweenGoal)
    tween:Play()
    tween.Completed:Connect(function()
        cube:Destroy()
    end)
end

local emitterEnabled = false
local cubeSpawnConnection

function EmitterOn()
    if not emitterEnabled then
        emitterEnabled = true
        particleEmitter.Enabled = true
        cubeSpawnConnection = RunService.RenderStepped:Connect(function()
            spawnCube()
        end)
    end
end

function EmitterOff()
    if emitterEnabled then
        emitterEnabled = false
        particleEmitter.Enabled = false
        if cubeSpawnConnection then
            cubeSpawnConnection:Disconnect()
            cubeSpawnConnection = nil
        end
    end
end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local TFlingActive = false
local ModeActive = false
local TFlingCoroutine
local ModeConnection

-- TFling functionality
local function TFling()
    local character = LocalPlayer.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    while TFlingActive do
        RunService.Heartbeat:Wait()
        local velocity = rootPart.Velocity
        rootPart.Velocity = velocity * 999999999999999999999999999999999 + Vector3.new(0, 999999999999999999999999999999999, 0)
        RunService.RenderStepped:Wait()
        rootPart.Velocity = velocity
        RunService.Stepped:Wait()
        rootPart.Velocity = velocity + Vector3.new(0, 0.1, 0)
    end
end

-- Mode functionality
local function DisableCollisions()
    if not LocalPlayer.Character then return end
    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and not part.Anchored then
            part.CanCollide = false
        end
    end
end

local function EnableCollisions()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Control functions
function TFlingOn()
    TFlingActive = true
    TFlingCoroutine = coroutine.create(TFling)
    coroutine.resume(TFlingCoroutine)
end

function TFlingOff()
    TFlingActive = false
    if TFlingCoroutine then
        coroutine.close(TFlingCoroutine)
    end
end

function ModeOn()
    ModeActive = true
    ModeConnection = RunService.Heartbeat:Connect(DisableCollisions)
end

function ModeOff()
    ModeActive = false
    if ModeConnection then
        ModeConnection:Disconnect()
    end
    EnableCollisions()
end


    local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local RunService = game:GetService("RunService")

local tpSpeed = 1
local tpWalking = false
local tpConnection = nil

-- Improved TP Walk Function
local function TpWalk()
    if tpConnection then return end

    tpConnection = RunService.Heartbeat:Connect(function(delta)
        if not rootPart or not humanoid or humanoid.Health <= 0 then
            StopTpWalk()
            return
        end

        if humanoid.MoveDirection.Magnitude > 0 then
            local moveDirection = humanoid.MoveDirection.Unit
            local offset = moveDirection * tpSpeed * 50 * delta
            rootPart.CFrame = rootPart.CFrame + offset
        end
    end)
end

local function StartTpWalk()
    if not tpWalking then
        tpWalking = true
        TpWalk()
    end
end

local function StopTpWalk()
    if tpConnection then
        tpConnection:Disconnect()
        tpConnection = nil
    end
    tpWalking = false
    print("TP Walk stopped.")
end

local function SetTpWalkSpeed(newSpeed)
    tpSpeed = newSpeed
    print("TP Walk speed set to:", tpSpeed)
end

    local player = game.Players.LocalPlayer  
    local character = player.Character or player.CharacterAdded:Wait()  
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")  

    function LayDown()  
    if humanoidRootPart then  
            humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0)  
        end  
    end  

    -- Function to enable XRay
    local function enableXRay()
        for _, part in pairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and not part:IsA("Terrain") then
                originalTransparency[part] = part.Transparency
                part.Transparency = 0.8 -- Set transparency to make parts semi-transparent
            end
        end
    end

    -- Function to disable XRay
    local function disableXRay()
        for part, transparency in pairs(originalTransparency) do
            if part:IsA("BasePart") then
                part.Transparency = transparency -- Restore original transparency
            end
        end
        originalTransparency = {} -- Clear the table
    end


    -- Function to handle input
    local function handleInput(input)
        local command = input.Text
        input.Text = ""

        -- Add the command to the output
        outputText.Text = outputText.Text .. "\n</> " .. command

        -- Simulate command execution
        local result = "Command not recognized."
        if command == "🍪" then
            result = "🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪??🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪"
        elseif command == "clear" then
            outputText.Text = ""
            return
         elseif command:sub(1, 11) == "jumpower " or command:sub(1, 3) == "jp " then
            local speed = tonumber(command:match("%d+"))
            if speed then
                player.Character.Humanoid.JumpPower = speed
                result = "JumpPower set to " .. speed
            else
                result = "Invalid walkspeed value."
            end
        elseif command == "resetjumppower" or command == "resetjp" then
            player.Character.Humanoid.JumpPower = 50
            result = "JumpPower reset to 50"
        elseif command:sub(1, 10) == "walkspeed " or command:sub(1, 3) == "ws " then
            local speed = tonumber(command:match("%d+"))
            if speed then
                player.Character.Humanoid.WalkSpeed = speed
                result = "Walkspeed set to " .. speed
            else
                result = "Invalid walkspeed value."
            end
        elseif command == "resetwalkspeed" or command == "resetws" then
            player.Character.Humanoid.WalkSpeed = 16
            result = "Walkspeed reset to 16"
        elseif command:sub(1, 5) == "tpto " then
            local targetPlayerName = command:sub(6)
            if targetPlayerName == "random" then
                -- Teleport to a random player
                local players = Players:GetPlayers()
                local randomPlayer = players[math.random(2, #players)] -- Exclude self
                if randomPlayer and randomPlayer.Character then
                    player.Character:MoveTo(randomPlayer.Character.HumanoidRootPart.Position)
                    result = "Teleported to random player: " .. randomPlayer.Name
                else
                    result = "No valid random player found."
                end
            else
                -- Teleport to a specific player
                local targetPlayer = Players:FindFirstChild(targetPlayerName)
                if targetPlayer and targetPlayer.Character then
                    player.Character:MoveTo(targetPlayer.Character.HumanoidRootPart.Position)
                    result = "Teleported to " .. targetPlayerName
                else
                    result = "Player not found."
                end
            end
        elseif command == "bring unachoredparts" or command == "bring ua" then
            for _, part in pairs(workspace:GetDescendants()) do
                if part:IsA("BasePart") and not part.Anchored and not Players:GetPlayerFromCharacter(part.Parent) and not part:IsDescendantOf(player.Character) and not part:IsDescendantOf(Players.LocalPlayer.Character) then
                    part.Position = player.Character.HumanoidRootPart.Position
                end
            end
            result = "Brought all unanchored parts to you."
        elseif command == "esp" then
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = otherPlayer.Character
                    highlight.FillColor = Color3.new(1, 0, 0)
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                    highlight.OutlineTransparency = 0.5
                    highlight.Parent = otherPlayer.Character
                end
            end
            result = "ESP enabled."
        elseif command == "unesp" then
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, child in pairs(otherPlayer.Character:GetChildren()) do
                        if child:IsA("Highlight") then
                            child:Destroy()
                        end
                    end
                end
            end
            result = "ESP disabled."
        elseif command:sub(1, 10) == "unctest" then
            local luaCode = command:sub(11)
            local func, err = loadstring(game:HttpGet("https://pastebin.com/raw/MzpVFDwx"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started UncTest:\n"
            end
        elseif command:sub(1, 11) == "pcr" then
            local luaCode = command:sub(12)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PCR/refs/heads/main/PartControllerRemote"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "pcr is active:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "PartControllerRemote is active:\n"
            end
        elseif command:sub(1, 12) == "hitblox" then
            local luaCode = command:sub(13)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Hitblox/refs/heads/main/Hitblox"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "HitbloxIsActive:\n"
            end
        elseif command:sub(1, 13) == "dex" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/peyton2465/Dex/master/out.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DexExplorerIsActive:\n"
            end
        elseif command:sub(1, 13) == "dexexplorer" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/peyton2465/Dex/master/out.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DexExplorerIsActive:\n"
            end
        elseif command:sub(1, 13) == "iy" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "InfyieldIsActive:\n"
            end
        elseif command:sub(1, 13) == "infiniteyield" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "InfyieldIsActive:\n"
            end
        elseif command:sub(1, 15) == "blackhole" then
            local luaCode = command:sub(16)
            local func, err = blackHoleScript()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "disableblackhole" then
            local luaCode = command:sub(16)
            local func, err = disableBlackHole()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Disabled:\n"
            end
        elseif command:sub(1, 18) == "cmds" then
            local luaCode = command:sub(18)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Cmdspaneldbsnsbsm/refs/heads/main/ShowCmdsPanellollol123123", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Command panel Started:\nSearch For A Command"
            end
        elseif command:sub(1, 18) == "cmd" then
            local luaCode = command:sub(18)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Cmdspaneldbsnsbsm/refs/heads/main/ShowCmdsPanellollol123123", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Command panel Started:\nSearch For A Command"
            end
        elseif command:sub(1, 15) == "bh" then
            local luaCode = command:sub(16)
            local func, err = blackHoleScript()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "dbh" then
            local luaCode = command:sub(16)
            local func, err = disableBlackHole()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Blackhole Is Disabled:\n"
            end
        elseif command:sub(1,4) == "fov " then
            local fovValue = tonumber(command:sub(5))
            if fovValue and fovValue >= 1 and fovValue <= 120 then
                game.Workspace.CurrentCamera.FieldOfView = fovValue
                result = "FOV set to "..fovValue
            else
                result = "Invalid FOV (1-120)"
            end
        elseif command == "serverhop" then
            result = "Attempting to server hop..."
            local HttpService = game:GetService("HttpService")
            local TeleportService = game:GetService("TeleportService")
    
            local placeId = game.PlaceId
            local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
    
            for _, server in ipairs(servers.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id)
                    break
                end
            end
        elseif command == "shop" then
            result = "Attempting to server hop..."
            local HttpService = game:GetService("HttpService")
            local TeleportService = game:GetService("TeleportService")
    
            local placeId = game.PlaceId
            local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
    
            for _, server in ipairs(servers.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id)
                    break
                end
            end
        elseif command:sub(1, 15) == "besp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "boxesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "disableboxesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "dbesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Disabled:\n"
            end
        elseif command:sub(1, 15) == "disablenameesp" then
            local luaCode = command:sub(16)
            local func, err = BoxEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "BoxEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "floatparts" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Gravity-inverter/refs/heads/main/GI", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "floaty :):\n"
            end
        elseif command:sub(1, 15) == "nesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "nameesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Enabled:\n"
            end
        elseif command:sub(1, 15) == "dnesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Disable:\n"
            end
        elseif command:sub(1, 15) == "disablenameesp" then
            local luaCode = command:sub(16)
            local func, err = NameEspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NameTagEsp Is Disabled:\n"
            end
        elseif command:sub(1, 13) == "reset" then
            local luaCode = command:sub(14)
            local func, err = game.Players.LocalPlayer.Character.Head:Destroy()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Reseting:\nUr Player has been reseted"
            end
        elseif command:sub(1, 13) == "re" then
            local luaCode = command:sub(14)
            local func, err = game.Players.LocalPlayer.Character.Head:Destroy()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Reseting:\nUr Player has been reseted"
            end
         elseif command:sub(1, 6) == "fling " then
            local targetPlayerName = command:sub(7)
            if targetPlayerName == "random" then
                -- Fling a random player
                local players = Players:GetPlayers()
                local randomPlayer = players[math.random(2, #players)] -- Exclude self
                if randomPlayer then
                    SkidFling(randomPlayer)
                    result = "Flinging random player: " .. randomPlayer.Name
                else
                    result = "No valid random player found."
                end
            else
                -- Fling a specific player
                local targetPlayer = GetPlayer(targetPlayerName)
                if targetPlayer then
                    SkidFling(targetPlayer)
                    result = "Flinging " .. targetPlayer.Name
                else
                    result = "Player not found."
                end
            end
        elseif command:sub(1, 17) == "flingall" then
            local luaCode = command:sub(18)
            local func, err = StartFlingAll({"All"})
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Flinged all players:\n"
            end
        elseif command:sub(1, 14) == "sit" then
            local luaCode = command:sub(15)
            local func, err = SitPlayer()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Sitting:\n"
            end
        elseif command:sub(1, 15) == "lay" then
            local luaCode = command:sub(16)
            local func, err = LayDown()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "laying:\n"
            end
        elseif command:sub(1, 9):lower() == "flygui" or command:sub(1, 5):lower() == "fly" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/F/refs/heads/main/F", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started FlyGui:\n"
            end
        elseif command:sub(1, 9):lower() == "killgui" or command:sub(1, 5):lower() == "kill" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/InstantKillig/refs/heads/main/Coolkillguithingy", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started KillGui:\n(REQ, Sword Or Tool)"
            end
        elseif command:sub(1, 15) == "infoviewer" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty31.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "I have Ur IP address:\n"
            end
        elseif command:sub(1, 9):lower() == "silverware" or command:sub(1, 5):lower() == "sw" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SilverWare/refs/heads/main/SW", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started SilverWare:\n"
            end
        elseif command:sub(1, 15) == "tornado" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TornadoGuiIg/refs/heads/main/Srrylolitsobfuscatednomorestealing", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started TornadoGui:\nWont work on some exec"
            end
        elseif command:sub(1, 15) == "td" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TornadoGuiIg/refs/heads/main/Srrylolitsobfuscatednomorestealing", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started TornadoGui:\nWont work on some exec"
            end
        elseif command:sub(1, 15) == "changerig" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/Bac0nHck/Scripts/refs/heads/main/ChangeRigType"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Changing Rig Type...:\n"
            end
        elseif command:sub(1, 15) == "rig" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/Bac0nHck/Scripts/refs/heads/main/ChangeRigType"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Changing Rig Type...:\n"
                end
            else
                result = "Changing Rig Type...:\n"
            end
        elseif command:sub(1, 15) == "invertgrav" then
            local luaCode = command:sub(16)
            local func, err = GravOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Inverting Gravity To UnachoredParts:\nWont Work On some Exec"
            end
        elseif command:sub(1, 15) == "uninvertgrav" then
            local luaCode = command:sub(16)
            local func, err = GravOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Stopped Inverting Gravity To UnachoredParts:\n"
            end
        elseif command:sub(1, 10):lower() == "setuagrav " then
            local gravityValue = tonumber(command:sub(11))
            if gravityValue then
                -- Set maximum simulation range
                sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 5000)
                sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", 5000)
                
                -- Clear previous modifications
                if _G.CustomGravityForces then
                    for part, force in pairs(_G.CustomGravityForces) do
                        if part and part.Parent then force:Destroy() end
                    end
                end
                
                _G.CustomGravityForces = {}
                local changed = 0
                local partsProcessed = 0
                local maxPartsPerFrame = 100 -- Process in chunks to prevent lag
                
                -- Create a list of all parts first to avoid nested loops
                local partsToProcess = {}
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored then
                        table.insert(partsToProcess, part)
                    end
                end
                
                -- Process in chunks using RunService
                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local processed = 0
                    while processed < maxPartsPerFrame and partsProcessed < #partsToProcess do
                        partsProcessed = partsProcessed + 1
                        local part = partsToProcess[partsProcessed]
                        
                        -- Remove existing forces
                        for _, child in ipairs(part:GetChildren()) do
                            if child:IsA("BodyForce") and child.Name == "CustomGravityForce" then
                                child:Destroy()
                            end
                        end
                        
                        -- Apply new force
                        local bodyForce = Instance.new("BodyForce")
                        bodyForce.Name = "CustomGravityForce"
                        
                        if gravityValue == 0 then
                            bodyForce.Force = Vector3.new(0, part:GetMass() * workspace.Gravity, 0)
                            part.Velocity = Vector3.new(0, 0, 0)
                            part.RotVelocity = Vector3.new(0, 0, 0)
                        else
                            bodyForce.Force = Vector3.new(0, part:GetMass() * workspace.Gravity * (gravityValue - 1), 0)
                        end
                        
                        bodyForce.Parent = part
                        _G.CustomGravityForces[part] = bodyForce
                        changed = changed + 1
                        processed = processed + 1
                    end
                    
                    if partsProcessed >= #partsToProcess then
                        connection:Disconnect()
                        result = string.format("Successfully applied gravity to %d parts (Multiplier: %.2f)", changed, gravityValue)
                    end
                end)
                
                result = string.format("Processing %d parts... (%.1f%%)", #partsToProcess, 0)
            else
                result = "Invalid value! Usage: setuagrav [number]\nExample: setuagrav 0 (zero gravity), setuagrav 0.5 (half gravity), setuagrav 2.0 (double gravity)"
            end
        elseif command:sub(1, 11):lower() == "resetuagrav" then
            if _G.CustomGravityForces then
                local restored = 0
                local maxPerFrame = 100
                local totalToProcess = 0
                
                -- First count how many we need to process
                for _ in pairs(_G.CustomGravityForces) do totalToProcess = totalToProcess + 1 end
                
                local processed = 0
                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local batch = 0
                    for part, force in pairs(_G.CustomGravityForces) do
                        if part and part.Parent then
                            force:Destroy()
                            restored = restored + 1
                        end
                        _G.CustomGravityForces[part] = nil
                        processed = processed + 1
                        batch = batch + 1
                        
                        if batch >= maxPerFrame then break end
                    end
                    
                    if processed >= totalToProcess then
                        connection:Disconnect()
                        _G.CustomGravityForces = nil
                        result = string.format("Removed custom gravity from %d parts", restored)
                    else
                        result = string.format("Resetting... (%d/%d)", processed, totalToProcess)
                    end
                end)
            else
                result = "No custom gravity forces to remove"
            end
        elseif command:sub(1, 15) == "bhop" then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:WaitForChild("Humanoid")
            
            -- Disconnect previous connection if exists
            if _G.BHopConnection then
                _G.BHopConnection:Disconnect()
            end
            
            -- Create new connection
            _G.BHopConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if humanoid and humanoid.FloorMaterial ~= Enum.Material.Air then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
            
            -- Increase jump power
            humanoid.JumpPower = 60
            humanoid.JumpHeight = 8
            
            result = "Bunnyhop activated! Auto-jumping when touching ground."
        elseif command:sub(1, 18) == "unbhop" then
            if _G.BHopConnection then
                _G.BHopConnection:Disconnect()
                _G.BHopConnection = nil
                
                -- Reset jump power
                local player = game:GetService("Players").LocalPlayer
                if player.Character then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.JumpPower = 50
                        humanoid.JumpHeight = 7.5
                    end
                end
                
                result = "Bunnyhop deactivated"
            else
                result = "Bunnyhop wasn't active"
            end
        elseif command:sub(1, 5) == "spin " then -- spins your character with adjustable speed
            local spinSpeed = tonumber(command:sub(6)) or 20  -- Default speed if not specified
            
            -- Get player components
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            -- Clean up any existing spin connection
            if _G.SpinConnection then
                _G.SpinConnection:Disconnect()
                _G.SpinConnection = nil
            end
            
            -- Create new spinning function
            local spinFunction = function()
                if humanoidRootPart and humanoidRootPart.Parent then
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
                else
                    if _G.SpinConnection then
                        _G.SpinConnection:Disconnect()
                        _G.SpinConnection = nil
                    end
                end
            end
            
            -- Start spinning
            _G.SpinConnection = game:GetService("RunService").Heartbeat:Connect(spinFunction)
            
            result = string.format("Spinning activated at speed: %d\n(Use 'unspin' to stop)", spinSpeed)
        elseif command:sub(1, 7) == "unspin" then -- stops spinning
            if _G.SpinConnection then
                _G.SpinConnection:Disconnect()
                _G.SpinConnection = nil
                result = "Spinning stopped"
            else
                result = "No active spinning to stop"
            end
        elseif command:sub(1, 15) == "graballtools" then -- grabs all tools even if it needs robux or it's on the ground
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if not humanoid then
                result = "Error: No humanoid found in character"
                return
            end
            local toolsCollected = 0
            local toolsFailed = 0
            local toolList = {}
            -- Function to attempt collecting a tool
            local function collectTool(tool)
                if tool:IsA("Tool") and not tool.Parent:IsA("Backpack") and tool.Parent ~= character then
                    -- Try normal collection first
                    local success = pcall(function()
                        tool.Parent = character
                    end)
                    
                    if not success then
                        -- If normal method fails, try alternative methods
                        pcall(function()
                            -- Try to clone the tool
                            local clone = tool:Clone()
                            clone.Parent = character
                            tool = clone
                        end)
                    end
                    if tool.Parent == character then
                        toolsCollected = toolsCollected + 1
                        table.insert(toolList, tool.Name)
                        return true
                    else
                        toolsFailed = toolsFailed + 1
                        return false
                    end
                end
                return false
            end
            -- Collect tools from workspace
            for _, tool in ipairs(game:GetService("Workspace"):GetDescendants()) do
                collectTool(tool)
            end
            -- Collect tools from other players
            for _, otherPlayer in ipairs(game:GetService("Players"):GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, tool in ipairs(otherPlayer.Character:GetDescendants()) do
                        collectTool(tool)
                    end
                end
            end
            -- Collect tools from tool services
            for _, service in ipairs(game:GetChildren()) do
                if service:IsA("BackpackItem") or service:IsA("Tool") then
                    collectTool(service)
                end
            end
            -- Prepare result message
            if toolsCollected > 0 then
                result = string.format("Successfully collected %d tools:\n", toolsCollected) ..
                         table.concat(toolList, ", ") ..
                         (toolsFailed > 0 and string.format("\nFailed to collect %d tools", toolsFailed) or "")
            else
                result = "No tools collected. " .. 
                         (toolsFailed > 0 and string.format("Failed to collect %d tools", toolsFailed) or "No tools found")
            end
        elseif command:sub(1, 15) == "gat" then -- grabs all tools even if it needs robux or it's on the ground
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if not humanoid then
                result = "Error: No humanoid found in character"
                return
            end
            local toolsCollected = 0
            local toolsFailed = 0
            local toolList = {}
            -- Function to attempt collecting a tool
            local function collectTool(tool)
                if tool:IsA("Tool") and not tool.Parent:IsA("Backpack") and tool.Parent ~= character then
                    -- Try normal collection first
                    local success = pcall(function()
                        tool.Parent = character
                    end)
                    
                    if not success then
                        -- If normal method fails, try alternative methods
                        pcall(function()
                            -- Try to clone the tool
                            local clone = tool:Clone()
                            clone.Parent = character
                            tool = clone
                        end)
                    end
                    if tool.Parent == character then
                        toolsCollected = toolsCollected + 1
                        table.insert(toolList, tool.Name)
                        return true
                    else
                        toolsFailed = toolsFailed + 1
                        return false
                    end
                end
                return false
            end
            -- Collect tools from workspace
            for _, tool in ipairs(game:GetService("Workspace"):GetDescendants()) do
                collectTool(tool)
            end
            -- Collect tools from other players
            for _, otherPlayer in ipairs(game:GetService("Players"):GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character then
                    for _, tool in ipairs(otherPlayer.Character:GetDescendants()) do
                        collectTool(tool)
                    end
                end
            end
            -- Collect tools from tool services
            for _, service in ipairs(game:GetChildren()) do
                if service:IsA("BackpackItem") or service:IsA("Tool") then
                    collectTool(service)
                end
            end
            -- Prepare result message
            if toolsCollected > 0 then
                result = string.format("Successfully collected %d tools:\n", toolsCollected) ..
                         table.concat(toolList, ", ") ..
                         (toolsFailed > 0 and string.format("\nFailed to collect %d tools", toolsFailed) or "")
            else
                result = "No tools collected. " .. 
                         (toolsFailed > 0 and string.format("Failed to collect %d tools", toolsFailed) or "No tools found")
            end
        elseif command:sub(1, 15) == "toolgiver" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/yofriendfromschool1/Sky-Hub-Backup/main/gametoolgiver.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "ToolGiver Loaded:\n"
            end
        elseif command:sub(1, 15) == "rpv2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SuperRingV2/refs/heads/main/SuperRing"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RingPartsV2 Started:\nRingParts but with shapes"
            end
        elseif command:sub(1, 5) == "zoom " then
            local distance = tonumber(command:sub(6))
            if distance then
                local player = game.Players.LocalPlayer
                player.CameraMaxZoomDistance = distance
                player.CameraMinZoomDistance = 0.5 -- optional: minimum zoom in
                result = "ZoomCameraDistance is set to: " .. distance
            else
                result = "Invalid zoom value. Usage: zoom [number]"
            end
        elseif command:sub(1, 15) == "rochips" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/load/refs/heads/main/rcloader"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RoChipsPanel Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "rc" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/load/refs/heads/main/rcloader"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "RoChipsPanel Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "control npc" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty38.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
                end
            else
                result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "cn" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty38.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
                end
            else
                result = "ControlNpc Started:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "pshade" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet('https://raw.githubusercontent.com/randomstring0/pshade-ultimate/refs/heads/main/src/cd.lua'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "your device is overheating at (109.4°F):\nGo Sub To @Im_Patrick"
                end
            else
                result = "your device is overheating at (109.4°F):\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "invistoggle" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet('https://pastebin.com/raw/3Rnd9rHf'))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started Invistoggle:\n"
            end
        elseif command:sub(1, 15) == "moveparts" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://pastefy.app/Vcuyg09O/raw", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "MovePartsStarted:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 15) == "mp" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://pastefy.app/Vcuyg09O/raw", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "MovePartsStarted:\nGo Sub To @Im_Patrick"
            end
        elseif command:sub(1, 5) == "nofog" then -- removes or pushes fog far away
            local atmosphere = game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere")
            local fogEnd = 1000000 -- Very far distance (effectively removes fog)
            
            if atmosphere then
                -- Save original fog settings if we haven't already
                if not _originalFogSettings then
                    _originalFogSettings = {
                        Density = atmosphere.Density,
                        Offset = atmosphere.Offset,
                        Color = atmosphere.Color,
                        Decay = atmosphere.Decay,
                        Glare = atmosphere.Glare,
                        Haze = atmosphere.Haze
                    }
                end
                
                -- Disable fog effects
                atmosphere.Density = 0
                atmosphere.Offset = 0
                atmosphere.Decay = Color3.new(1, 1, 1)
                atmosphere.Glare = 0
                atmosphere.Haze = 0
                
                result = "Fog has been disabled"
            else
                -- If no Atmosphere exists, try adjusting the global Lighting fog
                local lighting = game:GetService("Lighting")
                if not _originalFogSettings then
                    _originalFogSettings = {
                        FogEnd = lighting.FogEnd,
                        FogStart = lighting.FogStart
                    }
                end
                
                lighting.FogEnd = fogEnd
                lighting.FogStart = fogEnd - 100
                
                result = "GobalFog Is Pushed"
            end
        elseif command:sub(1, 5) == "view " then
            local playerName = command:sub(6)
            local targetPlayer
            for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                if player.Name:lower():find(playerName:lower(), 1, true) then
                    targetPlayer = player
                    break
                end
            end
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    local camera = workspace.CurrentCamera
                    camera.CameraType = Enum.CameraType.Custom
                    camera.CameraSubject = humanoid
                    result = "Now viewing player: " .. targetPlayer.Name
                else
                    result = "Player " .. targetPlayer.Name .. " has no humanoid"
                end
            else
                result = "Player not found or has no character: " .. playerName
            end
        elseif command:sub(1, 7) == "unview" then
            local camera = workspace.CurrentCamera
            local localPlayer = game:GetService("Players").LocalPlayer
            if localPlayer.Character then
                camera.CameraType = Enum.CameraType.Custom
                camera.CameraSubject = localPlayer.Character:FindFirstChild("Humanoid")
                result = "Stopped viewing player"
            else
                result = "Cannot reset view — no local character found"
            end
        elseif command:sub(1, 15) == "energize" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Energize-10408"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Just a random anims ui:\n"
            end
        elseif command:sub(1, 15) == "ee" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Energize-10408"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Just a random anims ui:\n"
            end
        elseif command:sub(1, 16) == "afem" then
            local luaCode = command:sub(17)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-AFEM-14048"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Just a random anims ui that only works on r15:\n"
            end
        elseif command:lower():sub(1, 5) == "orbit" then
            local args = {}
            for arg in command:gmatch("%S+") do
                table.insert(args, arg:lower())
            end
            -- Initialize or get existing orbit system
            if not getgenv().OrbitSystem then
                getgenv().OrbitSystem = {
                    Target = nil,
                    Radius = 10,
                    Speed = 2,
                    Angle = 0,
                    Connection = nil,
                    Running = false
                }
            end
            local orbit = getgenv().OrbitSystem
            -- Handle subcommands
            if #args == 1 then
                -- Show status if no subcommands
                result = "Orbit System Status:\n"
                      .. "Target: " .. (orbit.Target and orbit.Target.Name or "None") .. "\n"
                      .. "Radius: " .. orbit.Radius .. "\n"
                      .. "Speed: " .. orbit.Speed .. "\n"
                      .. "Running: " .. (orbit.Running and "YES" or "NO") .. "\n\n"
                      .. "Commands:\n"
                      .. "orbit [player] - Orbit around player\n"
                      .. "orbit stop - Stop orbiting\n"
                      .. "orbit radius [value] - Change orbit distance\n"
                      .. "orbit speed [value] - Change orbit speed"
            elseif args[2] == "stop" then
                -- Stop orbiting
                if orbit.Connection then
                    orbit.Connection:Disconnect()
                    orbit.Connection = nil
                end
                orbit.Running = false
                orbit.Target = nil
                result = "Stopped orbiting"
            elseif args[2] == "radius" and tonumber(args[3]) then
                -- Change orbit radius
                orbit.Radius = tonumber(args[3])
                result = "Orbit radius set to " .. orbit.Radius
            elseif args[2] == "speed" and tonumber(args[3]) then
                -- Change orbit speed
                orbit.Speed = tonumber(args[3])
                result = "Orbit speed set to " .. orbit.Speed
            else
                -- Find player to orbit
                local targetName = table.concat(args, " ", 2)
                local foundPlayer = nil
                -- Search for matching player (allows partial name matching)
                for _, player in pairs(game.Players:GetPlayers()) do
                    if player ~= game.Players.LocalPlayer and 
                       player.Name:lower():find(targetName:lower(), 1, true) then
                        foundPlayer = player
                        break
                    end
                end
                if foundPlayer then
                    -- Stop any existing orbit
                    if orbit.Connection then
                        orbit.Connection:Disconnect()
                    end
                    -- Set new target
                    orbit.Target = foundPlayer
                    orbit.Angle = 0
                    orbit.Running = true
                    -- Create new orbit loop
                    orbit.Connection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                        if not orbit.Running or not orbit.Target or not orbit.Target.Character then return end
                        
                        local targetRoot = orbit.Target.Character:FindFirstChild("HumanoidRootPart")
                        local localChar = game.Players.LocalPlayer.Character
                        if not targetRoot or not localChar then return end
                        
                        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
                        if not localRoot then return end
                        
                        -- Update angle based on speed and time
                        orbit.Angle = orbit.Angle + (orbit.Speed * dt)
                        if orbit.Angle > 2 * math.pi then
                            orbit.Angle = orbit.Angle - (2 * math.pi)
                        end
                        
                        -- Calculate orbit position
                        local offset = Vector3.new(
                            math.cos(orbit.Angle) * orbit.Radius,
                            0,
                            math.sin(orbit.Angle) * orbit.Radius
                        )
                        
                        -- Apply movement
                        localRoot.CFrame = CFrame.new(targetRoot.Position + offset, targetRoot.Position)
                    end)
                    result = "Now orbiting " .. foundPlayer.Name
                else
                    result = "Player not found or invalid command. Usage:\n"
                          .. "orbit [player] - Orbit around player\n"
                          .. "orbit stop - Stop orbiting\n"
                          .. "orbit radius [value] - Change orbit distance\n"
                          .. "orbit speed [value] - Change orbit speed"
                end
            end
        elseif command:sub(1, 15) == "antikick" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/AntkickLol/refs/heads/main/Antikicklol"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiKick Started:\n"
            end
        elseif command:sub(1, 15) == "ak" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/AntkickLol/refs/heads/main/Antikicklol"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiKick Started:\n"
            end
        elseif command:sub(1, 15) == "antilag" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Al/refs/heads/main/AntiLag", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n"
            end
        elseif command:sub(1, 15) == "al" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Al/refs/heads/main/AntiLag", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n"
            end
        elseif command:sub(1, 15) == "antilag2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Jxeybdfkhwnsantilagejbesnjdd/refs/heads/main/Al2", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n(rec, FullBright)"
            end
        elseif command:sub(1, 15) == "al2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/Jxeybdfkhwnsantilagejbesnjdd/refs/heads/main/Al2", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiLag Started:\n(rec, FullBright)"
            end
        elseif command:sub(1, 15) == "acr" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/ACR/refs/heads/main/Acr", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AntiCheat Removal Loaded:\n"
            end
        elseif command:sub(1, 5) == "bang " then
            -- Stop any existing back loop first
            if backLoopConnection then
                backLoopConnection:Disconnect()
                backLoopConnection = nil
            end
            if backAnimTrack then
                backAnimTrack:Stop()
                backAnimTrack = nil
            end
            
            local targetName = command:sub(6)
            local targetPlayer = game.Players:FindFirstChild(targetName) or findPlayer(targetName) -- Use your existing findPlayer function
            
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local localPlayer = game.Players.LocalPlayer
                if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
                    -- Create animation instance
                    local anim = Instance.new("Animation")
                    anim.Name = "BackLoopAnimation"
                    anim.AnimationId = "rbxassetid://148840371"
                    
                    -- Load and play animation
                    backAnimTrack = localPlayer.Character.Humanoid:LoadAnimation(anim)
                    backAnimTrack:Play()
                    
                    -- Start position loop
                    backLoopConnection = game:GetService("RunService").Heartbeat:Connect(function()
                        if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and 
                           localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            local targetRoot = targetPlayer.Character.HumanoidRootPart
                            local localRoot = localPlayer.Character.HumanoidRootPart
                            
                            -- Calculate position 3 studs behind target
                            local offset = targetRoot.CFrame.lookVector * -1
                            local newPosition = targetRoot.Position + offset
                            
                            -- Calculate CFrame to look at target
                            local newCFrame = CFrame.new(newPosition, targetRoot.Position)
                            
                            -- Apply the new position
                            localRoot.CFrame = newCFrame
                        else
                            -- Clean up if something went wrong
                            if backLoopConnection then
                                backLoopConnection:Disconnect()
                                backLoopConnection = nil
                            end
                            if backAnimTrack then
                                backAnimTrack:Stop()
                                backAnimTrack = nil
                            end
                        end
                    end)
                    
                    result = "Now looping behind "..targetPlayer.Name.." with animation"
                else
                    result = "Local player's character not fully loaded"
                end
            else
                result = "Target player '"..targetName.."' not found or character not loaded"
            end
        elseif command:sub(1, 9) == "unbang" then
            -- Stop the back loop
            if backLoopConnection then
                backLoopConnection:Disconnect()
                backLoopConnection = nil
            end
            if backAnimTrack then
                backAnimTrack:Stop()
                backAnimTrack = nil
            end
            result = "Stopped banging"
        elseif command:sub(1, 9):lower() == "toolesp" then
            local toolEspEnabled = true
            local toolBillboards = {}
            
            -- Function to create ESP for tools
            local function createToolEsp(character)
                if not character then return end
                
                for _, tool in pairs(character:GetChildren()) do
                    if tool:IsA("Tool") and not toolBillboards[tool] then
                        -- Highlight the tool
                        local highlight = Instance.new("Highlight")
                        highlight.Parent = tool
                        highlight.FillTransparency = 0.5
                        highlight.OutlineColor = Color3.new(1, 0, 0)
                        
                        -- Create billboard
                        local billboard = Instance.new("BillboardGui")
                        billboard.Size = UDim2.new(0, 200, 0, 50)
                        billboard.StudsOffset = Vector3.new(0, 2, 0)
                        billboard.Adornee = tool.Handle or tool:FindFirstChildWhichIsA("BasePart") or tool.PrimaryPart
                        billboard.Parent = tool
                        
                        local label = Instance.new("TextLabel")
                        label.Size = UDim2.new(1, 0, 1, 0)
                        label.BackgroundTransparency = 1
                        label.Text = tool.Name
                        label.TextColor3 = Color3.new(1, 1, 1)
                        label.TextScaled = true
                        label.Parent = billboard
                        
                        toolBillboards[tool] = {highlight = highlight, billboard = billboard}
                    end
                end
            end
            
            -- Connect to character added event
            game:GetService("Players").PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(createToolEsp)
            end)
            
            -- Process existing players
            for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                if player.Character then
                    createToolEsp(player.Character)
                end
                player.CharacterAdded:Connect(createToolEsp)
            end
            
            result = "Started ToolEsp"
        elseif command:sub(1, 9):lower() == "untoolesp" then
            for tool, espParts in pairs(toolBillboards or {}) do
                if espParts.highlight then espParts.highlight:Destroy() end
                if espParts.billboard then espParts.billboard:Destroy() end
            end
            toolBillboards = {}
            toolEspEnabled = false
            result = "Stopped ToolEsp"
        elseif command:sub(1, 9):lower() == "unvcban" then
            local luaCode = command:sub(16)
            local func, err = game:GetService("VoiceChatService"):joinVoice()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Removed Vcban:\n"
            end
        elseif command:sub(1, 15) == "god" then
            local luaCode = command:sub(16)
            local func, err = GodModeOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Godmode Enabled:\nAny Cient-sided dmg won't hurt you"
            end
        elseif command:sub(1, 9):lower() == "adminabuse" or command:sub(1, 5):lower() == "aa" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/O/refs/heads/main/O", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Loaded HD Admin Abuser:\nOnly Works On Old Hd Admins Or Original"
            end
        elseif command:sub(1, 15) == "tptool" then
            local luaCode = command:sub(16)
            local func, err = CreateTptool()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Created TpTool:\n"
            end
        elseif command:sub(1, 15) == "ungod" then
            local luaCode = command:sub(16)
            local func, err = GodModeOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Godmode Disabled:\n"
            end
        elseif command:sub(1, 9):lower() == "serverhopper" or command:sub(1, 5):lower() == "shopper" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/igfrxx/S/refs/heads/main/S", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Loaded ServerHopper:\n[WIP]"
            end
        elseif command:sub(1, 9):lower() == "fexpanel" or command:sub(1, 5):lower() == "f3xpanel" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/SkireScripts/F3X-Panel/main/Main.lua"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Loaded F3X Panel:\n"
            end
        elseif command:sub(1, 9):lower() == "rejoin" or command:sub(1, 5):lower() == "rj" then
            local luaCode = command:sub(16)
            local func, err = Rj()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Rejoing...:\n"
            end
        elseif command:sub(1, 15) == "swordblox" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SwordBlox/refs/heads/main/SB", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "swordblox loaded:\n"
            end
        elseif command:sub(1, 15) == "sb" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/SwordBlox/refs/heads/main/SB", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "swordblox loaded:\n"
            end
        elseif command:sub(1, 15) == "aca" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Analyser/refs/heads/main/AAA", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started AntiCheat Analyser:\nShowing all AC components"
            end
        elseif command:sub(1, 9):lower() == "sethealth" or command:sub(1, 5):lower() == "sethp" then
            -- Extract value (handles both "sethealth 100" and "sethp 100")
            local valueStr
            if command:sub(1, 9):lower() == "sethealth" then
                valueStr = command:sub(11) -- "sethealth 100" → "100"
            else
                valueStr = command:sub(7)  -- "sethp 100" → "100"
            end
            local value
            
            -- Check if the value is "math.huge" or a number
            if valueStr:lower() == "math.huge" then
                value = math.huge
            else
                -- Try to convert to number
                value = tonumber(valueStr)
            end
            
            -- Get the local player's character
            local player = game:GetService("Players").LocalPlayer
            if player and player.Character then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    if value then
                        humanoid.Health = value
                        result = "Set health to " .. tostring(value)
                    else
                        result = "Invalid health value. Use a number or 'math.huge'"
                    end
                else
                    result = "No Humanoid found in character"
                end
            else
                result = "Player character not found"
            end
        elseif command:sub(1, 9):lower() == "consoleline" or command:sub(1, 5):lower() == "cline" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/igfrx/Consoleline/refs/heads/main/Cline", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "ConsoleLine Loaded:\nCool admin panel for pc users also added a toggle :)"
            end
        elseif command:sub(1, 15) == "toolcontrol" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/v0c0n1337/scripts/refs/heads/main/FE%20Tool%20control.txt"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "ToolControl Is Active:\nBest script i found so far :)"
            end
        elseif command:sub(1, 9):lower() == "autouse" or command:sub(1, 5):lower() == "au" then
            local luaCode = command:sub(16)
            local func, err = AutoS.on()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AutoUse Tool Is Enabled:\n"
            end
        elseif command:sub(1, 9):lower() == "unautouse" or command:sub(1, 5):lower() == "unau" then
            local luaCode = command:sub(16)
            local func, err = AutoS.off()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "AutoUse Tool Is Disabled:\n"
            end
        elseif command:sub(1, 9):lower() == "voidprotection" or command:sub(1, 5):lower() == "voidp" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "VoidProtection Is Enabled:\n[May not be suitable for every game]"
            end
        elseif command:sub(1, 9):lower() == "unvoidprotection" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "VoidProtection Is Disabled:\n[May not be suitable for every game]"
            end
        elseif command:sub(1, 9):lower() == "unvoidp" then
            local luaCode = command:sub(16)
            local func, err = VoidProtectionOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "VoidProtection Is Disabled:\n[May not be suitable for every game]"
            end
        elseif command:sub(1, 9):lower() == "quirkycmd" or command:sub(1, 5):lower() == "qcmd" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-QuirkyCMD-FE-admin-8667"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Loaded Quirky Cmd:\n[Ban] (REQ, Remotes)"
            end
        elseif command:sub(1, 9):lower() == "players" or command:sub(1, 5):lower() == "plrs" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/igfrxx/PlayerSeletcte/refs/heads/main/r", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Started PlayerList:\nShowing all players"
            end
        elseif command:sub(1, 9):lower() == "smol" or command:sub(1, 5):lower() == "unsmol" then
            local luaCode = command:sub(16)
            local func, err = smallhead(5)
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Secret Cmd lol:\nType in [re] to stop"
            end
        elseif command:sub(1, 9):lower() == "invis" or command:sub(1, 5):lower() == "invisible" then
            local luaCode = command:sub(16)
            local func, err = invis()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "You are now invisible:\n[This Is Quite Buggy]"
            end
        elseif command:sub(1, 9):lower() == "vis" or command:sub(1, 5):lower() == "visible" then
            local luaCode = command:sub(16)
            local func, err = vis()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "You are now visible:\n[This Is Quite Buggy]"
            end
        elseif command:sub(1, 16):lower() == "animationspeed " or command:sub(1, 3):lower() == "as " then
            local speed = tonumber(command:match("%s(.+)"))
            if speed then
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                task.spawn(function()
                    while true do
                        task.wait()
                        local humanoid = character:FindFirstChildOfClass("Humanoid") or character:FindFirstChildOfClass("AnimationController")
                        if not humanoid or not character then continue end
                        for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                            track:AdjustSpeed(speed)
                        end
                    end
                end)
                result = "[Set to 1 to reset] Animation speed set to: " .. speed
            else
                result = "Invalid animation speed. Usage: animationspeed [number]"
            end
        elseif command:sub(1, 9):lower() == "touchfling" or command:sub(1, 5):lower() == "tf" then
            local luaCode = command:sub(16)
            local func, err = TFlingOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling Enabled:\n"
            end
        elseif command:sub(1, 9):lower() == "untouchfling" or command:sub(1, 5):lower() == "untf" then
            local luaCode = command:sub(16)
            local func, err = TFlingOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TouchFling Enabled:\n"
            end
        elseif command:sub(1, 9):lower() == "console" or command:sub(1, 5):lower() == "c" then
            local luaCode = command:sub(16)
            local func, err = game:GetService("StarterGui"):SetCore("DevConsoleVisible",true)
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "showing Console:\n"
            end
        elseif command:sub(1, 9):lower() == "antifling" or command:sub(1, 5):lower() == "af" then
            local luaCode = command:sub(16)
            local func, err = afon.on
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Antifling Func:\nEnabled " .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Enabled Antifling:\n"
            end
        elseif command:sub(1, 9):lower() == "unantifling" or command:sub(1, 5):lower() == "unaf" then
            local luaCode = command:sub(16)
            local func, err = afon.on
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Antifling Func:\nDestroyed" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Disabled Antifling:\n"
            end
        elseif command:lower():sub(1, 7) == "fakelag" or command:lower():sub(1, 4) == "flag" then
            local args = command:split(" ")
            local waitTime = tonumber(args[2])
            if not waitTime then
                result = "Usage: fakelag [wait time]\nExample: fakelag 0.05"
            else
                -- Disable any existing fakelag first
                if _G.FakeLagEnabled then
                    _G.FakeLagEnabled = false
                    if _G.FakeLagThread then
                        coroutine.close(_G.FakeLagThread)
                        _G.FakeLagThread = nil
                    end
                    -- Ensure character is unanchored when disabling
                    local player = game:GetService("Players").LocalPlayer
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        player.Character.HumanoidRootPart.Anchored = false
                    end
                end
                
                _G.FakeLagEnabled = true
                _G.FakeLagWaitTime = waitTime
                
                _G.FakeLagThread = task.spawn(function()
                    local Players = game:GetService("Players")
                    local player = Players.LocalPlayer
                    
                    while _G.FakeLagEnabled do
                        local char = player.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            char.HumanoidRootPart.Anchored = true
                            task.wait(0.4) -- fixed freeze duration
                            if char and char:FindFirstChild("HumanoidRootPart") then -- double check in case character changed
                                char.HumanoidRootPart.Anchored = false
                            end
                        end
                        task.wait(_G.FakeLagWaitTime) -- uses the variable wait time
                    end
                end)
                
                result = "FakeLag enabled with wait time: " .. tostring(waitTime)
            end
        -- Command: unfakelag or unflag
        elseif command:lower() == "unfakelag" or command:lower() == "unflag" then
            if _G.FakeLagEnabled then
                _G.FakeLagEnabled = false
                if _G.FakeLagThread then
                    task.cancel(_G.FakeLagThread)
                    _G.FakeLagThread = nil
                end
                -- Ensure character is unanchored
                local player = game:GetService("Players").LocalPlayer
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.Anchored = false
                end
                result = "FakeLag disabled"
            else
                result = "FakeLag was not active"
            end
        elseif command:sub(1, 15) == "seizure" then
            local luaCode = command:sub(16)
            local func, err = Fun()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "UR HAVING A SEIZURE:\n"
            end
        elseif command:sub(1, 15) == "unseizure" then
            local luaCode = command:sub(16)
            local func, err = NoFun()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Ur not having a seizure:\n"
            end
        elseif command:sub(1, 15) == "drawchat" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/AKadminlol/Chatdraw/refs/heads/main/Chattdraw"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "someone recommended me this :/ :\n"
            end
        elseif command:sub(1, 15) == "hugtool" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/ExploitFin/Animations/refs/heads/main/Front%20and%20Back%20Hug%20Tool"))()loadstring(game:HttpGet("https://raw.githubusercontent.com/ExploitFin/Animations/refs/heads/main/Front%20and%20Back%20Hug%20Tool"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "someone recommended me this :/ :\n"
            end
        elseif command:sub(1, 15) == "drawchat" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/AKadminlol/Chatdraw/refs/heads/main/Chattdraw"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "someone recommended me this :/ :\n"
            end
        elseif command:sub(1, 7) == "hitbox " then
            local valueStr = command:sub(8)
            local value = tonumber(valueStr)
            local localPlayer = game.Players.LocalPlayer
            
            -- Table to track connections and original sizes
            if not _G.HitboxManager then
                _G.HitboxManager = {
                    connections = {},
                    originalSizes = {}
                }
            else
                -- Clean up existing connections if re-running the command
                for _, connection in pairs(_G.HitboxManager.connections) do
                    connection:Disconnect()
                end
                _G.HitboxManager.connections = {}
            end
            
            if value then
                if value == 0 then
                    -- Turn off hitboxes for all players
                    for _, player in ipairs(game.Players:GetPlayers()) do
                        if player ~= localPlayer then
                            local character = player.Character
                            if character then
                                local hrp = character:FindFirstChild("HumanoidRootPart")
                                local head = character:FindFirstChild("Head")
                                
                                -- Restore HRP properties
                                if hrp and _G.HitboxManager.originalSizes[hrp] then
                                    hrp.Size = _G.HitboxManager.originalSizes[hrp]
                                    hrp.CanCollide = true
                                    hrp.Transparency = 0
                                    _G.HitboxManager.originalSizes[hrp] = nil
                                end
                                
                                -- Restore Head properties
                                if head and _G.HitboxManager.originalSizes[head] then
                                    head.Size = _G.HitboxManager.originalSizes[head]
                                    head.CanCollide = true
                                    head.Transparency = 0
                                    _G.HitboxManager.originalSizes[head] = nil
                                end
                            end
                        end
                    end
                    result = "Hitboxes turned off for all applicable players"
                else
                    -- Function to process a character
                    local function processCharacter(player, character)
                        if not character then return end
                        
                        local shouldModify = false
                        if game.Teams and #game.Teams:GetTeams() > 0 then
                            shouldModify = player.Team ~= localPlayer.Team
                        else
                            shouldModify = true
                        end
                        
                        if shouldModify then
                            local hrp = character:WaitForChild("HumanoidRootPart", 5)
                            local head = character:FindFirstChild("Head")
                            
                            -- Handle HRP
                            if hrp then
                                if not _G.HitboxManager.originalSizes[hrp] then
                                    _G.HitboxManager.originalSizes[hrp] = hrp.Size
                                end
                                hrp.Size = Vector3.new(value, value, value)
                                hrp.CanCollide = false
                                hrp.Transparency = 0.5
                            end
                            
                            -- Handle Head
                            if head then
                                if not _G.HitboxManager.originalSizes[head] then
                                    _G.HitboxManager.originalSizes[head] = head.Size
                                end
                                head.Size = Vector3.new(value, value, value)
                                head.CanCollide = false
                                head.Transparency = 0.5
                            end
                        end
                    end
                    
                    -- Process existing players
                    for _, player in ipairs(game.Players:GetPlayers()) do
                        if player ~= localPlayer then
                            if player.Character then
                                processCharacter(player, player.Character)
                            end
                            
                            -- Connect to character added event
                            table.insert(_G.HitboxManager.connections, player.CharacterAdded:Connect(function(character)
                                processCharacter(player, character)
                            end))
                        end
                    end
                    
                    -- Connect to player added event
                    table.insert(_G.HitboxManager.connections, game.Players.PlayerAdded:Connect(function(player)
                        if player ~= localPlayer then
                            if player.Character then
                                processCharacter(player, player.Character)
                            end
                            
                            table.insert(_G.HitboxManager.connections, player.CharacterAdded:Connect(function(character)
                                processCharacter(player, character)
                            end))
                        end
                    end))
                    
                    result = "Hitboxes expanded to " .. value .. ". Type 'hitbox 0' to reset."
                end
            else
                result = "Invalid value. Usage: hitbox [number] or hitbox 0 to turn off"
            end
        elseif command:sub(1, 15) == "susgui" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/TmcdSusGu182-hi/refs/heads/main/GuiLol", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "🍆💦:\n"
            end
        elseif command:sub(1, 15) == "ss" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/TmcdSusGu182-hi/refs/heads/main/GuiLol", true))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "🍆💦:\n"
            end
        elseif command:sub(1, 15) == "aat" then
            local luaCode = command:sub(16)
            local func, err = AAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Activated All Tools:\n"
            end
        elseif command:sub(1, 15) == "activatealltools" then
            local luaCode = command:sub(16)
            local func, err = AAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Activated All Tools:\n"
            end
        elseif command:sub(1, 15) == "dat" then
            local luaCode = command:sub(16)
            local func, err = DAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Dropped All Tools:\n"
            end
        elseif command:sub(1, 15) == "dropalltools" then
            local luaCode = command:sub(16)
            local func, err = DAT()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Dropped All Tools:\n"
            end

        elseif command:sub(1, 14) == "hitbox" then
            local luaCode = command:sub(15)
            local func, err = hitboxeson()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Expanded:\nHrp or head has been expanded"
            end
        elseif command:sub(1, 14) == "unhitbox" then
            local luaCode = command:sub(15)
            local func, err = hitboxesoff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "DeExpanded:\nHrp or head size is set to normal"
            end
        elseif command:sub(1, 14) == "emitteroff" then
            local luaCode = command:sub(15)
            local func, err = EmitterOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter On:\n"
            end
        elseif command:sub(1, 14) == "en" then
            local luaCode = command:sub(15)
            local func, err = EmitterOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter On:\n"
            end
        elseif command:sub(1, 14) == "ef" then
            local luaCode = command:sub(15)
            local func, err = EmitterOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Emitter Off:\n"
            end
        elseif command:sub(1, 15) == "noclip" then
            local luaCode = command:sub(17)
            local func, err = ModeOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Noclip:\nWalk thru Walls"
            end
        elseif command:sub(1, 15) == "clip" then
            local luaCode = command:sub(17)
            local func, err = ModeOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Clipped:\nWalk Thru Walls Is Disabled"
            end
        elseif command:sub(1, 15) == "namelessadmin" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminIsActive:\n"
            end
        elseif command:sub(1, 15) == "na" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminIsActive:\n"
            end
        elseif command:sub(1, 15) == "namelessadminv2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminV2IsActive:\n"
            end
        elseif command:sub(1, 15) == "nav2" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "NamelessAdminV2IsActive:\n"
            end
        elseif command:sub(1, 15) == "telekinesis" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TelekinesisIsActive:\n"
            end
        elseif command:sub(1, 15) == "tk" then
            local luaCode = command:sub(16)
            local func, err = loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "TelekinesisIsActive:\n"
            end
        elseif command:sub(1, 13) == "f3x" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "GetGear rbxassetid://6695644299:\nF3X is active"
            end
        elseif command:sub(1, 13) == "winobby" then
            local luaCode = command:sub(14)
            local func, err = TPCheckpoints()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "Finished Obby:\nMay Not Work On Some (Games)"
            end
        elseif command:sub(1, 13) == "fex" then
            local luaCode = command:sub(14)
            local func, err = loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "GetGear rbxassetid://6695644299:\nF3X is active"
            end
        elseif command:sub(1, 13) == "esp" then
            local luaCode = command:sub(14)
            local func, err = EspOn()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "EspIsEnabled:\nEsp On"
            end
        elseif command:sub(1, 13) == "unesp" then
            local luaCode = command:sub(14)
            local func, err = EspOff()
            if func then
                local success, execResult = pcall(func)
                if success then
                    result = "Executed successfully:\n" .. tostring(execResult)
                else
                    result = "Execution error:\n"
                end
            else
                result = "EspIsDisabled:\nEsp Off"
            end
        elseif command:sub(1, 5) == "grav " then
            local grav = tonumber(command:sub(6))
            if grav and grav > 0 then
                workspace.Gravity = grav
                result = "Gravity set to "..grav
            else
                result = "Invalid gravity. Use: grav [number]"
            end
        elseif command == "time" then
        local time = os.date("*t")
        result = string.format("Current time: %02d:%02d:%02d", time.hour, time.min, time.sec)
        
        elseif command == "date" then
        local date = os.date("*t")
        result = string.format("Today's date: %d/%d/%d", date.month, date.day, date.year)
        elseif command == "ping" then
        result = "Pong! TerminalCmd is running smoothly"
        
        elseif command == "fps" then
        local fps = 1/game:GetService("RunService").RenderStepped:Wait()
        result = string.format("Current FPS: %.1f", fps)
        elseif command:sub(1, 8) == "infjump" then
            local infiniteJumpEnabled = not _G.infiniteJumpEnabled
            _G.infiniteJumpEnabled = infiniteJumpEnabled
    
            if infiniteJumpEnabled then
                game:GetService("UserInputService").JumpRequest:Connect(function()
                    game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
                end)
                result = "Infinite jump enabled"
            else
                result = "Infinite jump disabled"
            end
        elseif command == "stoptpwalk" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StopTpWalk()
                result = "TP Walk Disabled"
            end
        elseif command == "stpw" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StopTpWalk()
                result = "TP Walk Disabled"
            end
        elseif command == "tpwalk" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StartTpWalk()
                result = "TP Walk enabled."
            end
        elseif command == "tpw" then
            if tpwalking then
                StopTpWalk()
                result = "TP Walk disabled."
            else
                StartTpWalk()
                result = "TP Walk Enabled."
            end
        elseif command:lower():find("^tpws ") or command:lower():find("^tpwalkspeed ") then
            local speed = tonumber(command:match("%d+"))
            if speed and speed > 0 then
                tpSpeed = speed
                result = "TP Speed set to " .. speed
            else
                result = "Invalid speed (use numbers > 0)"
            end
        elseif command:sub(1, 10) == "fullbright" then
            -- Enable fullbright (remove lighting effects)
            game:GetService("Lighting").GlobalShadows = false
            game:GetService("Lighting").Brightness = 2
            game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
            result = "Full Bright Is Enabled"
        elseif command:sub(1, 12) == "unfullbright" then
            -- Reset lighting to default values
            game:GetService("Lighting").GlobalShadows = true
            game:GetService("Lighting").Brightness = 1
            game:GetService("Lighting").Ambient = Color3.new(0.5, 0.5, 0.5)
            result = "Full Bright Is Disabled"
        elseif command:sub(1, 10) == "fb" then
            -- Enable fullbright (remove lighting effects)
            game:GetService("Lighting").GlobalShadows = false
            game:GetService("Lighting").Brightness = 2
            game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
            result = "Full Bright Is Enabled"
        elseif command:sub(1, 12) == "unfb" then
            -- Reset lighting to default values
            game:GetService("Lighting").GlobalShadows = true
            game:GetService("Lighting").Brightness = 1
            game:GetService("Lighting").Ambient = Color3.new(0.5, 0.5, 0.5)
            result = "Full Bright Is Disabled"
        elseif command == "xray" then
            enableXRay()
            result = "XRay enabled."
        elseif command == "unxray" then
            disableXRay()
            result = "XRay disabled."
        end

        -- Add the result to the output
        outputText.Text = outputText.Text .. "\n" .. result

        -- Auto-scroll to the bottom
        outputFrame.CanvasPosition = Vector2.new(0, outputText.TextBounds.Y)
    end

    -- Connect the input box to the handleInput function
    inputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            handleInput(inputBox)
        end
    end)

    -- Allow the user to press Enter to submit the command
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if input.KeyCode == Enum.KeyCode.Return and inputBox:IsFocused() then
            handleInput(inputBox)
        end
    end)
    
    -- Dragging functionality
    local gui = mainFrame -- Change this to the UI element you want to make draggable

    local dragging
    local dragStart
    local startPos
    local lastMousePos
    local lastGoalPos
    local DRAG_SPEED = 8 -- Adjust for smoother or faster dragging

    local function Lerp(a, b, m)
        return a + (b - a) * m
    end

    local function Update(dt)
        if not startPos then return end
        if not dragging and lastGoalPos then
            gui.Position = UDim2.new(
                startPos.X.Scale,
                Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED),
                startPos.Y.Scale,
                Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED)
            )
            return
        end

        local delta = lastMousePos - UserInputService:GetMouseLocation()
        local xGoal = startPos.X.Offset - delta.X
        local yGoal = startPos.Y.Offset - delta.Y
        lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)

        gui.Position = UDim2.new(
            startPos.X.Scale,
            Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED),
            startPos.Y.Scale,
            Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED)
        )
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position
            lastMousePos = UserInputService:GetMouseLocation()

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    RunService.Heartbeat:Connect(Update)

    print("Script completed")
end

    -- Initial UI creation
    createUI()

    -- Destroy UI when the player dies
    player.CharacterRemoving:Connect(destroyUI)

    -- Recreate UI when the player respawns
    player.CharacterAdded:Connect(createUI)
end)
end)

if not success then
    warn("Error caught:", err) -- Prevents full error log spam
    createNotification("⚠️ Error Caught: " .. err, 5, "rbxassetid://1234567890") -- Replace with an appropriate image asset ID
end
end)
end)

-- [ LoadsScriptResources ]
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LoadResources/refs/heads/main/ResSourcesLoaderSource", true))()
warn("StartedScript")
end)
